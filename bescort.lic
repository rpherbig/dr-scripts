=begin
  Suggestions and contributions are welcome: https://github.com/rpherbig/dr-scripts
=end

custom_require(%w(common drinfomon events))

class MazeRoom
  @@cardinals = { 'n' => 's', 's' => 'n', 'ne' => 'sw', 'sw' => 'ne', 'nw' => 'se', 'se' => 'nw', 'e' => 'w', 'w' => 'e' }
  @@adjustments = { 'n' => [0, 1], 's' => [0, -1], 'ne' => [1, 1], 'sw' => [-1, -1], 'nw' => [-1, 1], 'se' => [1, -1], 'e' => [1, 0], 'w' => [-1, 0] }

  attr_accessor :desc, :exits, :checked, :parent, :coords

  def initialize(came_from = nil, source_room = nil)
    if came_from
      @exits = { @@cardinals[came_from] => source_room }
      source_room.exits[came_from] = self
      @coords = update_coords(source_room.coords, came_from)
    else
      @@RoomList = []
      @exits = {}
      @coords = [0, 0]
    end

    populate_exits
    @@RoomList << self
  end

  def find_room_by_coords(coords)
    @@RoomList.find { |room| room.coords == coords }
  end

  def update_coords(coords, traveled)
    [coords.first + @@adjustments[traveled].first, coords.last + @@adjustments[traveled].last]
  end

  def best_path
    @@RoomList.each { |room| room.checked = false; room.parent = nil }
    @checked = true
    queue = [self]
    until queue.empty?
      current = queue.shift
      current.exits.each do |dir, child|
        return current.parent || dir if child.nil?
        next if child.checked
        child.checked = true
        child.parent = current.parent || dir
        queue << child
      end
    end
  end

  def condense_direction(direction)
    direction.gsub(/orth|est|ast|outh/i, '')
  end

  def populate_exits
    remaining_exits = XMLData.room_exits.map { |exit| condense_direction(exit) } - @exits.keys

    remaining_exits.each do |exit|
      @exits[exit] = nil
    end
  end

  def wander
    dir_to_go = @exits.keys.first if @exits.size == 1
    dir_to_go, = @exits.find { |_, room| room.nil? } unless dir_to_go
    dir_to_go, = best_path unless dir_to_go

    fix_standing
    retreat
    move(dir_to_go)
    pause

    return @exits[dir_to_go] if @exits[dir_to_go]

    if existing_room = find_room_by_coords(update_coords(@coords, dir_to_go))
      @exits[dir_to_go] = existing_room
      existing_room.exits[@@cardinals[dir_to_go]] = self
      return existing_room
    end

    MazeRoom.new(dir_to_go, self)
  end
end

class Bescort
  include DRC

  def initialize(area, mode)
    case area
    when /wilds/i
      wilds(mode)
    when /northern_trade/i
      northern_trade(mode)
    when /faldesu/i
      faldesu(mode)
    when /zaulfang/i
      zaulfang(mode)
    end
  end

  private

  def manual_go2(goal_room)
    path = Map.findpath(Room.current.id, Map[goal_room])
    path.each { |step| move Room.current.wayto[step.to_s] }
  end

  def search
    fput('search')
    pause
    waitrt?
    retreat
  end

  def search_path(pathname, visible = true, movetype = 'go')
    if visible
      loop do
        search until DRRoom.room_objs.find { |obj| obj.include?(pathname) }
        break if move "#{movetype} #{pathname}"
        pause
      end
      pause
    else
      search
      until move "#{movetype} #{pathname}"
        pause
        search
      end
    end
  end

  def move_direction?(dir_priority)
    if choice = dir_priority.find { |dir| XMLData.room_exits.include?(dir) }
      retreat
      move choice
      true
    else
      false
    end
  end

  def find_room_maze(valid_move = proc { |_| true }, error_rooms = {})
    loop do
      error_rooms[Room.current.id].call if error_rooms[Room.current.id]
      return if DRRoom.pcs.empty? && DRRoom.npcs.empty?
      exits = XMLData.room_exits.dup.shuffle
      exits.rotate! until valid_move.call(exits.first)
      retreat
      move exits.first
    end
  end

  def find_room_list(moves)
    moves.each do |dir|
      break if DRRoom.pcs.empty? && DRRoom.npcs.empty?
      retreat
      move dir
    end
  end

  def wilds(mode)
    if mode !~ /exit/i && Room.current.id != 1176
      echo('Wilds script must be started from 1176')
      exit
    end
    case mode
    when /exit/i
      retreat
      wilds_leave
    when /leucro1/i
      wilds_enter
      find_room_maze(proc { |dir| !(XMLData.room_exits == %w(east south northwest) && dir == 'northwest') }, 7958 => proc { search_path('spot') })
    when /leucro2/i
      wilds_enter
      wilds_leucro_maze(true)
      find_room_list(%w(se s se sw sw sw w w w w s se))
    when /geni/i
      wilds_enter
      wilds_leucro_maze(true)
      wilds_leucro_walk
      find_room_maze
    end
  end

  def wilds_enter
    move 'go path'
    pause
    search_path('trail')
    search_path('trail')
    search_path('trail')
    search_path('spot')
  end

  def wilds_leucro_walk
    attempts = 0
    until XMLData.room_description.include?('small creatures still lurk beneath its surface -- perhaps following the remnant of an old, long unused trail.')
      move_direction?(%w(southeast south southwest west))
      pause 0.5
      attempts += 1
      if attempts == 50
        echo 'Train your perception!'
        exit
      end
    end
    search_path('trail', false)
  end

  def wilds_leucro_maze(entering)
    if entering
      pause 0.5 while move_direction?(%w(northeast east north southeast))
      move 'go dead'
    else
      pause 0.5 while move_direction?(%w(northwest west north))
    end
  end

  def wilds_leave_trail
    pause 0.5 while move_direction?(%w(northeast north northwest east south))
    move 'go dead'
  end

  def wilds_leave
    if XMLData.room_exits.length <= 2 || XMLData.room_exits == %w(east southeast northwest)
      wilds_leave_trail
    end
    pause 0.5 while move_direction?(%w(northwest west north))
    unless Room.current.id == 7958
      search_path('trail', false)
      wilds_leave_trail
      pause 0.5 while move_direction?(%w(northwest west north))
    end
    search_path('trail')
    move 'n'
    move 'n'
    search_path('path')
  end

  def northern_trade(mode)
    if mode !~ /exit/i && Room.current.id != 1176
      echo('Northern trade route script must be started from 1176')
      exit
    end
    case mode
    when /exit/i
      retreat
      northern_trade_leave
    when /rock_guardians/i
      northern_trade_enter
      wait_for_script_to_complete('go2', ['19154'])
      find_room_list(['climb fall', 'nw', 'nw', 'w', 'sw', 's', 'se', 'se'])
    end
  end

  def northern_trade_enter
    move 'go path'
    pause
    search_path('trail')
    search_path('trail')
    search_path('trail')
    search_path('tracks', false)
  end

  def northern_trade_leave
    loop do
      case Room.current.id
      when 6830
        break
      when 1386 # Handle broken room
        retreat
        ['nw', 'nw', 'n', 'ne', 'e', 'se', 'se', 'climb fall'].each { |dir| move dir }
      end
      retreat
      wait_for_script_to_complete('go2', ['6830'])
    end
    search_path('tracks', false)
    search_path('trail')
    move 'n'
    move 'n'
    search_path('path')
  end

  def faldesu(mode)
    unless mode =~ /haven|crossing/i
      echo 'You must specify haven or crossing for traversing the faldesu river'
      exit
    end

    if DRSkill.getrank('Athletics').to_i >= 120
      swim_faldesu(mode =~ /haven/i)
    else
      take_rh_ferry(mode =~ /haven/i)
    end
  end

  def swim(dir)
    move dir
    pause
    waitrt?
  end

  def swim_faldesu(north)
    start = north ? 1375 : 473
    manual_go2(start)
    moveset = north ? %w(north northwest northeast) : %w(south southwest southeast)
    move 'dive river'
    swim(moveset[0]) while XMLData.room_exits.include?(moveset[0])

    swim(moveset[1]) while XMLData.room_exits.include?('east')

    swim(moveset[2]) while XMLData.room_exits.include?(moveset[0])

    move 'climb bridge'
  end

  def take_rh_ferry(north)
    if north
      manual_go2(1385)
    else
      manual_go2(470)
    end
    case bput('go ferry', 'You .* climb aboard', 'Come back when you can afford the fare', 'not here')
    when /not here/
      waitfor 'pulls into the dock'
      take_rh_ferry(north)
    when /climb aboard/
      waitfor 'reaches the dock and its crew ties the ferry off'
      fput('go dock')
    end
  end

  def zaulfang(mode)
    Flags.add('zfswamp-reset', 'The noxious swamp gas takes its toll on your mind, and your surroundings seem to shift as you grow immensely dizzy')
    case mode
    when /enter/i
      unless Room.current.id == 8540
        echo('Must enter Zaulfang swamp from 8540')
        exit
      end
      move('go path')
      pause
      wander_maze_until('sickly tree that looms far above the swamp', 'climb tree')
    when /exit/i
      unless Room.current.id == 19_415
        echo('Must exit Zaulfang swamp from 19415')
        exit
      end
      move('down')
      pause
      wander_maze_until('curving path', 'go path')
    end
  end

  def wander_maze_until(target, exit_command)
    current_room = MazeRoom.new
    loop do
      if Flags['zfswamp-reset']
        Flags.reset('zfswamp-reset')
        result = bput('look', 'Obvious paths:.*').split(':').last.split(', ').first
        retreat
        move(result)
        pause
        current_room = MazeRoom.new
      end

      if DRRoom.room_objs.include?(target)
        unless move(exit_command)
          fix_standing
          wander_maze_until(target, exit_command)
        end
        return
      end
      current_room = current_room.wander
    end
  end
end

unless variable.length == 3
  echo('Invalid arguments, please provide an area and a mode')
  exit
end

Bescort.new(variable[1], variable[2])
