=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#combat-trainer
=end
custom_require.call(%w[common common-arcana common-healing common-items common-summoning common-theurgy common-moonmage common-travel equipmanager events spellmonitor])

class SetupProcess
  def initialize(settings, equipment_manager)
    @equipment_manager = equipment_manager
    echo('New SetupProcess') if $debug_mode_ct

    @stance_override = settings.stance_override
    echo("  @stance_override: #{@stance_override}") if $debug_mode_ct
    @priority_defense = settings.priority_defense
    echo("  @priority_defense: #{@priority_defense}") if $debug_mode_ct
    @priority_weapons = settings.priority_weapons
    echo("  @priority_weapons: #{@priority_weapons}") if $debug_mode_ct
    @cycle_armors = settings.cycle_armors
    echo("  @cycle_armors: #{@cycle_armors}") if $debug_mode_ct
    @cycle_armors_time = settings.cycle_armors_time
    echo("  @cycle_armors_time: #{@cycle_armors_time}") if $debug_mode_ct
    @armor_hysteresis = settings.cycle_armors_hysteresis
    echo("  @armor_hysteresis: #{@armor_hysteresis}") if $debug_mode_ct
    @last_cycle_time = Time.now - @cycle_armors_time
    @combat_training_abilities_target = settings.combat_training_abilities_target
    echo("  @combat_training_abilities_target: #{@combat_training_abilities_target}") if $debug_mode_ct
    @cycle_regalia = settings.cycle_armors_regalia
    echo("  @cycle_regalia: #{@cycle_regalia}") if $debug_mode_ct
    @default_armor = settings.default_armor_type
    echo("  @default_armor: #{@default_armor}") if $debug_mode_ct
    @ignore_weapon_mindstate = settings.combat_trainer_ignore_weapon_mindstate
    echo("  @ignore_weapon_mindstate: #{@ignore_weapon_mindstate}") if $debug_mode_ct
    @gearsets = settings.gear_sets

    validate_regalia(settings)
  end

  def execute(game_state)
    return true if game_state.done_cleaning_up?

    if game_state.stowing?
      echo('SetupProcess::clean_up') if $debug_mode_ct
      DRC.retreat
      if game_state.summoned_info(game_state.weapon_skill)
        if DRStats.moon_mage?
          DRCMM.wear_moon_weapon?
        else
          DRCS.break_summoned_weapon(game_state.weapon_name)
        end
      else
        @equipment_manager.stow_weapon(game_state.weapon_name)
        game_state.sheath_whirlwind_offhand
      end
      game_state.next_clean_up_step
      return true
    end

    was_retreating = game_state.retreating?
    game_state.update_room_npcs
    if game_state.dancing?
      game_state.dance
    elsif game_state.retreating?
      determine_next_to_train(game_state, game_state.retreat_weapons, false)
    else
      determine_next_to_train(game_state, game_state.weapon_training, was_retreating)
    end

    if game_state.parrying
      # If parrying, determine your next stance (e.g. evasion or shield)
      # then switch to your new weapon. This ensures you have a weapon in hand
      # to parry with while you're stanced to parry.
      check_stance(game_state)
      check_weapon(game_state)
    else
      # And vice versa, if you're not parrying but you might stance to that next
      # then ensure you have a weapon in hand then choose an appropriate stance.
      # This also ensures the stance you choose respects any weapon-stance overrides.
      check_weapon(game_state)
      check_stance(game_state)
    end

    @cycle_regalia ? check_regalia_swap(game_state) : check_armor_swap(game_state)
    false
  end

  private

  def armor_hysteresis?(game_state)
    return false unless @armor_hysteresis
    return false if @cycle_armors.keys.any? { |skill| DRSkill.getxp(skill) < 25 }

    all_swap_pieces = @cycle_armors.keys.map { |armortype| @cycle_armors[armortype] }.flatten
    if @cycle_armors.keys.all? { |skill| DRSkill.getxp(skill) > 32 }
      if @last_worn_type != @default_armor && @cycle_armors.keys.include?(@default_armor)
        game_state.sheath_whirlwind_offhand
        @equipment_manager.worn_items(all_swap_pieces).each { |item| @equipment_manager.remove_item(item) }
        @equipment_manager.wear_items(@equipment_manager.desc_to_items(@cycle_armors[@default_armor]))
        @last_worn_type = @default_armor
        game_state.wield_whirlwind_offhand
      end
    end
    true
  end

  def regalia_hysteresis?(game_state)
    return false unless @armor_hysteresis
    # Override hysteresis logic if regalia is about to expire.
    return false if @cycle_regalia.any? { |skill| DRSkill.getxp(skill) < 22 } || game_state.last_regalia_type.nil? || Flags['ct-regalia-expired']

    if @cycle_regalia.all? { |skill| DRSkill.getxp(skill) > 24 } && game_state.last_regalia_type != @default_armor
      return false if Time.now - @last_cycle_time < @cycle_armors_time

      game_state.swap_regalia_type = @cycle_regalia.include?(@default_armor) ? @default_armor : @cycle_regalia.max_by { |skill| DRSkill.getrank(skill) } # If no default type declared, go by the highest rank.
    end
    true
  end

  def check_armor_swap(game_state)
    return if armor_hysteresis?(game_state)
    return if Time.now - @last_cycle_time < @cycle_armors_time
    return if game_state.loaded

    armor_types = @cycle_armors.map { |skill, _| skill }
    next_armor_type = game_state.sort_by_rate_then_rank(armor_types).first
    return if next_armor_type == @last_worn_type
    return if DRSkill.getxp(next_armor_type) >= @combat_training_abilities_target

    @last_cycle_time = Time.now

    game_state.sheath_whirlwind_offhand

    if @last_worn_type
      @equipment_manager.desc_to_items(@cycle_armors[@last_worn_type]).each { |item| @equipment_manager.remove_item(item) }
    else
      all_swap_pieces = @cycle_armors.map { |_, pieces| pieces }.flatten
      @equipment_manager.worn_items(all_swap_pieces).each { |item| @equipment_manager.remove_item(item) }
    end

    @equipment_manager.wear_items(@equipment_manager.desc_to_items(@cycle_armors[next_armor_type]))

    @last_worn_type = next_armor_type

    game_state.wield_whirlwind_offhand
  end

  def check_regalia_swap(game_state)
    return if regalia_hysteresis?(game_state)
    return if Time.now - @last_cycle_time < @cycle_armors_time && !Flags['ct-regalia-expired']

    # if CT is done with regalia (usually starlight depleted) don't process anymore until it starts to expire naturally, then close it down.
    if game_state.regalia_cancel
      regalia_shutdown(game_state) if Flags['ct-regalia-expired']
      return
    end
    armor_types = @cycle_regalia
    next_armor_type = game_state.sort_by_rate_then_rank(armor_types).first
    return unless Flags['ct-regalia-expired'] || next_armor_type != @last_worn_type
    return unless Flags['ct-regalia-expired'] || game_state.last_regalia_type.nil? || DRSkill.getxp(next_armor_type) < @combat_training_abilities_target

    @last_cycle_time = Time.now
    game_state.swap_regalia_type = next_armor_type # Mark for SpellProcess casting in check_regalia
  end

  def determine_next_to_train(game_state, weapon_training, ending_ranged)
    return unless game_state.skill_done? || !weapon_training[game_state.weapon_skill] || ending_ranged

    unless @ignore_weapon_mindstate
      # check if all weapons are maxed exp to prevent rapid cycling
      if weapon_training.reject { |skill, _| DRSkill.getxp(skill) == 34 }.empty?
        echo 'all weapons locked, not switching' if $debug_mode_ct
        return
      end
    end

    echo('new skill needed for training') if $debug_mode_ct

    game_state.reset_action_count

    # If you're training with summoned moon weapons but you haven't cast the moonblade spell yet
    # then skip those weapon skills and train something else while we wait for moonblade spell to be cast.
    if DRStats.moon_mage? && !game_state.summoned_weapons.empty? && DRCMM.moon_used_to_summon_weapon.nil?
      echo('skipping summoned weapons because no moonblade available') if $debug_mode_ct
      weapon_training = weapon_training.reject { |skill, _| game_state.summoned_info(skill) }
    end

    # Exclude current skill so that a new one is selected.
    new_weapon_skills = weapon_training.keys.reject { |skill| skill == game_state.weapon_skill }
    new_weapon_skill = game_state.sort_by_rate_then_rank(new_weapon_skills, @priority_weapons).first

    # Update weapon skill to train next, if a new one was chosen.
    # If you're training exactly one weapon then won't change.
    game_state.update_weapon_info(new_weapon_skill) if new_weapon_skill
    game_state.update_target_weapon_skill
  end

  def last_stance
    Flags['last-stance'][0] =~ /(\d+)%.* (\d+)%.* (\d+)%.* (\d+)/
    { 'EVASION' => Regexp.last_match(1).to_i, 'PARRY' => Regexp.last_match(2).to_i, 'SHIELD' => Regexp.last_match(3).to_i, 'SPARE' => Regexp.last_match(4).to_i }
  end

  def build_stance_string(vals)
    "stance set #{vals['EVASION']} #{vals['PARRY']} #{vals['SHIELD']}"
  end

  def check_stance(game_state, override = nil)
    return if @override_done && !game_state.reset_stance

    if @stance_override
      game_state.reset_stance = false
      pause
      waitrt?
      DRC.bput("stance set #{@stance_override}", 'Setting your')
      @override_done = true
      return
    end
    vals = { 'EVASION' => 0, 'PARRY' => 0, 'SHIELD' => 0, 'SPARE' => 0 }
    skill_map = { 'Parry Ability' => 'Parry', 'Shield Usage' => 'Shield' }
    previous = last_stance
    points = override || previous.values.inject(&:+)

    priority = if game_state.current_weapon_stance
                 if game_state.strict_weapon_stance
                   # Player wants their weapon stance strictly adhered to, no change.
                   game_state.current_weapon_stance
                 else
                   # Player has a preference for the first two stances for this weapon
                   # and is open to having them dynamically prioritized to optimize learning.
                   game_state.sort_by_rate_then_rank(game_state.current_weapon_stance[0..1]) + [game_state.current_weapon_stance.last]
                 end
               elsif @priority_defense
                 # Player does not have a weapon specific stance but does want
                 # a preferred defense to always be 100%.
                 rest = ['Evasion', 'Parry Ability', 'Shield Usage'] - [@priority_defense]
                 [@priority_defense] + game_state.sort_by_rate_then_rank(rest)
               else
                 # Player is a gambler and wants combat-trainer to dynamically
                 # prioritize the stances with the lowest learning rates/ranks.
                 game_state.sort_by_rate_then_rank(['Evasion', 'Parry Ability', 'Shield Usage'])
               end

    game_state.parrying = priority.index('Parry Ability') < 2

    priority.each do |skill|
      skill = skill_map[skill] if skill_map[skill]
      vals[skill.upcase] = points >= 100 ? 100 : points
      points -= vals[skill.upcase]
    end

    return if vals == previous
    return unless /maximum number of points \((\d+)/ =~ DRC.bput(build_stance_string(vals), 'Setting your Evasion stance to', 'is above your maximum number of points \(\d+')

    check_stance(game_state, Regexp.last_match(1).to_i)
  end

  def check_weapon(game_state)
    return if @last_seen_weapon_skill == game_state.weapon_skill

    @last_seen_weapon_skill = game_state.weapon_skill

    echo("checking weapons as #{game_state.last_weapon_skill.inspect}!=#{game_state.weapon_skill}") if $debug_mode_ct

    last_summoned = game_state.summoned_info(game_state.last_weapon_skill)
    next_summoned = game_state.summoned_info(game_state.weapon_skill)

    # Clean up the previous weapon
    if !last_summoned
      @equipment_manager.stow_weapon(game_state.last_weapon_name)
      game_state.sheath_whirlwind_offhand
    elsif !next_summoned && !DRStats.moon_mage?
      DRCS.break_summoned_weapon(game_state.last_weapon_name)
    elsif !next_summoned && DRStats.moon_mage?
      DRCMM.wear_moon_weapon?
    end

    # Reset state that was specific to the prior weapon.
    # This prevents, for example, attempting to do a powershot maneuver
    # as soon as you equip another ranged weapon before you've had
    # a chance to load it because the game_state thinks you're still holding a loaded weapon.
    game_state.loaded = false
    @firing_check = 0

    # Prepare the next weapon
    if next_summoned
      game_state.prepare_summoned_weapon(last_summoned)
    else
      DRC.bput('aim stop', "But you're not aiming", 'You stop concentrating', 'You are already') if game_state.aimed_skill?
      game_state.wield_weapon
      if game_state.whirlwind_trainable?
        game_state.currently_whirlwinding = true
        determine_whirlwind_weapon(game_state)
        echo("Combat-Trainer:: Whirlwinding with -=== MAIN: #{game_state.weapon_skill}  OFF: #{game_state.whirlwind_offhand_skill} ===-") if $debug_mode_ct
      else
        game_state.currently_whirlwinding = false
      end
    end

    # Invoke Focus
    return unless game_state.weapon_skill == 'Targeted Magic' && game_state.weapon_name
    return unless DRCI.get_item?(game_state.weapon_name)

    DRC.bput("invoke #{game_state.weapon_name}", 'You')
    waitrt?
  end

  def determine_whirlwind_weapon(game_state)
    return if game_state.twohanded_weapon_skill?

    offhand_skill = game_state.determine_whirlwind_weapon_skill
    game_state.update_whirlwind_weapon_info(offhand_skill)
    game_state.wield_whirlwind_offhand
  end

  def validate_regalia(settings)
    return unless @cycle_regalia

    if @cycle_armors
      DRC.message 'ERROR - Regalia cycling and armorswap cycling at the same time not currently supported!  Removing Regalia from combat-training!'
      @cycle_regalia = nil
    end

    if settings.gear_sets['regalia'].empty? || settings.gear_sets['regalia'].nil?
      DRC.message "ERROR - Regalia cycling requires a gear_set named 'regalia' that will be worn immediately before casting. Removing Regalia from combat-training!"
      @cycle_regalia = nil
    end
    # reset swap clock if you start CT already wearing a regalia.
    @last_cycle_time = Time.now unless DRCA.parse_regalia.empty?
  end

  def regalia_shutdown(game_state)
    DRCA.shatter_regalia?
    game_state.last_regalia_type = nil
    game_state.swap_regalia_type = nil
    game_state.regalia_cancel = nil
    @cycle_regalia = nil
    Flags.reset('ct-regalia-expired')
    @equipment_manager.wear_equipment_set?('standard')
    @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill) if @gearsets['standard'].include?(game_state.weapon_name) # The above will put away worn weapons
  end
end

class LootProcess
  def initialize(settings, equipment_manager)
    @equipment_manager = equipment_manager
    echo('New LootProcess') if $debug_mode_ct
    skinning = settings.skinning

    @worn_trashcan = settings.worn_trashcan
    echo("  @worn_trashcan: #{@worn_trashcan}") if $debug_mode_ct

    @worn_trashcan_verb = settings.worn_trashcan_verb
    echo("  @worn_trashcan_verb: #{@worn_trashcan_verb}") if $debug_mode_ct

    @skin = skinning['skin'] || false
    echo("  @skin: #{@skin}") if $debug_mode_ct

    @dissect = skinning['dissect'] || false
    echo("  @dissect: #{@dissect}") if $debug_mode_ct

    @dissect_priority = skinning['dissect_priority']
    echo("  @dissect_priority: #{@dissect_priority}") if $debug_mode_ct

    @dissect_for_thanatology = skinning['dissect_for_thanatology'] || false
    echo("  @dissect_for_thanatology: #{@dissect_for_thanatology}") if $debug_mode_ct

    @dissect_retry_once = skinning['dissect_retry_once'] || false
    echo("  @dissect_retry_once: #{@dissect_retry_once}") if $debug_mode_ct

    @dissect_cycle_skills = []
    @dissect_cycle_skills.append("Thanatology") if @dissect_for_thanatology
    @dissect_cycle_skills.append("First Aid") if @dissect
    @dissect_cycle_skills.append("Skinning") if @skin
    echo("  @dissect_cycle_skills: #{@dissect_cycle_skills}") if $debug_mode_ct

    # Setting to determine whether to always arrange, regardless of skinning, or dissecting
    # Depending on the creature level, and the character's skinning skill, simply arranging will teach skinning
    # Defaulting to true to keep existing behaviour.
    @arrange_for_dissect = skinning['arrange_for_dissect'].nil? ? true : skinning['arrange_for_dissect']
    echo("  @arrange_for_dissect: #{@arrange_for_dissect}") if $debug_mode_ct

    @arrange_all = skinning['arrange_all'] || false
    echo("  @arrange_all: #{@arrange_all}") if $debug_mode_ct

    @arrange_count = if @arrange_all
                       1
                     else
                       skinning['arrange_count'] || 0
                     end
    echo("  @arrange_count: #{@arrange_count}") if $debug_mode_ct

    @tie_bundle = skinning['tie_bundle'] || false
    echo("  @tie_bundle: #{@tie_bundle}") if $debug_mode_ct

    @arrange_types = skinning['arrange_types'] || {}
    echo("  @arrange_types: #{@arrange_types}") if $debug_mode_ct

    @lootables = settings.lootables
    echo("  @lootables: #{@lootables}") if $debug_mode_ct

    thanatology = settings.thanatology
    @ritual_type = thanatology['ritual_type'].downcase
    echo("  @ritual_type: #{@ritual_type}") if $debug_mode_ct

    @cycle_rituals = @ritual_type == 'cycle'
    echo("  @cycle_rituals: #{@cycle_rituals}") if $debug_mode_ct

    @dissect_and_butcher = settings.dissect_and_butcher
    echo("  @dissect_and_butcher: #{@dissect_and_butcher}") if $debug_mode_ct

    @rituals = get_data('spells').rituals
    echo("  @rituals: #{@rituals}") if $debug_mode_ct

    @redeemed = settings.necro_redeemed
    echo("  @redeemed: #{@redeemed}") if $debug_mode_ct

    @force_rituals = settings.necro_force_rituals
    echo("  @force_rituals: #{@force_rituals}") if $debug_mode_ct

    @last_ritual = nil
    echo("  @last_ritual: #{@last_ritual}") if $debug_mode_ct

    @necro_heal = thanatology['heal'] || false
    echo("  @necro_heal: #{@necro_heal}") if $debug_mode_ct

    @necro_store = thanatology['store'] || false
    echo("  @necro_store: #{@necro_store}") if $debug_mode_ct

    @necro_container = thanatology['harvest_container']
    echo("  @necro_container: #{@necro_container}") if $debug_mode_ct

    @current_harvest_count = DRC.rummage('C material', @necro_container).size if @necro_container
    echo("  @current_harvest_count: #{@current_harvest_count}") if $debug_mode_ct

    @necro_count = thanatology['harvest_count'] || 0
    echo("  @necro_count: #{@necro_count}") if $debug_mode_ct

    @make_zombie = settings.zombie['make']
    echo("  @make_zombie: #{@make_zombie}") if $debug_mode_ct

    @make_bonebug = settings.bonebug['make']
    echo("  @make_bonebug: #{@make_bonebug}") if $debug_mode_ct

    @necro_corpse_priority = settings.necro_corpse_priority
    echo("  @necro_corpse_priority: #{@necro_corpse_priority}") if $debug_mode_ct

    @wound_level_threshold = settings.necromancer_healing['wound_level_threshold'] || 1
    echo("  @wound_level_threshold: #{@wound_level_threshold}") if $debug_mode_ct

    @gem_nouns = get_data('items').gem_nouns
    echo("  @gem_nouns: #{@gem_nouns}") if $debug_mode_ct

    @tie_pouch = settings.tie_gem_pouches
    echo("  @tie_pouch: #{@tie_pouch}") if $debug_mode_ct

    @spare_gem_pouch_container = settings.spare_gem_pouch_container
    echo("  @spare_gem_pouch_container: #{@spare_gem_pouch_container}") if $debug_mode_ct

    @full_pouch_container = settings.full_pouch_container
    echo("  @full_pouch_container: #{@full_pouch_container}") if $debug_mode_ct

    @gem_pouch_adjective = settings.gem_pouch_adjective
    echo("  @gem_pouch_adjective: #{@gem_pouch_adjective}") if $debug_mode_ct

    @gem_pouch_noun = settings.gem_pouch_noun
    echo("  @gem_pouch_noun: #{@gem_pouch_noun}") if $debug_mode_ct

    @autoloot_container = settings.autoloot_container
    echo("  @autoloot_container: #{@autoloot_container}") if $debug_mode_ct

    @autoloot_gems = settings.autoloot_gems
    echo("  @autoloot_gems: #{@autoloot_gems}") if $debug_mode_ct

    @autoloot_fill_gem_pouch_delay = settings.autoloot_fill_gem_pouch_delay
    echo("  @autoloot_fill_gem_pouch_delay: #{@autoloot_fill_gem_pouch_delay}") if $debug_mode_ct

    @autoloot_fill_gem_pouch_timer = Time.now
    echo("  @autoloot_fill_gem_pouch_timer: #{@autoloot_fill_gem_pouch_timer}") if $debug_mode_ct

    @loot_delay = settings.loot_delay
    echo("  @loot_delay: #{@loot_delay}") if $debug_mode_ct

    @loot_timer = Time.now - @loot_delay
    echo("  @loot_timer: #{@loot_timer}") if $debug_mode_ct

    @loot_bodies = settings.loot_bodies
    echo("  @loot_bodies: #{@loot_bodies}") if $debug_mode_ct

    @loot_specials = settings.loot_specials
    echo("  @loot_specials: #{@loot_specials}") if $debug_mode_ct

    @custom_loot_type = settings.custom_loot_type
    echo("  @custom_loot_type: #{@custom_loot_type}") if $debug_mode_ct

    @dump_junk = settings.dump_junk
    echo("  @dump_junk: #{@dump_junk}") if $debug_mode_ct
    @dump_timer = Time.now - 300
    @dump_item_count = settings.dump_item_count

    @last_rites = settings.last_rites
    echo("  @last_rites: #{@last_rites}") if $debug_mode_ct
    @last_rites_timer = Time.now - 600

    if settings.box_loot_limit
      @box_nouns = get_data('items').box_nouns
      @box_loot_limit = settings.box_loot_limit
      @current_box_count = DRCI.count_all_boxes(settings)
      echo("  @current_box_count: #{@current_box_count}") if $debug_mode_ct
      echo("  @box_loot_limit: #{@box_loot_limit}") if $debug_mode_ct
    end

    Flags.add('using-corpse', 'begins arranging', 'completes arranging', 'kneels down briefly and draws a knife', 'cruelly into the body and carving out a chunk', 'makes additional cuts, purposeful but seemingly at random')
    Flags.add('pouch-full', 'You think the .* is too full to fit another gem into', /You'd better tie it up before putting/)
    Flags.add('container-full', 'There isn\'t any more room')
  end

  def execute(game_state)
    if DRRoom.room_objs.include?("junk")
      @dump_item_count -= 3
    end
    if (Time.now - @dump_timer > 300) && @dump_junk && DRRoom.room_objs.count >= @dump_item_count
      fput 'DUMP JUNK'
      @dump_timer = Time.now
    end

    fill_pouch_with_autolooter(game_state) if @autoloot_container && @autoloot_gems

    game_state.mob_died = false

    dispose_body(game_state)

    stow_lootables(game_state)

    if (game_state.mob_died || game_state.npcs.empty?) && game_state.finish_killing?
      15.times do
        break unless Flags['using-corpse']
        break if DRRoom.dead_npcs.empty?

        pause
      end
      stow_lootables(game_state)
      echo('LootProcess::clean_up') if $debug_mode_ct
      game_state.next_clean_up_step
    end

    return true if game_state.finish_spell_casting? || game_state.stowing?

    false
  end

  def fill_pouch_with_autolooter(game_state)
    return unless (Time.now - @autoloot_fill_gem_pouch_timer) > @autoloot_fill_gem_pouch_delay
    return unless (DRC.left_hand.nil? || game_state.currently_whirlwinding)

    game_state.sheath_whirlwind_offhand if game_state.currently_whirlwinding

    DRCI.fill_gem_pouch_with_container(
      @gem_pouch_adjective,
      @gem_pouch_noun,
      @autoloot_container,
      @full_pouch_container,
      @spare_gem_pouch_container,
      @tie_pouch
    )

    @autoloot_fill_gem_pouch_timer = Time.now

    game_state.wield_whirlwind_offhand if game_state.currently_whirlwinding
  end

  def stow_loot(item, game_state)
    Flags.reset('pouch-full')
    Flags.reset('container-full')

    special = @loot_specials.find { |x| x['name'] == item }
    if special && DRCI.get_item_unsafe(item)
      return if DRCI.put_away_item?(item, special['bag'])
    end

    case DRC.bput("stow #{item}", 'You pick up', 'You put', 'You get', 'You need a free hand', 'needs to be tended to be removed', 'There isn\'t any more room', 'You just can\'t', 'push you over the item limit', 'You stop as you realize the .* is not yours', 'Stow what', 'already in your inventory', 'The .* is not designed to carry anything', 'rapidly decays away', 'cracks and rots away', 'That can\'t be picked up')
    when 'already in your inventory'
      if @gem_nouns.include?(item)
        DRC.bput('stow gem', 'You pick up', 'You get', 'You need a free hand', 'You just can\'t', 'push you over the item limit', 'You stop as you realize the .* is not yours', 'Stow what', 'already in your inventory')
      elsif @box_nouns.include?(item)
        item_reg = item.split.join('.*')
        return stow_loot(DRRoom.room_objs.grep(/\b#{item_reg}$/).first.split.last(2).join(' '), game_state)
      else
        DRC.bput("stow other #{item}", 'You pick up', 'You put', 'You get', 'You need a free hand', 'needs to be tended to be removed', 'There isn\'t any more room', 'You just can\'t', 'push you over the item limit', 'You stop as you realize the .* is not yours', 'Stow what', 'already in your inventory', 'The .* is not designed to carry anything', 'rapidly decays away', 'cracks and rots away', 'That can\'t be picked up')
      end
    when 'You pick up', 'You get'
      @current_box_count += 1 if @box_loot_limit && @box_nouns.include?(item)
    end
    pause 0.25
    if Flags['container-full']
      DRC.bput("drop #{item}", 'You drop')
      game_state.unlootable(item)
    end

    return unless Flags['pouch-full']

    DRC.bput("drop my #{item}", 'You drop', 'What were')
    unless @spare_gem_pouch_container
      game_state.unlootable(item)
      return
    end
    DRC.bput("remove my #{@gem_pouch_adjective} #{@gem_pouch_noun}", 'You remove')
    if @full_pouch_container
      case DRC.bput("put my #{@gem_pouch_adjective} #{@gem_pouch_noun} in my #{@full_pouch_container}", 'You put', 'too heavy to go in there')
      when 'too heavy to go in there'
        DRC.bput("stow my #{@gem_pouch_adjective} #{@gem_pouch_noun}", 'You put')
      end
    else
      DRC.bput("stow my #{@gem_pouch_adjective} #{@gem_pouch_noun}", 'You put')
    end
    DRC.bput("get #{@gem_pouch_adjective} #{@gem_pouch_noun} from my #{@spare_gem_pouch_container}", 'You get a')
    DRC.bput("wear my #{@gem_pouch_adjective} #{@gem_pouch_noun}", 'You attach')
    DRC.bput('stow gem', 'You pick up', 'You get', 'You need a free hand', 'You just can\'t', 'push you over the item limit', 'You stop as you realize the .* is not yours', 'Stow what', 'already in your inventory')
    if @tie_pouch
      DRC.bput("tie my #{@gem_pouch_noun}", 'You tie')
    else
      DRC.bput("close my #{@gem_pouch_noun}", 'You close')
    end
  end

  def stow_lootables(game_state)
    return unless @loot_bodies

    pair = [DRC.left_hand, DRC.right_hand]
    tried_loot = false
    items_to_loot = []
    @lootables
      .select { |item| game_state.lootable?(item) }
      .reject { |item| @box_nouns.include?(item) && @box_loot_limit && at_box_limit? }
      .each do |item|
        item_reg = item.split.join('.*')
        matches = DRRoom.room_objs.grep(/\b#{item_reg}$/)
        tried_loot ||= !matches.empty?
        matches.each { |_| items_to_loot.push(item); }
      end
    if items_to_loot.any?
      game_state.sheath_whirlwind_offhand
      items_to_loot.each { |item| stow_loot(item, game_state) }
      game_state.wield_whirlwind_offhand
    end
    return unless tried_loot

    pause 1
    if DRC.left_hand != pair.first || DRC.right_hand != pair.last
      # Mitigating a race condition when wand-watcher or another script pauses
      # combat-trainer while it's looting, then resumes in the middle of this function.
      # Occassionally, the thread hasn't updated the left_hand/right_hand variables
      # to know what's currently in your hand and will trash what's in your hand!
      # Do a glance to force the variables to be refreshed before we take action.
      DRC.bput('glance', 'You glance .*')
    end
    if DRC.left_hand != pair.first && !@equipment_manager.is_listed_item?(DRC.left_hand)
      DRC.message("Out of room, failed to store: #{DRC.left_hand}")
      game_state.unlootable(DRC.left_hand_noun.downcase)
      DRCI.dispose_trash(DRC.left_hand)
    end
    if DRC.right_hand != pair.last && !@equipment_manager.is_listed_item?(DRC.right_hand)
      DRC.message("Out of room, failed to store: #{DRC.right_hand}")
      game_state.unlootable(DRC.right_hand_noun.downcase)
      DRCI.dispose_trash(DRC.right_hand)
    end
  end

  def at_box_limit?
    return false unless @box_loot_limit

    @current_box_count >= @box_loot_limit
  end

  def should_perform_ritual?(game_state)
    return false unless DRStats.necromancer?
    return false unless @ritual_type
    return false if game_state.necro_casting?
    return true if @force_rituals
    return true if @ritual_type == 'cycle'
    return true if @ritual_type == 'butcher' && DRSkill.getxp('Thanatology') < 32
    return true if @ritual_type == 'dissect' && DRSkill.getxp('First Aid') < 32
    return true if @ritual_type == 'harvest' && DRSkill.getxp('Skinning') < 32
    return true if DRSkill.getxp('Thanatology') < 32

    false
  end

  def determine_next_ritual
    return unless @cycle_rituals

    next_ritual = if DRSkill.getxp('Skinning') > 31 && DRSkill.getxp('First Aid') > 31 && DRSkill.getxp('Thanatology') > 31
                    if @dissect_and_butcher
                      'butcher'
                    else
                      'dissect'
                    end
                  elsif DRSkill.getxp('Skinning') < DRSkill.getxp('First Aid')
                    'harvest'
                  elsif @dissect_and_butcher
                    'butcher'
                  else
                    'dissect'
                  end
    next_ritual
  end

  def check_rituals?(game_state)
    return true unless DRStats.necromancer?

    mob_noun = DRRoom.dead_npcs.first
    return true if game_state.construct?(mob_noun)

    echo "  should_perform_ritual? #{should_perform_ritual?(game_state)}" if $debug_mode_ct
    if @last_ritual.nil?
      if @necro_corpse_priority == 'pet'
        echo "Prioritizing pet creation over healing" if $debug_mode_ct
        check_necro_pet(mob_noun, game_state)
        check_necro_heal(mob_noun, game_state)
      elsif @necro_corpse_priority == 'heal' || !@necro_corpse_priority
        echo "Prioritizing healing over pet creation" if $debug_mode_ct
        check_necro_heal(mob_noun, game_state)
        check_necro_pet(mob_noun, game_state)
      end
      ritual = if @redeemed
                 'dissect'
               elsif @current_harvest_count < @necro_count
                 'harvest'
               elsif @cycle_rituals
                 determine_next_ritual
               elsif @ritual_type.eql?('dissect') && @dissect_and_butcher
                 'butcher'
               else
                 @ritual_type
               end
      do_necro_ritual(mob_noun, ritual, game_state) if should_perform_ritual?(game_state)
    end
    return false if %w[consume harvest dissect].include?(@last_ritual)

    true
  end

  def check_necro_heal(mob_noun, game_state)
    if @necro_heal && !game_state.necro_casting?
      game_state.wounds = DRCH.check_health['wounds']
      echo "Severity to Wounds: #{game_state.wounds}" if $debug_mode_ct
      echo "wound_level_threshold: #{@wound_level_threshold}" if $debug_mode_ct
      unless game_state.wounds.empty?
        if @wound_level_threshold <= game_state.wounds.keys.max
          do_necro_ritual(mob_noun, 'consume', game_state)
          return false
        end
      end
    end
  end

  def check_necro_pet(mob_noun, game_state)
    if @make_zombie && !game_state.necro_casting? && !game_state.cfb_active?
      echo 'Making zombie' if $debug_mode_ct
      do_necro_ritual(mob_noun, 'arise', game_state)
      return false
    end
    if @make_bonebug && !game_state.necro_casting? && !game_state.cfw_active?
      echo 'Making bone bug' if $debug_mode_ct
      do_necro_ritual(mob_noun, 'arise', game_state)
      return false
    end
  end

  def do_necro_ritual(mob_noun, ritual, game_state)
    return unless DRStats.necromancer?
    return unless ritual
    return if game_state.construct?(mob_noun)

    echo "Attempting necromancer ritual #{ritual} on #{mob_noun}" if $debug_mode_ct

    if ritual.eql?('butcher')
      butcher_corpse(mob_noun, ritual, game_state)

      @last_ritual = ritual
      echo "Last ritual performed: #{@last_ritual}" if $debug_mode_ct
      return
    end

    do_necro_ritual(mob_noun, 'preserve', game_state) if %w[consume harvest arise].include?(ritual)
    perform_message = "perform #{ritual} on #{mob_noun}"
    result = DRC.bput(perform_message, @rituals['arise'], @rituals['preserve'], @rituals['dissect'], @rituals['harvest'], @rituals['consume'], @rituals['construct'], @rituals['failures'])
    echo result if $debug_mode_ct
    case result
    when @rituals['arise']
      echo 'Detected arise messaging' if $debug_mode_ct
      game_state.prepare_nr = true if @make_zombie && !game_state.cfb_active?
      game_state.prepare_cfb = true if @make_zombie && !game_state.cfb_active?
      game_state.prepare_cfw = true if @make_bonebug && !game_state.cfw_active?
      @last_ritual = ritual
    when @rituals['preserve'], @rituals['dissect']
      echo 'Detected preserve or dissect messaging' if $debug_mode_ct
      @last_ritual = ritual
    when @rituals['consume']
      echo 'Detected consume messaging' if $debug_mode_ct
      @last_ritual = ritual
      game_state.prepare_consume = true if @necro_heal
    when @rituals['harvest']
      echo 'Detected harvest messaging' if $debug_mode_ct
      @last_ritual = ritual
      waitrt?
      necro_harvest_check
    when @rituals['construct']
      echo 'Detected an attempt to do ritual on a construct' if $debug_mode_ct
      game_state.construct(mob_noun)
    when *@rituals['failures']
      echo 'Failure detected' if $debug_mode_ct
    end
    echo "Last ritual performed: #{@last_ritual}" if $debug_mode_ct
  end

  def butcher_corpse(mob_noun, ritual, game_state)
    return unless ritual.eql?('butcher')

    echo "Butchering the #{mob_noun}'s corpse!" if $debug_mode_ct
    echo ' Only butchering it once!' if $debug_mode_ct && @dissect_and_butcher && !@ritual_type.eql?('butcher')

    @equipment_manager.stow_weapon(game_state.weapon_name)

    loop do
      result = DRC.bput("perform #{ritual} on #{mob_noun}", @rituals['butcher'], @rituals['failures'])
      break if result.empty? || @rituals['failures'].any? { |msg| result.include?(msg) }

      DRC.bput("drop my #{DRC.right_hand}", 'You drop', 'You discard', 'Please rephrase')
      break if @dissect_and_butcher && !@ritual_type.eql?('butcher')
    end

    do_necro_ritual(mob_noun, 'dissect', game_state) if @dissect_and_butcher && !@ritual_type.eql?('butcher')
    @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill)
  end

  def necro_harvest_check
    unless @necro_store
      echo 'Store material: false, dropping harvested material' if $debug_mode_ct
      DRC.bput('drop material', 'you discard it')
      return
    end

    quality = DRC.bput('glance', 'You glance down.*')
    if quality['great'] || quality['excellent'] || quality['perfect'] || quality['flawless']
      echo 'Harvested high quality material.' if $debug_mode_ct
    else
      DRC.bput('drop material', 'you discard it')
      echo 'Dropped low quality material.' if $debug_mode_ct
      return
    end

    echo 'Store material: true, checking count of stored material' if $debug_mode_ct
    if @current_harvest_count >= @necro_count
      DRC.bput('drop material', 'you discard it')
      echo 'Already full on stored material, dropping harvested material.' if $debug_mode_ct
      return
    end

    result = DRC.bput("put material in my #{@necro_container}", 'You put', 'material doesn\'t seem to fit')
    @current_harvest_count += 1 if result =~ /^You put/
    DRC.bput('drop material', 'you discard it') if result =~ /^material doesn't seem to fit/
  end

  def dispose_body(game_state)
    return unless @loot_bodies

    if DRRoom.dead_npcs.empty?
      Flags.reset('using-corpse')
      @last_ritual = nil
      return
    end
    return if Time.now - @loot_timer < @loot_delay

    game_state.mob_died = true
    waitrt?
    return if Flags['using-corpse']

    if (Time.now - @last_rites_timer > 600) && @last_rites && game_state.blessed_room
      DRC.bput("pray #{DRRoom.dead_npcs.first}", 'You beseech your god for mercy', 'You pray fervently', 'You continue praying for guidance', 'Quietly touching your lips with the tips of your fingers', 'murmur a brief prayer for')
      waitrt?
      fput "recite Meraud, power the holy fires that unleash my righteous vengeance;Chadatru, guide my sword to swing in justice;Everild, give me the power to conquer my enemies;Truffenyi, let me not lose sight of compassion and mercy;Else, I will become like those I despise;Urrem'tier, receive into your fetid grasp these wicked souls;May the Tamsine's realms never know their evil ways again;May all the Immortals guide your faithful soldier #{checkname}."
      waitrt?
      @last_rites_timer = Time.now
      return
    end

    game_state.sheath_whirlwind_offhand

    echo("DRRoom.dead_npcs.first is: #{DRRoom.dead_npcs.first}") if $debug_mode_ct
    skin_or_dissect(DRRoom.dead_npcs.first, game_state) if check_rituals?(game_state)

    game_state.wield_whirlwind_offhand

    unless game_state.necro_casting?
      while DRC.bput("loot #{@custom_loot_type}".strip, 'You search', 'I could not find what you were referring to', 'and get ready to search it') == 'and get ready to search it'
        pause
        waitrt?
      end
      @last_ritual = nil
    end
    @loot_timer = Time.now
  end

  def arrange_mob(mob_noun, game_state)
    return unless @skin
    return unless @arrange_count > 0
    return unless game_state.skinnable?(mob_noun)
    return if game_state.necro_casting?

    arranges = 0
    type = @arrange_types[mob_noun] || 'skin'
    arrange_message = @arrange_all ? "arrange all for #{type}" : "arrange for #{type}"
    while arranges < @arrange_count
      arranges += 1
      case DRC.bput(arrange_message, 'You begin to arrange', 'You continue arranging', 'You make a mistake', 'You complete arranging', 'That creature cannot', 'That has already been arranged', 'Arrange what', 'cannot be skinned', 'You make a serious mistake in the arranging process', 'The .* is currently being arranged to produce')
      when 'You complete arranging', 'That has already been arranged', 'You make a serious mistake in the arranging process', 'Arrange what'
        break
      when 'cannot be skinned'
        game_state.unskinnable(mob_noun)
        @dissect_cycle_skills.delete("Skinning")
        @skin = false
        break
      when 'That creature cannot'
        arranges = 0
        arrange_message = @arrange_all ? 'arrange all' : 'arrange'
      end
    end
  end

  def skin_or_dissect(mob_noun, game_state)
    return unless (game_state.dissectable?(mob_noun) || game_state.skinnable?(mob_noun))
    return unless (@dissect || @skin)

    already_arranged = false

    if @dissect && game_state.dissectable?(mob_noun)
      if @arrange_for_dissect
        arrange_mob(mob_noun, game_state)
        already_arranged = true
      end

      if game_state.skinnable?(mob_noun)
        skill_to_train = game_state.sort_by_rate_then_rank(@dissect_cycle_skills, @dissect_priority).first
      else
        skill_to_train = 'First Aid'
      end

      if skill_to_train == 'First Aid' || skill_to_train == 'Thanatology'
        unless dissected?(mob_noun, game_state)
          arrange_mob(mob_noun, game_state) unless already_arranged
          check_skinning(mob_noun, game_state) if @skin
        end
      elsif skill_to_train == 'Skinning'
        arrange_mob(mob_noun, game_state) unless already_arranged
        check_skinning(mob_noun, game_state) if @skin
      end
    elsif @skin && game_state.skinnable?(mob_noun)
      arrange_mob(mob_noun, game_state) unless already_arranged
      check_skinning(mob_noun, game_state)
    else
      return
    end
  end

  def dissected?(mob_noun, game_state)
    return unless game_state.dissectable?(mob_noun)

    if @dissect_for_thanatology
      return false if (DRSkill.getxp('Thanatology') == 34 && DRSkill.getxp('First Aid') == 34)
    else
      return false if DRSkill.getxp('First Aid') == 34
    end

    case DRC.bput("dissect #{mob_noun}",
                  /You'll gain no insights from this attempt/,
                  /You succeed in dissecting the corpse/,
                  'What exactly are you trying to dissect',
                  "You'll learn nothing",
                  'While likely a fascinating study',
                  'You cannot dissect',
                  'would probably object',
                  "should be left alone.",
                  "That'd be a waste of time.",
                  'A skinned creature is worthless',
                  'You do not yet possess the knowledge',
                  'This ritual may only be performed on a corpse',
                  /You learn something/i,
                  'A failed or completed ritual has rendered',
                  'You realize after a few seconds',
                  'prevents a meaningful dissection',
                  "With less concern than you'd give a fresh corpse")
    when /You succeed in dissecting the corpse/, /You learn something/i, "With less concern than you'd give a fresh corpse"
      return true
    when /You'll gain no insights from this attempt/
      waitrt?
      fput("dissect")
      return false
    when 'This ritual may only be performed on a corpse', 'A failed or completed ritual has rendered', 'You realize after a few seconds', 'prevents a meaningful dissection'
      return false
    when 'While likely a fascinating study', "That'd be a waste of time.", 'You do not yet possess the knowledge'
      game_state.undissectable(mob_noun)
      @dissect_cycle_skills.delete("First Aid")
      @dissect_cycle_skills.delete("Thanatology") if @dissect_for_thanatology
      @dissect = false
      return false
    when 'would probably object', "should be left alone."
      dissected?('', game_state)
    end
    return false
  end

  def check_skinning(mob_noun, game_state)
    return unless game_state.skinnable?(mob_noun)

    if game_state.need_bundle
      case DRC.bput('tap my bundle', 'You tap a \w+ bundle that you are wearing', 'I could not find what you were referring to', 'You tap a tight bundle inside')
      when /lumpy/
        if @tie_bundle
          DRC.bput('tie my bundle', 'TIE the bundle again')
          DRC.bput('tie my bundle', 'you tie the bundle')
          DRC.bput('adjust my bundle', 'You adjust')
        end
        game_state.need_bundle = false
      when /tight/
        game_state.need_bundle = false
      end
    end

    snap = [DRC.left_hand, DRC.right_hand]
    case DRC.bput('skin', 'roundtime', 'skin what', 'cannot be skinned', 'carrying far too many items', 'need a more appropriate weapon', 'need to have a bladed instrument to skin', 'You must have one hand free to skin')
    when 'You must have one hand free to skin'
      temp_item = DRC.left_hand
      if DRCI.lower_item?(temp_item)
        check_skinning(mob_noun, game_state)
        DRCI.get_item?(temp_item)
      end
    when 'need a more appropriate weapon', 'need to have a bladed instrument to skin'
      DRC.message('BUY A SKINNING KNIFE')
      @skin = false
      return
    when 'cannot be skinned', 'carrying far too many items'
      game_state.unskinnable(mob_noun)
      return
    end
    pause 1
    waitrt?
    if game_state.need_bundle && snap != [DRC.left_hand, DRC.right_hand]
      stored_moon = false
      if DRStats.moon_mage? && DRCMM.wear_moon_weapon?
        stored_moon = true
      elsif (summoned = game_state.summoned_info(game_state.weapon_skill))
        DRCS.break_summoned_weapon(game_state.weapon_name)
      else
        @equipment_manager.stow_weapon(game_state.weapon_name)
      end

      if DRCI.get_item_if_not_held?('bundling rope')
        DRC.bput('bundle', 'You bundle')
        DRCI.wear_item?('bundle')
        if @tie_bundle
          DRC.bput('tie my bundle', 'TIE the bundle again')
          DRC.bput('tie my bundle', 'you tie the bundle')
          DRC.bput('adjust my bundle', 'You adjust')
        end
      else
        DRCI.dispose_trash(DRC.left_hand) if snap.first != DRC.left_hand && !@equipment_manager.is_listed_item?(DRC.left_hand)
        DRCI.dispose_trash(DRC.right_hand) if snap.last != DRC.right_hand && !@equipment_manager.is_listed_item?(DRC.right_hand)
      end
      game_state.need_bundle = false
      unless stored_moon && DRCMM.hold_moon_weapon?
        if summoned
          game_state.prepare_summoned_weapon(false)
        else
          @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill)
        end
      end
    end
    DRCI.dispose_trash(DRC.left_hand) if snap.first != DRC.left_hand && !@equipment_manager.is_listed_item?(DRC.left_hand)
    DRCI.dispose_trash(DRC.right_hand) if snap.last != DRC.right_hand && !@equipment_manager.is_listed_item?(DRC.right_hand)
  end
end

class SafetyProcess
  def initialize(settings, equipment_manager)
    echo('New SafetyProcess') if $debug_mode_ct
    Flags.add('ct-engaged', 'closes to pole weapon range on you', 'closes to melee range on you')
    Flags.add('ct-lodged', 'from the .* lodged in your (?<body_part>.*)\.')
    # When you drop an item due to loss of hand, the phrase is "Your <item> falls to your feet." (do recovery logic)
    # When you shoot or throw something, the phrase is "The <item> falls to your feet!" (normal mechanics)
    Flags.add('ct-itemdropped', '^Your (?<item>.*) falls to your feet\.', '^You cannot maintain your grip on the (?<item>.*), and it falls to the ground!')
    Flags.add('ct-germshieldlost', 'It jerks the.* (?<shield>\w+) out of your hands')
    Flags.add('active-mitigation', 'You believe you could \b(?<action>\w+) out of the way of the \b(?<obstacle>\w+)')
    Flags.add('ct-parasite', 'blood mite on your (?<body_part>.*)\.')
    @equipment_manager = equipment_manager
    @health_threshold = settings.health_threshold
    @stop_on_bleeding = settings.stop_hunting_if_bleeding
    echo("  @health_threshold: #{@health_threshold}") if $debug_mode_ct
    @untendable_counter = 0
  end

  def execute(game_state)
    if @untendable_counter >= 3 && @stop_on_bleeding
      echo('Skipping tendme check due to untendable backoff') if $debug_mode_ct
      echo("Couldn't tend bleeders after trying three times. Stopping hunt to heal.")
      $HUNTING_BUDDY.stop_hunting
      $COMBAT_TRAINER.stop
    elsif bleeding? && !Script.running?('tendme')
      echo('Checking for tendable bleeders...') if $debug_mode_ct
      if DRCH.has_tendable_bleeders?
        DRC.wait_for_script_to_complete('tendme')
      end
      @untendable_counter += 1
    end

    fput 'exit' if DRStats.health < @health_threshold
    DRC.fix_standing
    check_item_recovery(game_state)
    tend_lodged
    tend_parasite
    active_mitigation
    game_state.danger = in_danger?(game_state.danger)
    keep_away if !game_state.danger && game_state.retreating?
  end

  private

  def check_item_recovery(game_state)
    if Flags['ct-germshieldlost']
      recover_item(game_state, Flags['ct-germshieldlost'][:shield], 'wear')
      Flags.reset('ct-germshieldlost')
    end
    if Flags['ct-itemdropped']
      # You dropped an item because either your hand is too injured to hold it or stolen or *tingle*.
      # Since one hand might be useless, free up the other hand so you can pick something up with it.
      temp_left_item = DRC.left_hand
      temp_right_item = DRC.right_hand
      temp_item = [temp_left_item, temp_right_item].compact.first
      if temp_item
        # Put item away per gear config, but if not in your config then just put it away.
        @equipment_manager.stow_weapon(temp_item) || DRCI.put_away_item?(temp_item)
      end
      # Try to recover the item you lost.
      recover_item(game_state, Flags['ct-itemdropped'][:item], 'pickup')
      Flags.reset('ct-itemdropped')
      # If put an item away then get it back out.
      if temp_item
        @equipment_manager.wield_weapon?(temp_item) || DRCI.get_item?(temp_item)
        # In case the items end up in opposite hands, swap.
        # This may do nothing if you have only one usable hand.
        fput('swap') if (DRC.left_hand != temp_left_item && DRC.right_hand != temp_right_item)
      end
    end
  end

  def recover_item(game_state, item, action = 'pickup')
    return unless item

    echo "*** Recovering #{item}"
    recovered = false
    game_state.sheath_whirlwind_offhand
    if DRCI.get_item_unsafe(item)
      case action
      when 'pickup'
        recovered = true
      when 'wear'
        recovered = DRCI.wear_item?(item)
      when 'stow'
        recovered = @equipment_manager.stow_weapon(item) || DRCI.put_away_item?(item)
      end
    end
    warn_failed_item_recovery(item) unless recovered
    waitrt?
    game_state.wield_whirlwind_offhand
  end

  def warn_failed_item_recovery(item)
    5.times { DRC.message "UNABLE TO RECOVER FROM #{item} LOSS!"; DRC.beep }
  end

  def tend_lodged
    return unless Flags['ct-lodged']

    DRCH.bind_wound(Flags['ct-lodged'][:body_part])
    Flags.reset('ct-lodged')
  end

  def tend_parasite
    return unless Flags['ct-parasite']

    DRC.wait_for_script_to_complete('tendme')
    Flags.reset('ct-parasite')
  end

  def keep_away
    return unless Flags['ct-engaged']

    Flags.reset('ct-engaged')
    DRC.retreat
  end

  def active_mitigation
    return unless Flags['active-mitigation']

    DRC.bput("#{Flags['active-mitigation'][:action]} #{Flags['active-mitigation'][:obstacle]}", 'You manage to', "You've got to", 'Please rephrase', 'You jump back', "You can't do")
    Flags.reset('active-mitigation')
  end

  def in_danger?(danger)
    return false if DRStats.health >= 75

    unless danger
      Flags.reset('ct-engaged')
      DRC.retreat
    end

    keep_away
    true
  end
end

class SpellProcess
  $weapon_buffs = ['Ignite', 'Rutilor\'s Edge', 'Resonance']

  def initialize(settings, equipment_manager)
    @equipment_manager = equipment_manager
    echo('New SpellProcess') if $debug_mode_ct

    @settings = settings

    if settings.combat_buff_waggle && settings.waggle_sets[settings.combat_buff_waggle]
      @buff_spells = settings.waggle_sets[settings.combat_buff_waggle]
    else
      @buff_spells = settings.buff_spells
    end
    echo("  @buff_spells: #{@buff_spells}") if $debug_mode_ct

    @offensive_spells = settings.offensive_spells
    echo("  @offensive_spells: #{@offensive_spells}") if $debug_mode_ct

    @training_spells = settings.combat_spell_training
    echo("  @training_spells: #{@training_spells}") if $debug_mode_ct

    @training_spells_max_threshold = settings.combat_spell_training_max_threshold
    echo("  @training_spells_max_threshold: #{@training_spells_max_threshold}") if $debug_mode_ct

    @training_spells_wait = settings.combat_spell_timer
    echo("  @training_spells_wait: #{@training_spells_wait}") if $debug_mode_ct

    @magic_exp_training_max_threshold = settings.magic_exp_training_max_threshold
    echo("  @magic_exp_training_max_threshold: #{@magic_exp_training_max_threshold}") if $debug_mode_ct

    @offensive_spell_cycle = settings.offensive_spell_cycle
    echo("  @offensive_spell_cycle: #{@offensive_spell_cycle}") if $debug_mode_ct

    @necromancer_healing = settings.necromancer_healing
    echo("  @necromancer_healing: #{@necromancer_healing}") if $debug_mode_ct

    @corpse_healing = settings.waggle_sets['corpse_healing']
    echo("  @corpse_healing: #{@corpse_healing}") if $debug_mode_ct

    @necromancer_zombie = settings.waggle_sets['zombie']
    echo("  @necromancer_zombie: #{@necromancer_zombie}") if $debug_mode_ct

    @necromancer_bonebug = settings.waggle_sets['bonebug']
    echo("  @necromancer_bonebug: #{@necromancer_bonebug}") if $debug_mode_ct

    @empath_spells = settings.empath_healing
    echo("  @empath_spells: #{@empath_spells}") if $debug_mode_ct

    @empath_vitality_threshold = settings.empath_vitality_threshold
    echo("  @empath_vitality_threshold: #{@empath_vitality_threshold}") if $debug_mode_ct

    @osrel_timer = Time.now - 1000
    echo("  @osrel_timer: #{@osrel_timer}") if $debug_mode_ct

    @osrel_amount = settings.osrel_amount
    echo("  @osrel_amount: #{@osrel_amount}") if $debug_mode_ct

    @osrel_no_harness = settings.osrel_no_harness
    echo("  @osrel_no_harness: #{@osrel_no_harness}") if $debug_mode_ct

    @osrel_mana_threshold = settings.osrel_mana_threshold
    echo("  @osrel_mana_threshold: #{@osrel_mana_threshold}") if $debug_mode_ct

    @osrel_need_mana = false
    echo("  @osrel_need_mana: #{@osrel_need_mana}") if $debug_mode_ct

    @cast_only_to_train = settings.cast_only_to_train
    echo("  @cast_only_to_train: #{@cast_only_to_train}") if $debug_mode_ct

    @offensive_spell_mana_threshold = settings.offensive_spell_mana_threshold
    echo("  @offensive_spell_mana_threshold: #{@offensive_spell_mana_threshold}") if $debug_mode_ct

    @training_spell_mana_threshold = settings.training_spell_mana_threshold
    echo("  @training_spell_mana_threshold: #{@training_spell_mana_threshold}") if $debug_mode_ct

    @training_spells_combat_sorcery = settings.training_spells_combat_sorcery
    echo("  @training_spells_combat_sorcery: #{@training_spells_combat_sorcery}") if $debug_mode_ct

    @release_cyclic_on_low_mana = settings.release_cyclic_on_low_mana
    echo("  @release_cyclic_on_low_mana: #{@release_cyclic_on_low_mana}") if $debug_mode_ct

    @release_cyclic_threshold = settings.release_cyclic_threshold
    echo("  @release_cyclic_threshold: #{@release_cyclic_threshold}") if $debug_mode_ct

    @buff_spell_mana_threshold = settings.buff_spell_mana_threshold
    echo("  @buff_spell_mana_threshold: #{@buff_spell_mana_threshold}") if $debug_mode_ct

    @cambrinth = settings.cambrinth
    echo("  @cambrinth: #{@cambrinth}") if $debug_mode_ct

    @cambrinth_cap = settings.cambrinth_cap
    echo("  @cambrinth_cap: #{@cambrinth_cap}") if $debug_mode_ct

    @dedicated_camb_use = settings.dedicated_camb_use
    echo(" @dedicated_camb_use: #{@dedicated_camb_use}") if $debug_mode_ct

    @stored_cambrinth = settings.stored_cambrinth
    echo(" @stored_cambrinth: #{@stored_cambrinth}") if $debug_mode_ct

    @cambrinth_invoke_exact_amount = settings.cambrinth_invoke_exact_amount
    echo("  @cambrinth_invoke_exact_amount: #{@cambrinth_invoke_exact_amount}") if $debug_mode_ct

    @harness_for_attunement = settings.use_harness_when_arcana_locked
    echo(" @harness_for_attunement: #{@harness_for_attunement}") if $debug_mode_ct

    @siphon_vit_threshold = settings.necro_siphon_vit_threshold
    echo(" @siphon_vit_threshold: #{@siphon_vit_threshold}") if $debug_mode_ct

    @ignored_npcs = settings.ignored_npcs
    echo(" @ignored_npcs: #{@ignored_npcs}") if $debug_mode_ct

    @hide_type = settings.hide_type
    echo("  @hide_type: #{@hide_type}") if $debug_mode_ct

    @buff_force_cambrinth = settings.combat_trainer_buffs_force_cambrinth
    echo("  @buff_force_cambrinth: #{@buff_force_cambrinth}") if $debug_mode_ct

    @regalia_array = settings.cycle_armors_regalia
    echo("  @regalia_array: #{@regalia_array}") if $debug_mode_ct

    @regalia_spell = settings.waggle_sets['regalia']['Regalia']
    echo("  @regalia_spell: #{@regalia_spell}") if $debug_mode_ct

    @aura_frequency = settings.aura_frequency
    echo("  @aura_frequency: #{@aura_frequency}") if $debug_mode_ct

    @barb_healing = settings.barb_famine_healing
    echo("  @barb_healing: #{@barb_healing}") if $debug_mode_ct

    @runestone_storage = settings.runestone_storage
    echo("  @runestone_storage: #{@runestone_storage}") if $debug_mode_ct

    @perc_health_timer = Time.now
    @aura_timer = 0
    @avtalia_timer = Time.now - 290

    @symbiosis_learning_threshold = settings.symbiosis_learning_threshold
    echo(" @symbiosis_learning_threshold: #{@symbiosis_learning_threshold}") if $debug_mode_ct

    Flags.add('ct-spelllost', 'Your pattern dissipates with the loss of your target', 'Your secondary spell pattern dissipates because your target is dead, but the main spell remains intact', 'Your concentration lapses and you lose your targeting pattern')
    Flags.add('ct-need-bless', ' passes through the .* with no effect')
    Flags.add('ct-starlight-depleted', 'enough starlight') if DRStats.trader?
    Flags.add('ct-regalia-expired', 'Your .* glimmers? weakly') if DRStats.trader?
    Flags.add('ct-regalia-succeeded', 'You cup your palms skyward to bask in') if DRStats.trader?
    Flags.add('ct-shock-warning', 'You are distinctly aware that completion of this spell pattern may bring you shock')

    @offensive_spells
      .select { |spell| spell['expire'] }
      .each { |spell| add_spell_flag(spell['abbrev'], spell['expire']) }
    @buff_spells
      .values
      .select { |data| data['expire'] }
      .each { |data| add_spell_flag(data['abbrev'], data['expire']) }

    @training_cast_timer = Time.now + 45
    @training_cyclic_timer = Time.now + 45

    @spell_timers = {}
    @wounds = {}

    @tk_ammo = settings.tk_ammo
    @tk_spell = @offensive_spells.find { |spell| spell['abbrev'] =~ /tkt|tks/i }
    drop_tkt_ammo
    Flags.add('need-tkt-ammo', 'There is nothing here that can be thrown')

    return unless DRStats.trader? && @regalia_array

    @regalia_spell = get_data('spells').spell_data['Regalia'] if @regalia_array && @regalia_spell.nil? # get data from the regalia waggle or base-spells
    DRC.bput('release spell', 'You let your concentration lapse', "You aren't preparing a spell") unless checkprep == 'None' # prepare to check for bespoke regalia
    @know_bespoke = DRC.bput('pre bspk', 'Bespoke Regalia', 'You have no idea', 'fully prepared', 'already preparing') == 'Bespoke Regalia' # check for bespoke regalia
  end

  def drop_tkt_ammo
    return unless @tk_ammo

    fput("get my #{@tk_ammo}")
    fput("drop #{@tk_ammo}")
  end

  def add_spell_flag(name, expire)
    Flags.add("ct-#{name}", expire)
    Flags["ct-#{name}"] = true
  end

  def execute(game_state)
    return true if game_state.stowing?
    return false if game_state.dismiss_pet?

    check_timer(game_state)

    if game_state.finish_spell_casting?
      echo('SpellProcess::clean_up') if $debug_mode_ct
      game_state.next_clean_up_step
      if DRStats.guild == "Bard" && @settings.segue_spell_on_stop
        DRCA.segue?(@settings.segue_spell_on_stop, @settings.segue_prep_on_stop)
      end
      DRCA.release_cyclics(@settings.cyclic_no_release)
      if checkprep != 'None'
        DRC.bput('release spell', 'You let your concentration lapse', "You aren't preparing a spell")
        DRC.bput('release mana', 'You release all', "You aren't harnessing any mana")
      end
      if @tk_ammo
        waitrt?
        pause
        fput("stow #{@tk_ammo}")
      end
      DRCA.shatter_regalia? if @regalia_array
      return true
    end

    if Flags['ct-spelllost']
      game_state.casting = false
      Flags.reset('ct-spelllost')
    end

    check_osrel(game_state)
    DRC.message("Skipping other spell processes until @osrel_need_mana is false") if @osrel_need_mana
    return false if @osrel_need_mana

    if game_state.mob_died
      @offensive_spells
        .select { |spell| spell['expire'] }
        .reject { |spell| spell['cyclic'] }
        .reject { |spell| spell['heavy'] }
        .each { |spell| Flags["ct-#{spell['abbrev']}"] = true }
    end
    if Flags['need-tkt-ammo']
      Flags.reset('need-tkt-ammo')
      drop_tkt_ammo
    end
    check_slivers(game_state)
    check_regalia(game_state)
    check_consume(game_state)
    check_cfw(game_state)
    heal_corpse(game_state)
    check_cfb(game_state)
    check_bless(game_state)
    check_ignite(game_state)
    check_rutilors_edge(game_state)
    check_health(game_state)
    check_starlight(game_state)
    check_avtalia(game_state)
    check_buffs(game_state)
    check_training(game_state)
    check_offensive(game_state)
    check_current(game_state)

    false
  end

  private

  def check_slivers(game_state)
    return unless DRSpells.known_spells.include?('Moonblade')
    return unless DRStats.moon_mage?
    return unless @tk_spell
    return if game_state.casting
    return if DRSpells.slivers

    unless UserVars.moons['visible'].any?
      DRC.message "There are NO moons available and you have NO TK_AMMO set! You need to fix this!" if !@tk_ammo && $debug_mode_ct
      return
    end

    # With low skill you may fail to create the slivers
    # when breaking your moonblade. If so, keep retrying.
    retry_count = 0
    max_retries = 3
    created_slivers = false
    # We don't need to cast the spell a fancy way
    # so rather than asking users to define a new waggle
    # then simply cast the spell at minimum prep.
    moonblade_spell = get_data('spells').spell_data['Moonblade'].dup
    # Minimally prepare the spell so we can cast it quickly.
    moonblade_spell['mana'] = 1
    # Try, try, try to break moonblade into slivers.
    # For novices, this may fail a couple times.
    while !created_slivers && retry_count < max_retries
      # For skilled mages, try to snap cast
      # unless we failed the first time.
      if retry_count == 0
        case DRSkill.getrank('Lunar Magic')
        when 200..299
          moonblade_spell['prep_time'] = 3
        when 300..399
          moonblade_spell['prep_time'] = 2
        when 400..Float::INFINITY
          moonblade_spell['prep_time'] = 1
        end
      end
      DRCA.cast_spell(moonblade_spell, @settings)
      created_slivers = DRC.bput("break moonblade", "The slivers drift about", "dissipate without any benefit", "Break what?") == "The slivers drift about"
      retry_count = retry_count + 1
    end
    DRC.message("Failed to create slivers for telekinetic ammo after #{retry_count} attempts") unless created_slivers
  end

  def check_osrel(game_state)
    return if game_state.casting
    return unless @osrel_amount && DRSpells.active_spells['Osrel Meraud']
    return unless Time.now - @osrel_timer > 300
    return unless DRSpells.active_spells['Osrel Meraud'] && DRSpells.active_spells['Osrel Meraud'] < 90

    if DRStats.mana <= @osrel_mana_threshold
      DRC.message("Setting @osrel_need_mana to true until mana over #{@osrel_mana_threshold}. Current mana: #{DRStats.mana}")
      @osrel_need_mana = true
      return
    end

    @osrel_timer = Time.now
    DRCA.infuse_om(!@osrel_no_harness, @osrel_amount)
    DRC.message("Setting @osrel_need_mana to false") if @osrel_need_mana
    @osrel_need_mana = false
  end

  def check_timer(game_state)
    return if game_state.cast_timer.nil? || (Time.now - game_state.cast_timer) <= 70

    game_state.cast_timer = nil
    if game_state.casting
      DRC.bput('release spell', 'You let your concentration lapse', "You aren't preparing a spell")
      DRC.bput('release mana', 'You release all', "You aren't harnessing any mana")
    end
    game_state.casting = false
  end

  def check_avtalia(game_state)
    return if @settings.avtalia_array.empty?
    return unless Time.now - @avtalia_timer > 360
    return unless DRStats.mana < 90
    return if game_state.casting

    DRCA.update_avtalia
    @avtalia_timer = Time.now
  end

  def check_regalia(game_state) # designed to catch a signal from SetupProcess and prep regalia
    return unless @regalia_array
    return unless game_state.swap_regalia_type
    return if game_state.swap_regalia_type == game_state.last_regalia_type && !Flags['ct-regalia-expired'] # Don't swap to same armortype unless expiring
    return if game_state.casting
    return if game_state.loaded
    return if DRStats.mana < @buff_spell_mana_threshold

    case game_state.swap_regalia_type
    when 'Light Armor'
      armor_word = 'light'
    when 'Chain Armor'
      armor_word = 'chain'
    when 'Brigandine'
      armor_word = 'brigandine'
    when 'Plate Armor'
      armor_word = 'plate'
    end

    @regalia_spell['cast'] = @know_bespoke ? "cast #{armor_word} all" : 'cast'
    prepare_spell(@regalia_spell, game_state)
  end

  def check_bless(game_state)
    return if game_state.casting
    return unless @buff_spells['Bless']
    return unless Flags['ct-need-bless']

    Flags.reset('ct-need-bless')

    DRCA.prepare?('Bless', 1)
    DRCA.cast?("cast #{DRC.right_hand || DRC.left_hand}")
  end

  def check_ignite(game_state)
    # Ignite must be released before it can be recast
    # Rutilor's Edge and Resonance do not have this problem
    return if @last_seen_weapon_buff_name == game_state.weapon_name
    return unless DRSpells.active_spells['Ignite']

    # Release the spell on the character
    DRC.bput('release ignite', 'The warm feeling in your hand goes away', 'Release what')
    # Wait for the spell on the weapon to be released (it can take a second or two to pulse)
    pause 1
  end

  def check_rutilors_edge(game_state)
    # Rutilor's Edge does not need to be released before it can be recast
    # But releasing allows the buff logic to detect it should be recast
    return if @last_seen_weapon_buff_name == game_state.weapon_name
    return unless DRSpells.active_spells['Rutilor\'s Edge']

    # Release the spell on the character
    DRC.bput('release rue', 'You sense the Rutilor\'s Edge spell fade away', 'Release what')
    # Wait for the spell on the weapon to be released (it can take a second or two to pulse)
    pause 1
  end

  def ready_to_cast?(game_state)
    Flags['ct-spellcast'] || (@prep_time && Time.now - game_state.cast_timer >= @prep_time)
  end

  def check_current(game_state)
    return unless game_state.casting

    game_state.avtalia_cyclic(@mana) if game_state.casting_cyclic
    if @should_invoke
      return if game_state.check_charging?
    end

    return unless ready_to_cast?(game_state)

    game_state.check_harness if @should_harness
    cast_spell(game_state)
  end

  def check_invoke(game_state)
    return unless @should_invoke
    return if @cambrinth_invoke_exact_amount && game_state.charges_total.zero?

    DRCA.find_cambrinth(@cambrinth, @stored_cambrinth, @cambrinth_cap)
    @should_invoke = nil
    invoke_amount = @cambrinth_invoke_exact_amount ? game_state.charges_total : nil
    game_state.charges_total = nil
    DRCA.invoke(@cambrinth, @dedicated_camb_use, invoke_amount)
    DRCA.stow_cambrinth(@cambrinth, @stored_cambrinth, @cambrinth_cap)
  end

  def cast_spell(game_state)
    check_invoke(game_state)
    if game_state.casting_weapon_buff
      @custom_cast = "cast my #{game_state.weapon_name}"
      @last_seen_weapon_buff_name = game_state.weapon_name
    end

    if game_state.casting_consume
      if @necromancer_healing.key?('Consume Flesh') && !@necromancer_healing.key?('Devour')
        @custom_cast = "cast #{game_state.wounds[game_state.wounds.keys.max].first.body_part}"
      end
    end

    DRC.hide?(@hide_type) if game_state.hide_on_cast && game_state.use_stealth?

    if game_state.casting_sorcery
      @equipment_manager.stow_weapon(game_state.weapon_name)
    end

    if game_state.casting_regalia
      result = DRCA.parse_regalia
      if result.empty? # if not wearing a regalia, retreat, swap to regalia gearset, then cast
        DRC.retreat
        @equipment_manager.wear_equipment_set?('regalia')
        @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill) if @settings.gear_sets['regalia'].include?(game_state.weapon_name)
      else # otherwise break what you're already wearing then cast.
        DRCA.shatter_regalia?(result)
      end
    end

    # Warrior Mage's "elemental barrage" attack
    if @prep == 'target' && @barrage && game_state.can_use_barrage_attack?
      @custom_cast = "barrage #{game_state.melee_attack_verb}"
    end

    if game_state.is_offense_allowed? || @prepared_spell['harmless']
      snapshot = DRSkill.getxp(@skill)
      success = DRCA.cast?(@custom_cast, @symbiosis, @before, @after)
      if (@symbiosis || spell_is_sorcery?(@prepared_spell)) && @use_auto_mana
        if !success
          UserVars.discerns[@abbrev]['more'] = [UserVars.discerns[@abbrev]['more'] - 1, 0].max
          @prepared_spell['failed'] = true
          DRC.message("Casting spell #{@abbrev} failed - will no longer automatically increase")
        elsif DRSkill.getxp(@skill) - snapshot < @symbiosis_learning_threshold && !@prepared_spell['failed']
          UserVars.discerns[@abbrev]['more'] = UserVars.discerns[@abbrev]['more'] + 1
        end
      end
    else
      DRC.message('Dropping spell: Offensive magic is not allowed right now...')
      DRC.bput('release spell', 'You let your concentration lapse', "You aren't preparing a spell")
      DRC.bput('release mana', 'You release all', "You aren't harnessing any mana")
    end

    @custom_cast = nil
    @symbiosis = nil
    @barrage = nil
    @before = nil
    @after = nil
    @skill = nil
    @abbrev = nil
    @use_auto_mana = nil
    @prepared_spell = nil
    game_state.hide_on_cast = false
    game_state.casting = false
    game_state.cast_timer = nil

    game_state.casting_weapon_buff = false
    game_state.casting_consume = false
    game_state.casting_nr = false
    game_state.casting_cfb = false
    game_state.casting_cfw = false
    game_state.casting_cyclic = false
    if game_state.casting_sorcery
      game_state.casting_sorcery = false
      @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill)
    end

    if game_state.casting_moonblade
      if DRC.left_hand =~ /moon/ || game_state.brawling? || game_state.offhand?
        # The moonblade was summoned or refreshed while training something else
        DRCMM.wear_moon_weapon?
      end

      game_state.casting_moonblade = false
    end

    check_trader_magic(game_state)

    Flags.reset("ct-#{@reset_expire}") if @reset_expire

    return unless @command

    # escape valve in case spell immediately fails (due to anti magic?)
    temp_count = 0
    until DRRoom.npcs.include?('warrior') || temp_count > 20
      pause 0.5
      temp_count += 1
    end

    fput("command #{@command}")
    @command = nil
  end

  def check_spell_timer?(data)
    Time.now - (@spell_timers[data['pet_type']] || @spell_timers[data['abbrev']] || Time.at(0)) >= data['recast_every']
  end

  def check_buff_conditions?(name, game_state)
    return false if $weapon_buffs.include?(name) && (game_state.aimed_skill? || game_state.brawling?)
    # Resonance does not show up in Active Spells, so we need to track the last weapon on which it was cast to avoid recasting it continuously
    # Ignite and Rutilor's Edge do not have this problem
    return false if name == 'Resonance' && @last_seen_weapon_buff_name == game_state.weapon_name

    true
  end

  def check_training(game_state)
    return if game_state.casting
    return unless @training_spells
    return if @training_spells_max_threshold && game_state.npcs.length > @training_spells_max_threshold

    DRCA.release_cyclics if @release_cyclic_on_low_mana && DRStats.mana < @release_cyclic_threshold
    return if DRStats.mana < @training_spell_mana_threshold

    needs_training = ['Warding', 'Utility', 'Augmentation', 'Sorcery', 'Debilitation', 'Targeted Magic']
                     .select { |skill| @training_spells[skill] }
                     .select { |skill| game_state.is_offense_allowed? || @training_spells[skill]['harmless'] }
                     .select { |skill| ['Warding', 'Utility', 'Augmentation'].include?(skill) || !@training_spells_combat_sorcery && skill == 'Sorcery' || !game_state.npcs.empty? }
                     .select { |skill| DRSkill.getxp(skill) < @magic_exp_training_max_threshold }
                     .select { |skill| Time.now > (@training_spells[skill]['cyclic'] ? @training_cyclic_timer : @training_cast_timer) }
                     .select { |skill| @training_spells[skill]['night'] ? UserVars.sun['night'] : true }
                     .select { |skill| @training_spells[skill]['day'] ? UserVars.sun['day'] : true }
    DRC.message "all eligible training spells: #{needs_training}" if $debug_mode_ct
    needs_training = game_state.sort_by_rate_then_rank(needs_training).first
    return unless needs_training

    DRC.message "needs_training: #{needs_training}" if $debug_mode_ct

    data = @training_spells[needs_training]
    @training_cast_timer = Time.now + @training_spells_wait
    if data['cyclic']
      @training_cyclic_timer = Time.now + 325
      DRC.message "@training_cyclic_timer of Time.now + 325: #{@training_cyclic_timer}" if $debug_mode_ct
    elsif @training_cyclic_timer < @training_cast_timer
      @training_cyclic_timer = @training_cast_timer
      DRC.message "@training_cyclic_timer less than @training_cast_timer: #{@training_cyclic_timer}" if $debug_mode_ct
    end

    game_state.hide_on_cast = true if data['use_stealth']

    if spell_is_sorcery?(data)
      echo 'Preparing a sorcery spell, held items will be stowed to prevent item loss' if $debug_mode_ct
      game_state.casting_sorcery = true
    end
    prepare_spell(data, game_state)
    Flags.reset('ct-spelllost')
  end

  def spell_is_sorcery?(spell_data)
    return true  if spell_data['sorcery']
    return false unless spell_data['mana_type']
    return false if DRStats.native_mana.casecmp(spell_data['mana_type']).zero?
    return false if spell_data['mana_type'].casecmp('ap').zero?

    true
  end

  def cast_runestone(data, game_state)
    DRCA.prepare_to_cast_runestone?(data, @settings)
    return unless DRCI.in_hands?(data['runestone_name'])

    prepare_spell(data, game_state, @buff_force_cambrinth)
    return unless DRCI.in_hands?(data['runestone_name'])

    DRCI.put_away_item?(data['runestone_name'], @runestone_storage)
  end

  def check_buffs(game_state)
    return if game_state.casting
    return if DRStats.mana < @buff_spell_mana_threshold

    recastable_buffs = @buff_spells
                       .select { |_name, data| data['recast'] || data['recast_every'] || data['expire'] }
                       .select { |_name, data| data['expire'] ? Flags["ct-#{data['abbrev']}"] : true }
                       .select { |name, _data| check_buff_conditions?(name, game_state) }
                       .select { |_name, data| data['night'] ? UserVars.sun['night'] : true }
                       .select { |_name, data| data['day'] ? UserVars.sun['day'] : true }
                       .select { |_name, data| data['starlight_threshold'] ? enough_starlight?(game_state, data) : true }
                       .reject { |_name, data| data['cyclic'] && DRSpells.active_spells.include?(data['name']) && !data['recast_every'] }

    name, data = recastable_buffs.find do |name, data|
      if data['pet_type']
        check_spell_timer?(data) && DRRoom.npcs.include?(data['pet_type'])
      elsif data['recast_every']
        check_spell_timer?(data)
      elsif data['expire']
        true
      else
        !DRSpells.active_spells[name] || DRSpells.active_spells[name].to_i <= data['recast']
      end
    end
    echo("found buff missing: #{name}") if $debug_mode_ct && name
    game_state.casting_weapon_buff = $weapon_buffs.include?(name)
    if data['ritual']
      cast_ritual(data, game_state)
    elsif data['runestone_name']
      if DRCI.inside?(data['runestone_name'], @runestone_storage)
        data['runestone_for_combat_exists'] = true
        cast_runestone(data, game_state)
      else
        ### Just need this setting to remove the spell from the list
        data['runestone_for_combat_exists'] = false
        @buff_spells.reject! { |spell| @buff_spells[spell]['runestone_for_combat_exists'] == false }
        return
      end
    else
      prepare_spell(data, game_state, @buff_force_cambrinth)
    end
  end

  def check_health(game_state)
    return if game_state.casting
    return check_health_barbarian(game_state) if DRStats.barbarian?
    return check_health_empath(game_state) if DRStats.empath?
  end

  def check_health_barbarian(_game_state)
    if !@barb_healing.empty?
      return if DRSpells.active_spells['Famine']
      return if DRStats.health > @barb_healing['health_threshold']
      return if DRStats.mana < @barb_healing['inner_fire_threshold']

      DRC.message("Activating FAMINE as your health has dropped below the threshold of #{@barb_healing['health_threshold']}")
      DRCA.activate_barb_buff?('Famine')
    end
  end

  def check_health_empath(game_state)
    return if DRStats.health > @empath_vitality_threshold && @wounds.empty?

    if DRSpells.active_spells['Regeneration']
      if @empath_spells['VH'] && DRStats.health <= @empath_vitality_threshold
        data = { 'abbrev' => 'vh', 'mana' => @empath_spells['VH'].first, 'cambrinth' => @empath_spells['VH'][1..-1], 'harmless' => true }
        prepare_spell(data, game_state)
      end
      return
    end

    if Time.now - @perc_health_timer > 30 && @empath_spells['FOC'] || @empath_spells['HEAL']
      @perc_health_timer = Time.now
      @wounds = DRCH.perceive_health['wounds']
    end

    echo('Healing') if $debug_mode_ct
    if @wounds.any?
      if @empath_spells['FOC']
        data = { 'abbrev' => 'foc', 'mana' => @empath_spells['FOC'].first, 'cambrinth' => @empath_spells['FOC'][1..-1], 'harmless' => true }
      elsif @empath_spells['HEAL']
        data = { 'abbrev' => 'heal', 'mana' => @empath_spells['HEAL'].first, 'cambrinth' => @empath_spells['HEAL'][1..-1], 'harmless' => true }
      end
      @wounds = {}
      prepare_spell(data, game_state, true) if data
    elsif @empath_spells['VH']
      data = { 'abbrev' => 'vh', 'mana' => @empath_spells['VH'].first, 'cambrinth' => @empath_spells['VH'][1..-1], 'harmless' => true }
      prepare_spell(data, game_state, true)
    end
  end

  def check_starlight(game_state)
    return unless DRStats.trader?
    return unless @aura_frequency > 0 && (Time.now - @aura_timer).to_i > @aura_frequency

    @aura_timer = Time.now
    game_state.starlight_values = DRCA.perc_aura
  end

  def enough_starlight?(game_state, data)
    return UserVars.sun['night'] unless DRStats.trader?
    return true unless game_state.starlight_values

    data['starlight_threshold'] <= game_state.starlight_values['level']
  end

  def check_trader_magic(game_state) # handles starlight-depletion and regalia
    return unless DRStats.trader?

    if Flags['ct-starlight-depleted']
      DRC.message '----OUT OF STARLIGHT - DELETING STARLIGHT MAGIC----'
      @buff_spells.reject! { |spell| @buff_spells[spell]['starlight_threshold'] > -1 } # delete all buffs and offensive spells. Potential to add stellar collector support later
      @offensive_spells.reject! { |spell| spell['starlight_threshold'] > -1 }
      @aura_frequency = 0
      game_state.regalia_cancel = true # stop all regalia swap functions and clean it up next time it expires.
    end
    if game_state.casting_regalia
      if Flags['ct-starlight-depleted'] # In some conditions, regalia can run out of starlight partway through creation.  Don't want a partial regalia on.
        DRCA.shatter_regalia?
        @equipment_manager.wear_equipment_set?('standard')
        @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill) if @settings.gear_sets['standard'].include?(game_state.weapon_name)
        game_state.last_regalia_type = nil
        game_state.swap_regalia_type = nil
      end
      if Flags['ct-regalia-succeeded']
        Flags.reset('ct-regalia-expired')
        Flags.reset('ct-regalia-succeeded')
        game_state.last_regalia_type = game_state.swap_regalia_type
        game_state.swap_regalia_type = nil
      end
      game_state.casting_regalia = false
    end
    Flags.reset('ct-starlight-depleted')
  end

  def check_cfb(game_state)
    return unless DRStats.necromancer?
    return unless @necromancer_zombie['Call from Beyond']
    return if game_state.casting
    return unless game_state.prepare_cfb

    game_state.casting_cfb = true
    game_state.prepare_cfb = false
    data = @necromancer_zombie['Call from Beyond']
    prepare_spell(data, game_state, true)
  end

  def check_cfw(game_state)
    return unless DRStats.necromancer?
    return unless @necromancer_bonebug['Call from Within']
    return if game_state.casting
    return unless game_state.prepare_cfw

    game_state.casting_cfw = true
    game_state.prepare_cfw = false
    data = @necromancer_bonebug['Call from Within']
    prepare_spell(data, game_state, true)
  end

  def heal_corpse(game_state)
    return unless DRStats.necromancer?
    return unless @corpse_healing['Necrotic Reconstruction']
    return if game_state.casting
    return unless game_state.prepare_nr

    game_state.casting_nr = true
    game_state.prepare_nr = false
    data = @corpse_healing['Necrotic Reconstruction']
    prepare_spell(data, game_state, true)
  end

  def check_consume(game_state)
    return unless DRStats.necromancer?
    return unless @necromancer_healing
    return if game_state.casting

    if DRStats.health <= @siphon_vit_threshold.to_i && @necromancer_healing['Siphon Vitality'] && !game_state.npcs.empty?
      @necromancer_healing['Siphon Vitality']['prep'] = 'target'
      prepare_spell(@necromancer_healing['Siphon Vitality'], game_state, true)
      return
    end

    return unless game_state.prepare_consume
    return if @necromancer_healing.key?('Devour') && DRSpells.active_spells['Devour']

    echo "@necromancer_healing.key?('Consume Flesh'): #{@necromancer_healing.key?('Consume Flesh')}" if $debug_mode_ct
    echo "@necromancer_healing.key?('Devour'): #{@necromancer_healing.key?('Devour')}" if $debug_mode_ct
    data = @necromancer_healing['Devour'] || @necromancer_healing['Consume Flesh']
    game_state.casting_consume = true
    game_state.prepare_consume = false
    prepare_spell(data, game_state, true)
  end

  def check_offensive(game_state)
    echo "Checking offensive spells:" if $debug_mode_ct
    return if game_state.casting
    return if game_state.npcs.empty?
    return if DRStats.mana < @offensive_spell_mana_threshold

    echo "Figuring out ready offensive spells..." if $debug_mode_ct
    ready_spells = @offensive_spells
                   .select { |spell| spell['target_enemy'] ? game_state.npcs.include?(spell['target_enemy']) : true }
                   .select { |spell| spell['min_threshold'] ? game_state.npcs.length >= spell['min_threshold'] : true }
                   .select { |spell| spell['max_threshold'] ? game_state.npcs.length <= spell['max_threshold'] : true }
                   .select { |spell| spell['expire'] ? Flags["ct-#{spell['abbrev']}"] : true }
                   .select { |spell| game_state.is_offense_allowed? || spell['harmless'] }
                   .select { |spell| game_state.dancing? ? spell['harmless'] : true }
                   .select { |spell| spell['recast_every'] ? check_spell_timer?(spell) : true }
                   .select { |spell| (@cast_only_to_train || spell['cast_only_to_train']) ? DRSkill.getxp(spell['skill']) <= @magic_exp_training_max_threshold : true }
                   .select { |spell| spell['cyclic'] ? !DRSpells.active_spells[spell['name']] : true }
                   .select { |spell| spell['night'] ? UserVars.sun['night'] : true }
                   .select { |spell| spell['day'] ? UserVars.sun['day'] : true }
                   .select { |spell| spell['slivers'] ? (DRSpells.slivers || @tk_ammo) : true }
                   .select { |spell| spell['starlight_threshold'] ? enough_starlight?(game_state, spell) : true }
    echo "Ready Spells: #{ready_spells.to_yaml}" if $debug_mode_ct

    data = if @offensive_spell_cycle.empty?
             skills = ready_spells.map { |spell| spell['skill'] }
             skill = game_state.sort_by_rate_then_rank(skills).first
             ready_spells.find { |spell| spell['skill'] == skill }
           else
             name = @offensive_spell_cycle.find { |spell_name| ready_spells.find { |spell| spell['name'] == spell_name } }
             @offensive_spell_cycle.rotate!
             ready_spells.find { |spell| spell['name'] == name }
           end

    game_state.hide_on_cast = true if data['use_stealth']

    if data['runestone_name']
      if DRCI.inside?(data['runestone_name'], @runestone_storage)
        data['runestone_for_combat_exists'] = true
        cast_runestone(data, game_state)
      else
        ### Just need this setting to remove the spell from the list
        data['runestone_for_combat_exists'] = false
        @offensive_spells.reject! { |spell| spell['runestone_for_combat_exists'] == false }
        return
      end
    else
      prepare_spell(data, game_state)
    end

    Flags.reset('ct-spelllost')
  end

  def cast_ritual(data, game_state)
    if (summoned = game_state.summoned_info(game_state.weapon_skill))
      DRCS.break_summoned_weapon(game_state.weapon_name)
    else
      @equipment_manager.stow_weapon(game_state.weapon_name)
    end

    data = DRCMM.update_astral_data(data, @settings)
    if data # DRCMM.update_astral_data returns nil on failure
      check_invoke(game_state)
      DRCA.ritual(data, @settings)
    end

    if summoned
      game_state.prepare_summoned_weapon(false)
    else
      @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill)
    end
    game_state.reset_stance = true
  end

  def prepare_spell(data, game_state, force_cambrinth = false)
    return unless data

    data = DRCA.check_discern(data, @settings, spell_is_sorcery?(data)) if data['use_auto_mana']
    game_state.cast_timer = Time.now
    @prep_time = data['prep_time']
    echo("prepare spell: #{data}") if $debug_mode_ct
    if data['target_enemy']
      echo("  Target found: #{data['target_enemy']}") if $debug_mode_ct
      fput("face #{data['target_enemy']}")
    end

    command = 'prep'
    command = data['prep'] if data['prep']
    command = data['prep_type'] if data['prep_type']

    if command == 'segue'
      return if DRCA.segue?(data['abbrev'], data['mana'])

      command = 'prep'
    end

    if data['cyclic']
      DRCA.release_cyclics
      game_state.casting_cyclic = true
    end

    if data['recast_every']
      if data['pet_type']
        @spell_timers[data['pet_type']] = Time.now
      else
        @spell_timers[data['abbrev']] = Time.now
      end
    end

    if data['moon']
      DRCMM.check_moonwatch
      moon = UserVars.moons['visible'].first
      if data['name'].downcase == 'moonblade'
        game_state.casting_moonblade = true
        last_moon = DRCMM.moon_used_to_summon_weapon
        # Determine if we can just refresh the currently summoned weapon.
        # Doing so can save us some RT by not needing to shape a new summoned weapon again.
        # We'll only do this if the last moon used is expected to stay visible for a decent amount of time.
        if DRCMM.hold_moon_weapon? && UserVars.moons['visible'].include?(last_moon) && UserVars.moons[last_moon]['timer'] >= 4
          moon = last_moon
          data['cast'] = "cast #{moon} refresh"
        else
          # Drop current moon weapon because we're casting
          # on a different moon to summon a new weapon.
          DRCMM.drop_moon_weapon?
          data['cast'] = "cast #{moon}"
        end
      elsif !moon && data['name'].downcase == 'cage of light'
        data['cast'] = "cast ambient"
      elsif !moon
        echo "No moon available to cast #{data['abbrev']}" if $debug_mode_ct

        @weather ||= DRC.bput('weather', 'inside', 'You glance up at the sky.', 'You glance outside')
        if @weather =~ /inside/
          DRC.message "*** You're inside and there are no available moons. You're going to have a hard time casting #{data['abbrev']}"
        end

        unless UserVars.moons['visible'].first
          echo "Couldn't find any moons to cast #{data['abbrev']} with" if $debug_mode_ct
          return
        end
      else
        data['cast'] = "cast #{moon}"
      end
    end

    game_state.casting_regalia = data['abbrev'].casecmp('REGAL').zero?

    Flags.reset('ct-shock-warning')
    DRCA.prepare?(data['abbrev'], data['mana'], data['symbiosis'], command, data['tattoo_tm'], data['runestone_name'], data['runestone_tm'])

    if Flags['ct-shock-warning'] && !game_state.is_permashocked?
      DRC.message('Dropping spell: Got shock warning.')
      DRC.bput('release spell', 'You let your concentration lapse', "You aren't preparing a spell")
      DRC.bput('release mana', 'You release all', "You aren't harnessing any mana")
    end

    game_state.casting = true
    game_state.cambrinth_charges(data['cambrinth'])
    if data['cambrinth']
      @should_harness = DRCA.check_to_harness(@harness_for_attunement) && !force_cambrinth
      @should_invoke = data['cambrinth'] unless @should_harness
    end
    @custom_cast = data['cast']
    @symbiosis = data['symbiosis']
    @barrage = data['barrage']
    @after = data['after']
    @skill = data['skill']
    @prep = data['prep']
    @mana = data['mana']
    @command = data['command']
    @prepared_spell = data
    @reset_expire = data['expire'] ? data['abbrev'] : nil
    Flags.reset('ct-spellcast')
    @before = data['before']
    @abbrev = data['abbrev']
    @use_auto_mana = data['use_auto_mana']
    game_state.action_taken if (@skill == 'Targeted Magic' || @prep == 'target') && game_state.weapon_skill == 'Targeted Magic'
  end
end

class PetProcess
  def initialize(settings)
    echo('New Pet Process') if $debug_mode_ct

    @zombie = settings.zombie
    echo("  @zombie: #{@zombie}") if $debug_mode_ct
    @bonebug = settings.bonebug
    echo("  @bonebug: #{@bonebug}") if $debug_mode_ct

    @is_present = false
    @current_stance = nil
    @current_behavior = nil
  end

  def execute(game_state)
    check_zombie(game_state)
    if game_state.dismiss_pet?
      dismiss_zombie(game_state)
      dismiss_bonebug(game_state)
      game_state.next_clean_up_step
      return true
    end
    false
  end

  def summon_zombie(game_state)
    return unless game_state.cfb_active?
    return unless @zombie['summon']
    return if @is_present

    command_zombie('come', game_state)
  end

  def dismiss_zombie(game_state)
    return unless @is_present
    return unless game_state.cfb_active?

    command_zombie('leave', game_state)
  end

  def dismiss_bonebug(game_state)
    return unless @is_present
    return unless game_state.cfw_active?

    DRCA.release_cyclics
  end

  def update_behavior(game_state)
    return unless game_state.cfb_active?
    return unless @zombie['behavior']
    return if @zombie['behavior'].eql?(@current_behavior)

    command_zombie("behavior #{@zombie['behavior']}", game_state)
  end

  def update_stance(game_state)
    return unless game_state.cfb_active?
    return unless @zombie['stance']
    return if @zombie['stance'].eql?(@current_stance)

    command_zombie("stance #{@zombie['stance']}", game_state)
  end

  def check_zombie(game_state)
    return unless DRStats.necromancer?
    return unless game_state.cfb_active?

    summon_zombie(game_state)
    update_behavior(game_state)
    update_stance(game_state)
  end

  def command_zombie(command, game_state)
    return unless game_state.cfb_active?

    case DRC.bput("command zombie #{command}", 'willing it to come back to you', 'You have already shifted', 'That is not a valid stance', 'is already right beside you', 'zombie shambles off with a groan', 'You sense a flicker of acknowledgement through the link', 'you sense your .+ shift into (a|an) \w+ stance', 'you sense your .+ behavior shift')
    when 'is already right beside you'
      echo('  Zombie is present') if $debug_mode_ct
      @is_present = true
    when 'zombie shambles off with a groan'
      echo('  Zombie is no longer present') if $debug_mode_ct
      @is_present = false
    when /shift into a \w+ stance/
      echo("  Zombie stance set to #{@zombie['stance']}") if $debug_mode_ct
      @current_stance = @zombie['stance']
    when /you sense your .+ behavior shift/
      echo("  Zombie behavior set to #{@zombie['behavior']}") if $debug_mode_ct
      @current_behavior = @zombie['behavior']
    end
  end
end

class AbilityProcess
  def initialize(settings)
    echo('New AbilityProcess') if $debug_mode_ct

    @buffs = settings.buff_nonspells
    echo("  @buffs: #{@buffs}") if $debug_mode_ct

    @khri = @buffs.delete('khri') || []
    echo("  @khri: #{@khri}") if $debug_mode_ct

    @kneel_khri = settings.kneel_khri
    echo("  @kneel_khri: #{@kneel_khri}") if $debug_mode_ct

    @battle_cries = settings.battle_cries
    echo("  @battle_cries: #{@battle_cries}") if $debug_mode_ct

    @battle_cry_cycle = settings.battle_cry_cycle || @battle_cries.map { |battle_cry| battle_cry['name'] }
    echo("  @battle_cry_cycle: #{@battle_cry_cycle}") if $debug_mode_ct

    @battle_cry_cooldown = settings.battle_cry_cooldown
    echo("  @battle_cry_cooldown: #{@battle_cry_cooldown}") if $debug_mode_ct

    @roar_helm_noun = settings.roar_helm_noun
    echo("  @roar_helm_noun: #{@roar_helm_noun}") if $debug_mode_ct

    @barb_buffs = @buffs.delete('barb_buffs') || []
    echo("  @barb_buffs: #{@barb_buffs}") if $debug_mode_ct

    @barb_buffs_inner_fire_threshold = settings.barb_buffs_inner_fire_threshold
    echo("  @barb_buffs_inner_fire_threshold: #{@barb_buffs_inner_fire_threshold}") if $debug_mode_ct

    @meditation_pause_timer = settings.meditation_pause_timer
    echo("  @meditation_pause_timer: #{@meditation_pause_timer}") if $debug_mode_ct

    setup_barb_buff_flags
    Flags.add('ct-battle-cry-not-facing', 'You are not facing an enemy')

    @paladin_use_badge = settings.paladin_use_badge
    echo("  @paladin_use_badge: #{@paladin_use_badge}") if $debug_mode_ct

    @use_mana_glyph = settings.paladin_use_mana_glyph
    echo("  @paladin_glyphs: #{@paladin_glyphs}") if $debug_mode_ct

    if @use_mana_glyph
      Flags.add('glyph-mana-expired', 'You sense the holy power return to normal')
      Flags['glyph-mana-expired'] = true
      echo 'Added glyph of mana expiration flag.' if $debug_mode_ct
    end

    # Warhorn setting, could be legacy egg or warhorn
    @warhorn = settings.warhorn
    echo("  @warhorn: #{@warhorn}") if $debug_mode_ct

    # Allows user to set the warhorn cooldown
    @warhorn_cooldown = settings.warhorn_cooldown.to_i || 1200
    echo("  @warhorn_cooldown: #{@warhorn_cooldown}") if $debug_mode_ct

    @stomp_on_cooldown = settings.war_stomp_on_cooldown
    echo("  @stomp_on_cooldown: #{@stomp_on_cooldown}") if $debug_mode_ct

    @pounce_on_cooldown = settings.pounce_on_cooldown
    echo("  @pounce_on_cooldown: #{@pounce_on_cooldown}") if $debug_mode_ct

    # Egg settings, for egg only
    @egg = settings.egg
    echo("  @egg: #{@egg}") if $debug_mode_ct

    set_warhorn_or_egg if @warhorn || @egg

    return unless @paladin_use_badge

    if DRCI.wearing?('pilgrim badge')
      @paladin_badge_get_verb = 'remove'
      @paladin_badge_store_verb = 'wear'
    else
      @paladin_badge_get_verb = 'get'
      @paladin_badge_store_verb = 'stow'
    end

    UserVars.paladin_last_badge_use ||= Time.now
    @badge_reuse_cooldown = 1860 # 31 minutes
  end

  def execute(game_state)
    check_paladin_skills
    check_nonspell_buffs(game_state)
    check_battle_cries(game_state)
    use_warhorn_or_egg(game_state) unless @warhorn_or_egg.nil? || @warhorn_or_egg.empty?
    game_state.stomp if @stomp_on_cooldown && game_state.npcs && Flags['war-stomp-ready']
    game_state.pounce if DRStats.ranger? && @pounce_on_cooldown && game_state.npcs && Flags['pounce-ready']
    false
  end

  private

  # Sets up our warhorn and/or egg use. Sets timers. Allows legacy use of warhorn: egg. Checks to
  # see if we're using a wearable warhorn or have it in a bag.
  def set_warhorn_or_egg
    # Helps us rotate horn/egg use
    @warhorn_or_egg = [@warhorn, @egg].compact

    # Store timestamps in UserVars
    UserVars.warhorn = {} unless UserVars.warhorn
    UserVars.warhorn["last_warhorn"] = (Time.now - @warhorn_cooldown) unless UserVars.warhorn["last_warhorn"]
    UserVars.warhorn["last_egg"] = (Time.now - 900) unless UserVars.warhorn["last_egg"]
    UserVars.warhorn["last_warhorn_or_egg"] = (Time.now - 600) unless UserVars.warhorn["last_warhorn_or_egg"]

    # If user has defined both a warhorn and egg, we'll rotate, and since cooldowns are persistent in UserVars,
    # do a one-time check to see which has lower time left, and put that first.
    if @warhorn_or_egg.count > 1
      if (Time.now - UserVars.warhorn["last_egg"]) > (Time.now - UserVars.warhorn["last_warhorn"])
        @warhorn_or_egg.rotate!
      end
    end

    # This is how an egg was specified prior to this warhorn/egg rotation code. We'll still support.
    if @warhorn =~ /egg/
      echo "Legacy use of warhorn: egg. Handling." if $debug_mode_ct
      @warhorn_activation_command = "invoke my #{@warhorn}"
    else
      echo "Warhorn is actually a warhorn, not legacy use of : egg." if $debug_mode_ct
      @warhorn_activation_command = "exhale #{@warhorn} lure"
    end

    # Set our warhorn verbs depending on whether a worn or stowed warhorn.
    if DRCI.wearing?(@warhorn)
      echo "We're wearing the warhorn, remove/wear are the verbs." if $debug_mode_ct
      @warhorn_get_verb = 'remove'
      @warhorn_store_verb = 'wear'
    else
      echo "Not wearing warhorn, get/stow are the verbs." if $debug_mode_ct
      @warhorn_get_verb = 'get'
      @warhorn_store_verb = 'stow'
    end
  end

  # Controller method for warhorn and/or egg use
  def use_warhorn_or_egg(game_state)
    DRC.message("Time since last warhorn room effect: #{(Time.now - UserVars.warhorn["last_warhorn_or_egg"]) / 60}") if $debug_mode_ct
    DRC.message("Time since last warhorn use: #{(Time.now - UserVars.warhorn["last_warhorn"]) / 60}") if $debug_mode_ct
    DRC.message("Time since last egg use: #{(Time.now - UserVars.warhorn["last_egg"]) / 60}") if $debug_mode_ct

    # Return if it hasn't been 10 minutes since last warhorn. Room effect lasts 10 minutes.
    return unless Time.now > (UserVars.warhorn["last_warhorn_or_egg"] + 600)

    noun = @warhorn_or_egg[0]

    # Check timers. Egg is always 15 minutes. Warhorn is 20 minutes, or configurable.
    if noun =~ /egg/i
      return unless Time.now > UserVars.warhorn["last_egg"] + 900

      if use_egg?
        DRC.message("SUCCESSFUL egg use") if $debug_mode_ct
        UserVars.warhorn["last_egg"] = Time.now
        UserVars.warhorn["last_warhorn_or_egg"] = Time.now
      end
    else
      return unless Time.now > (UserVars.warhorn["last_warhorn"] + @warhorn_cooldown)

      if use_warhorn?(game_state)
        DRC.message("SUCCESSFUL horn use") if $debug_mode_ct
        UserVars.warhorn["last_warhorn"] = Time.now
        UserVars.warhorn["last_warhorn_or_egg"] = Time.now
      end
    end

    # Rotate array to rotate warhorn/egg use. If we only have one, this still works fine.
    @warhorn_or_egg.rotate!
  end

  def use_egg?
    use_egg = DRC.bput('invoke my egg', 'light envelops the area briefly',
                       'The red light within the egg is dim and moves about sluggishly',
                       'Something about the area inhibits', 'Invoke what?', 'You cannot stay hidden while using the egg.')

    case use_egg
    when /The red light within the egg is dim and moves about sluggishly/
      return false
    when /Something about the area inhibits/
      DRC.message("Egg can't be used in this area. Removing from hunt.")
      @warhorn_or_egg.delete('egg')
      return false
    when /^What were you referring to/, /Invoke what?/
      DRC.message("Can't find egg, removing from hunt.")
      @warhorn_or_egg.delete('egg')
      return false
    end

    return true
  end

  def use_warhorn?(game_state)
    game_state.sheath_whirlwind_offhand
    use_warhorn = DRC.bput("#{@warhorn_get_verb} my #{@warhorn}", /^You get.*(?:warhorn).*\.$/,
                           /^You remove.*(?:warhorn).*\.$/, /^You take.*(?:warhorn).*\.$/, /^What were you referring to/,
                           /^You need a free hand/, /^Remove what/)

    case use_warhorn
    when /^You get.*(?:warhorn).*\.$/, /^You remove.*(?:warhorn).*\.$/, /^You take.*(?:warhorn).*\.$/
      warhorn_activation = DRC.bput(@warhorn_activation_command, 'Something about the area inhibits',
                                    'You sound a series of bursts from the', 'Your lungs are tired from having sounded a', 'not accomplishing much and looking rather silly')
      if /Your lungs are tired from having sounded a/ =~ warhorn_activation
        stow_warhorn(game_state)
        return true
      elsif /Something about the area inhibits/ =~ warhorn_activation
        DRC.message "Can't use #{@warhorn} in this area. Removing from hunt."
        stow_warhorn(game_state)
        @warhorn_or_egg.delete(@warhorn)
        return false
      elsif /not accomplishing much and looking rather silly/ =~ warhorn_activation
        DRC.message "You can't use a warhorn. Removing from hunt."
        stow_warhorn(game_state)
        @warhorn_or_egg.delete(@warhorn)
        return false
      end
      waitrt?
      stow_warhorn(game_state)
    when /^What were you referring to/
      DRC.message "#{@warhorn} NOT FOUND! Removing from hunt."
      @warhorn_or_egg.delete(@warhorn)
      return false
    end

    return true
  end

  def stow_warhorn(game_state)
    DRC.bput("#{@warhorn_store_verb} my #{@warhorn}", 'You put', 'You attach')
    game_state.wield_whirlwind_offhand
  end

  def check_paladin_skills
    return unless DRStats.paladin?

    pray_badge
    check_mana_glyph
  end

  def pray_badge
    return unless @paladin_use_badge
    return unless Time.now - UserVars.paladin_last_badge_use > @badge_reuse_cooldown

    case DRC.bput("#{@paladin_badge_get_verb} my pilgrim badge", 'You take off', 'You get', 'You remove', 'What were you referring to', 'You need a free hand', 'Remove what')
    when 'You get', 'You remove', 'You take off'
      DRC.retreat
      DRC.bput('pray my pilgrim badge', 'You think upon the immortals')
      UserVars.paladin_last_badge_use = Time.now
      waitrt?
      DRC.bput("#{@paladin_badge_store_verb} my pilgrim badge", 'You put', 'You attach')
    when 'What were you referring to'
      DRC.message '***PILGRIM BADGE NOT FOUND! REMOVING FROM HUNT.***'
      @paladin_use_badge = false
      return
    end
  end

  def check_mana_glyph
    return unless @use_mana_glyph
    return unless Flags['glyph-mana-expired']

    DRC.bput('glyph mana', 'You trace a glyph', 'You begin to trace')
    Flags.reset('glyph-mana-expired')
    echo 'Used Glyph of Mana!' if $debug_mode_ct
  end

  # Barbarians without knowledge of the Power meditation won't
  # see their activated abilities in the spell window.
  # This means we can't always rely on DRSpells.active_spells
  # to know if an ability is active or not for those characters.
  # As a workaround, we monitor for the expiry messages.
  def setup_barb_buff_flags
    @barb_buffs.each do |name|
      ability_data = get_data('spells').barb_abilities[name]
      Flags.add("ap-#{name}-expired", ability_data['expired_message'])
      Flags["ap-#{name}-expired"] = true unless DRSpells.active_spells[name]
      echo "setup_barb_buff_flags:: adding #{Flags["ap-#{name}-expired"]} flag with an expiration message of: #{ability_data['expired_message']}" if $debug_mode_ct
    end
  end

  def check_nonspell_buffs(game_state)
    @buffs.each do |action, cooldown|
      timer = game_state.cooldown_timers[action]
      next unless !timer || (Time.now - timer).to_i > cooldown

      game_state.cooldown_timers[action] = Time.now
      fput action
      waitrt?
    end

    @khri
      .map { |name| "Khri #{name}" }
      .each do |name|
        next if game_state.danger && DRCA.kneel_for_khri?(@kneel_khri, name)

        timer = game_state.cooldown_timers[name]
        next unless !timer || (Time.now - timer).to_i > 30

        if DRCA.activate_khri?(@kneel_khri, name)
          game_state.cooldown_timers[name] = Time.now
          echo "Activated khri #{name}" if $debug_mode_ct
        else
          echo "Did not activate khri #{name}" if $debug_mode_ct
        end
      end

    @barb_buffs
      .select { |name| Flags["ap-#{name}-expired"] }
      .reject { |name| DRSpells.active_spells[name] }
      .each do |name|
        timer = game_state.cooldown_timers[name]
        next unless !timer || (Time.now - timer).to_i > 30

        if name == 'Tsunami' && (!game_state.melee_weapon_skill? || DRC.right_hand.nil? || DRC.right_hand.empty?)
          echo "Not activating barb_buff #{name} because you're not currently wielding a melee weapon. Will retry when you're training melee weapons." if $debug_mode_ct
        elsif DRStats.mana < @barb_buffs_inner_fire_threshold
          echo "Not activating barb_buff #{name} until have at least #{@barb_buffs_inner_fire_threshold} inner fire. You currently have #{DRStats.mana}." if $debug_mode_ct
        elsif DRCA.activate_barb_buff?(name, @meditation_pause_timer)
          Flags.reset("ap-#{name}-expired")
          game_state.cooldown_timers[name] = Time.now
          echo "Activated barb_buff #{name}" if $debug_mode_ct
        else
          echo "Did not activate barb_buff #{name}" if $debug_mode_ct
        end
      end
  end

  def check_battle_cries(game_state)
    timer = game_state.cooldown_timers['Battle Cry']
    return unless !timer || (Time.now - timer).to_i > @battle_cry_cooldown
    return unless game_state.can_face?

    Flags.reset('ct-battle-cry-not-facing')

    battle_cries = @battle_cries
                   .select { |battle_cry| battle_cry['target_enemy'] ? game_state.npcs.include?(battle_cry['target_enemy']) : true }
                   .select { |battle_cry| battle_cry['min_threshold'] ? game_state.npcs.length >= battle_cry['min_threshold'] : true }
                   .select { |battle_cry| battle_cry['max_threshold'] ? game_state.npcs.length <= battle_cry['max_threshold'] : true }

    # Of the ready battle cries, find the next best one according to the preferred cycle
    battle_cry_name = @battle_cry_cycle.find { |next_cry| battle_cries.find { |ready_cry| ready_cry['name'] == next_cry } }

    # Get the details about the selected battle cry
    battle_cry_data = battle_cries.find { |battle_cry| battle_cry['name'] == battle_cry_name }

    if battle_cry_data
      echo "Selected battle cry: #{battle_cry_data}" if $debug_mode_ct
      echo "Using roar helm: #{@roar_helm_noun}" if @roar_helm_noun && $debug_mode_ct

      command = battle_cry_data['command']
      command = (command + " at " + battle_cry_data['target_enemy']) if battle_cry_data['target_enemy']

      # Use roar helm if specified
      fput("scream #{@roar_helm_noun}") if @roar_helm_noun
      pause
      waitrt?

      fput(command)
      pause
      waitrt?
      if Flags['ct-battle-cry-not-facing']
        # Oops, you're not actually facing an enemy to roar/scream at
        case DRC.bput('face next', 'You turn', 'There is nothing else to face', 'Face what')
        when 'You turn'
          # Let's try that again...
          check_battle_cries(game_state)
        else
          # Nothing to roar/scream at, maybe next time
          return
        end
      else
        game_state.cooldown_timers['Battle Cry'] = Time.now
        @battle_cry_cycle.rotate!
      end
    else
      echo "No battle cries met criteria" if $debug_mode_ct
    end
  end
end

class ManipulateProcess
  def initialize(settings)
    echo('New ManipulateProcess') if $debug_mode_ct

    @threshold = settings.manipulate_threshold
    echo("  @threshold: #{@threshold}") if $debug_mode_ct

    @manip_to_train = settings.manipulate_only_to_train
    echo("  @manip_to_train: #{@manip_to_train}") if $debug_mode_ct

    @last_manip = Time.now - 200
  end

  def execute(game_state)
    return if game_state.danger || @threshold.nil? || game_state.construct_mode?

    @filtered_npcs = game_state.npcs
    manipulate(game_state) if should_manipulate?
  end

  private

  def should_manipulate?
    return false if @manip_to_train && DRSkill.getxp('Empathy') > 30

    @filtered_npcs.length >= @threshold && Time.now - @last_manip > 120
  end

  def manipulate(game_state)
    DRC.bput('manipulate stop all', /^You relax your will/, /^But you aren't manipulating anything/)

    manipulate_count = 0
    npc_occurrences = Hash.new(0)

    @filtered_npcs.each do |npc|
      next if game_state.construct?(npc)
      break if manipulate_count >= @threshold

      index = npc_occurrences[npc]
      ordinal_string = $ORDINALS[index]

      case DRC.bput("manipulate friendship #{ordinal_string} #{npc}", 'You\'re already manipulating', 'beyond your ken', 'You attempt to empathically manipulate', 'You strain', 'does not seem to have a life essence', 'Manipulate what')
      when 'does not seem to have a life essence' then
        game_state.construct(npc)
      else
        manipulate_count += 1
        npc_occurrences[npc] += 1
      end
    end

    @last_manip = Time.now
  end
end

class TrainerProcess
  def initialize(settings, equipment_manager)
    @equipment_manager = equipment_manager
    echo('New TrainerProcess') if $debug_mode_ct
    @training_abilities = settings.training_abilities
    echo("  @training_abilities: #{@training_abilities}") if $debug_mode_ct

    @skill_map = {
      'Almanac'                    => 'Anything',
      'Ambush Choke'               => 'Debilitation',
      'Ambush Stun'                => settings.stun_skill,
      'Analyze'                    => 'Tactics',
      'App Bundle'                 => 'Appraisal',
      'App Careful'                => 'Appraisal',
      'App Pouch'                  => 'Appraisal',
      'App Quick'                  => 'Appraisal',
      'App'                        => 'Appraisal',
      'Astro'                      => 'Astrology',
      'Barb Research Augmentation' => 'Augmentation', # Debilitation cannot be learned via meditate research
      'Barb Research Utility'      => 'Utility',           # because it is a combat skill and can only be learned by
      'Barb Research Warding'      => 'Warding',           # contesting your opponent, such as roaring against them.
      'Berserk Landslide'          => 'Warding',
      'Berserk Avalanche'          => 'Utility',
      'Charged Maneuver'           => 'Expertise',
      'Collect'                    => 'Outdoorsmanship',
      'Favor Orb'                  => 'Anything',
      'Flee'                       => 'Athletics',
      'Hunt'                       => 'Perception',
      'Khri Prowess'               => 'Debilitation',
      'Meraud'                     => 'Theurgy',
      'Perc Health'                => 'Empathy',
      'Perc'                       => 'Attunement',
      'PercMana'                   => 'Attunement',
      'Pray'                       => 'Theurgy',
      'PrayerMat'                  => 'Theurgy',
      'Recall'                     => 'Scholarship',
      'Scream'                     => 'Bardic Lore',
      'Smite'                      => 'Conviction',
      'Stealth'                    => 'Stealth',
      'Tactics'                    => 'Tactics',
      'Teach'                      => 'Scholarship',
      'Tessera'                    => 'Trading',
      'Locksmithing'               => 'Locksmithing'
    }

    @skill_map['Hunt'] = %w[Perception Instinct] if DRStats.ranger?
    @favor_god = settings.favor_god
    if settings.favor_goal && @favor_god && /delicate/ =~ DRC.bput("tap #{@favor_god} orb", 'The orb is delicate', 'I could not find')
      @training_abilities['Favor Orb'] = settings.favor_orb_rub_frequency
    end

    # Skill check that you can summon an elemental domain
    summoning_ranks = DRSkill.getrank('Summoning')
    @training_abilities
      .select { |ability| ability =~ /Summon .* Domain/i }
      .each do |ability|
        if summoning_ranks < 200
          DRC.message("Removing training ability '#{ability}' because you need at least 200 ranks of Summoning, and you only have #{summoning_ranks}")
          @training_abilities.delete(ability)
        end
      end

    @no_app = []

    @dont_stalk = settings.dont_stalk
    echo("  @dont_stalk: #{@dont_stalk}") if $debug_mode_ct

    @hide_type = settings.hide_type
    echo("  @hide_type: #{@hide_type}") if $debug_mode_ct

    @force_unhide = settings.force_unhide
    echo("  @force_unhide: #{@force_unhide}") if $debug_mode_ct

    @stun_weapon = settings.stun_weapon
    echo("  @stun_weapon: #{@stun_weapon}") if $debug_mode_ct

    @stun_weapon_skill = settings.stun_weapon_skill
    echo("  @stun_weapon_skill: #{@stun_weapon_skill}") if $debug_mode_ct

    @theurgy_supply_container = settings.theurgy_supply_container
    echo("  @theurgy_supply_container: #{@theurgy_supply_container}") if $debug_mode_ct

    @water_holder = settings.water_holder
    echo("  @water_holder: #{@water_holder}") if $debug_mode_ct

    @flint_lighter = settings.flint_lighter
    echo("  @flint_lighter: #{@flint_lighter}") if $debug_mode_ct

    @prayer_mat = settings.prayer_mat
    echo("  @prayer_mat: #{@prayer_mat}") if $debug_mode_ct

    @prayer_mat_container = settings.prayer_mat_container || settings.theurgy_supply_container
    echo("  @prayer_mat_container: #{@prayer_mat_container}") if $debug_mode_ct

    @dirt_stacker = settings.dirt_stacker
    echo("  @dirt_stacker: #{@dirt_stacker}") if $debug_mode_ct

    @kneel_khri = settings.kneel_khri
    echo("  @kneel_khri: #{@kneel_khri}") if $debug_mode_ct

    @forage_item = settings.forage_item
    echo("  @forage_item: #{@forage_item}") if $debug_mode_ct

    @analyze_retry_count = settings.combat_analyze_retry_count
    echo("  @analyze_retry_count: #{@analyze_retry_count}") if $debug_mode_ct

    @combat_teaching_skill = settings.combat_teaching_skill
    echo("  @combat_teaching_skill: #{@combat_teaching_skill}") if $debug_mode_ct

    @combat_training_abilities_target = settings.combat_training_abilities_target
    echo("  @combat_training_abilities_target: #{@combat_training_abilities_target}") if $debug_mode_ct

    @combat_trainer_herbs_allowhands = settings.combat_trainer_herbs_allowhands
    echo("  @combat_trainer_herbs_allowhands: #{@combat_trainer_herbs_allowhands}") if $debug_mode_ct

    @telescope_storage = settings.telescope_storage
    echo("  @telescope_storage: #{@telescope_storage}") if $debug_mode_ct

    @have_telescope = settings.have_telescope
    echo("  @have_telescope: #{@have_telescope}") if $debug_mode_ct

    @astrology_prediction_skills_survival = settings.astrology_prediction_skills['survival']
    echo("  @astrology_prediction_skills_survival: #{@astrology_prediction_skills_survival}") if $debug_mode_ct

    @gem_pouch_adjective = settings.gem_pouch_adjective
    echo("  @gem_pouch_adjective: #{@gem_pouch_adjective}") if $debug_mode_ct

    @gem_pouch_noun = settings.gem_pouch_noun
    echo("  @gem_pouch_noun: #{@gem_pouch_noun}") if $debug_mode_ct

    @almanac_skills = settings.almanac_skills
    echo("  @almanac_skills: #{@almanac_skills}") if $debug_mode_ct

    @almanac_priority_skills = settings.almanac_priority_skills
    echo("  @almanac_priority_skills #{@almanac_priority_skills}") if $debug_mode_ct

    @almanac = settings.almanac_noun
    echo("  @almanac: #{@almanac}") if $debug_mode_ct

    @barb_buffs_inner_fire_threshold = settings.barb_buffs_inner_fire_threshold
    echo("  @barb_buffs_inner_fire_threshold: #{@barb_buffs_inner_fire_threshold}") if $debug_mode_ct

    @always_use_maneuvers = settings.always_use_maneuvers
    echo("  @always_use_maneuvers: #{@always_use_maneuvers}") if $debug_mode_ct

    @tessera_mindstates = settings.tessera_mindstates
    echo("  @tessera_mindstates: #{@tessera_mindstates}") if $debug_mode_ct
  end

  def execute(game_state)
    return if game_state.danger

    case select_ability(game_state)
    when /^PercMana$/i
      moon_mage_perc(game_state)
    when /^Perc$/i
      DRC.bput('perc', 'You reach out', 'Strangely, you can sense absolutely nothing.', 'Something in the area is interfering with your ability to perceive power.') unless game_state.retreating?
    when /^Perc Health$/i
      DRC.bput('perc heal', 'You close your eyes')
    when /^Astro$/i
      astrology(game_state)
    when /^Flee$/i
      waitfor('Obvious') unless DRC.bput('flee bluff', 'You begin', 'see anything engaged with you', 'You suddenly realize') == 'see anything engaged with you'
    when /^App$/i
      appraise(game_state, '')
    when /^App Quick$/i
      appraise(game_state, 'quick')
    when /^App Careful$/i
      appraise(game_state, 'careful')
    when /^App Pouch$/i
      DRC.retreat
      DRC.bput("app my #{@gem_pouch_adjective} #{@gem_pouch_noun} quick", 'You sort', 'Appraise what', 'You cannot appraise', 'You can\'t appraise')
    when /^App Bundle$/i
      DRC.retreat
      DRC.bput("app my bundle quick", 'You scan', 'Appraise what', 'You cannot appraise', 'You can\'t appraise')
    when /^Summon (?<element>.*?) Domain$/i
      DRC.retreat
      DRC.bput("summon #{Regexp.last_match[:element]} domain", "turn your attention inward", "It isn't possible to perform", "Summon allows Warrior Mages", "Roundtime")
      waitrt?
      DRC.fix_standing
    when /^Tactics$/i
      DRC.bput($tactics_actions.sample, 'roundtime', 'There is nothing else', 'Face what', 'You must be closer', 'You must be standing', 'Strangely, you don\'t feel like fighting right now', 'flying too high for you to attack') if game_state.can_face?
    when /^Analyze$/i
      analyze(game_state, 0)
    when /^Hunt$/i
      DRC.bput('hunt', 'You take note of ', 'You find yourself unable to hunt in this area') unless game_state.retreating?
    when /^Teach$/i
      UserVars.friends.select { |c| DRRoom.pcs.include?(c) }.each do |character|
        DRC.bput("teach #{@combat_teaching_skill} to #{character}", 'You begin to', 'is already listening to you', 'is listening to someone else', 'I could not find who you were referring to', 'You have already offered', 'That person is too busy teaching', 'You are already teaching', 'You cannot teach two different classes at the same time', 'is not paying attention to you', 'You cannot listen to a teacher and teach', 'already trying to teach you something', 'trying to teach someone else')
      end
    when /^Pray$/i
      DRC.bput("pray #{@favor_god}", 'You offer a quiet prayer', 'Clasping your hands humbly', 'You hum under your breath', 'You murmur under your breath', 'You proclaim cheerfully', 'You raise your voice', 'You glance heavenward', 'You quietly go over the mantra', 'Immersing yourself in your faith', 'You bow your head', 'You murmur softly to yourself', 'You pray in susurration', 'You raise your fist', 'You lift your chin proudly', 'Feeling your blood boiling', 'You sigh and say softly', 'You open your arms', 'You glance at your surroundings', 'You mutter a prayer', 'Aligning your thoughts', 'You grumble ominously', 'You offer a prayer', 'You pray quietly', 'You throw your head back', 'With a mirthful laugh', 'Smiling joyously', 'You chant solemnly', 'You roll your eyes heavenward', 'You intone serenely', 'You narrow your eyes', 'You take a deep breath', 'You recite fervently', 'With an exultant grin', 'With renewed purpose', 'Drawing your fist to your heart', 'Glancing furtively at the comforting', 'You close your eyes and slow', 'You still your thoughts and whisper', 'You prepare to take lives', 'You raise your hands lightly', 'Bristling up against a sudden', 'You slowly square your shoulders', 'You tap the center of your forehead', 'You whisper your prayer', 'With a pat you double-check', 'Quietly touching your lips')
    when /^Scream$/i
      DRC.bput('Scream conc', 'Inhaling deeply', 'There is nothing', 'You open your mouth, then close it suddenly, looking somewhat like a fish', 'Scream at what?') unless game_state.npcs.empty?
    when /^Khri Prowess$/i
      unless game_state.npcs.empty?
        if DRCA.kneel_for_khri?(@kneel_khri, 'khri prowess')
          DRC.retreat
          fput('kneel')
        end
        DRC.bput('khri prowess', 'Remembering the mantra of mind over matter', 'You\'re already using the Prowess meditation.', 'previous use of the Prowess', 'Your body is willing', 'Your mind and body are willing')
        if DRCA.kneel_for_khri?(@kneel_khri, 'khri prowess')
          waitrt?
          DRC.fix_standing
        end
      end
    when /^Stealth$/i
      hide_action(game_state)
    when /^(Ret|Retreat) Stealth$/i
      DRC.retreat
      hide_action(game_state)
    when /^Ambush Stun$/i
      return ambush_stun(game_state)
    when /^Ambush Choke$/i
      ambush_choke(game_state)
    when /^Favor Orb$/i
      fput("rub my #{@favor_god} orb")
    when /^Charged Maneuver$/i
      # This tells the attack process to perform a combat maneuver as soon as it can.
      # Depending on cooldowns and which weapon is equipped, it may not be immediate.
      # Once a maneuver is performed then this flag gets reset to false.
      game_state.use_charged_maneuvers = true
    when /^Meraud$/i
      meraud_commune(game_state)
    when /^PrayerMat$/i
      pray_mat(game_state)
    when /^Recall$/i
      DRC.bput("recall #{game_state.npcs.first}", 'Roundtime', 'You are far too occupied') unless game_state.npcs.empty?
    when /^Barb Research Augmentation$/i
      DRC.bput('meditate research monkey', /^You clear your mind and begin to meditate/, /^What did you want to research/)
    when /^Barb Research Warding$/i
      DRC.bput('meditate research turtle', /^You clear your mind and begin to meditate/, /^What did you want to research/)
    when /^Barb Research Utility$/i
      DRC.bput('meditate research prediction', /^You clear your mind and begin to meditate/, /^What did you want to research/)
    when /^Berserk Landslide$/i
      DRCA.activate_barb_buff?('Landslide')
    when /^Berserk Avalanche$/i
      DRCA.activate_barb_buff?('Avalanche')
    when /^Collect$/i
      game_state.sheath_whirlwind_offhand
      DRC.retreat
      game_state.engage if game_state.can_engage?
      DRC.collect(@forage_item)
      waitrt?
      game_state.wield_whirlwind_offhand
      DRC.kick_pile?
    when /^Almanac$/i
      UserVars.almanac_last_use ||= Time.now - 600
      use_almanac(game_state)
    when /^Locksmithing$/i
      DRC.wait_for_script_to_complete('locksmithing', ['once'])
    when /^Smite$/i
      smite(game_state)
    when /^Herbs$/i
      if game_state.npcs.empty? || @combat_trainer_herbs_allowhands
        game_state.sheath_whirlwind_offhand
        DRC.wait_for_script_to_complete('heal-remedy', ['quick'])
        game_state.wield_whirlwind_offhand
      else
        DRC.wait_for_script_to_complete('heal-remedy', %w[quick nohands])
      end
    when /^Tessera$/i
      invest_in_tessera(game_state)
    end
    waitrt?
    false
  end

  private

  def hide_action(game_state)
    if DRC.hide?(@hide_type) && !@dont_stalk && !game_state.npcs.empty? && @hide_type == 'hide'
      stalked = DRC.bput('stalk', 'Stalk what',
                         'Try being out of sight',
                         'You move into position',
                         'already stalking',
                         'discovers you, ruining your hiding place') == ('You move into position' || 'already stalking')
      DRC.bput('stop stalk', "You're not stalking anything though", 'You stop stalking') if stalked
    end
    DRC.bput('unhide', 'You come out of hiding', 'You slip out of hiding', 'But you are not', 'You try to creep out of hiding but your injuries cause you to stumble and crash to the ground!') if (game_state.npcs.empty? || @force_unhide) && hidden
  end

  def almanac_sort_by_rate_then_rank(skills)
    skills
      .select { |skill| DRSkill.getxp(skill) < 18 }
      .min_by { |skill| [DRSkill.getxp(skill), DRSkill.getrank(skill)] }
  end

  def skill_with_lowest_mindstate
    list = []
    DRSkill.list
           .map { |skill| [skill.name, skill.exp, skill.rank] }
           .select { |element| element[1] }
           .reject { |_skill, _exp, rank| (rank.to_i == 1750 || rank.to_i == 0) }
           .reject { |skill, _exp| skill == "Mechanical Lore" }
           .select { |skill, exp| list.append [skill, exp] }
    skill = list.sort_by(&:last).first[0].sub(/(Lunar|Life|Arcane|Holy|Elemental)\s/, '')
    return skill
  end

  def use_almanac(game_state)
    return unless @almanac
    return unless Time.now - UserVars.almanac_last_use >= 600
    return if DRC.left_hand && !game_state.currently_whirlwinding

    unless @almanac_skills.empty?
      training_skill = almanac_sort_by_rate_then_rank(@almanac_priority_skills) || almanac_sort_by_rate_then_rank(@almanac_skills) || skill_with_lowest_mindstate
      echo("training skill is #{training_skill}") if $debug_mode_ct
      return unless training_skill
    end

    game_state.sheath_whirlwind_offhand if game_state.currently_whirlwinding
    DRC.retreat
    game_state.engage if game_state.can_engage?
    DRC.bput("get my #{@almanac}", 'You get', 'What were')
    if training_skill
      DRC.bput("turn #{@almanac} to #{training_skill}", 'You turn', 'You attempt to turn')
    end
    DRC.bput("study my #{@almanac}", 'You set about', 'gleaned all the insight you can', 'Study what')
    waitrt?
    DRC.bput("stow my #{@almanac}", 'You put', 'Stow what', 'You hold out')
    UserVars.almanac_last_use = Time.now
    game_state.wield_whirlwind_offhand if game_state.currently_whirlwinding
  end

  def smite(game_state)
    return if game_state.npcs.empty?
    return if game_state.brawling? || game_state.offhand? || game_state.aimed_skill?
    return if DRC.right_hand.nil?

    DRC.bput("smite", "Drawing strength from your conviction", "Drawing upon holy wrath", "You aren't close enough", "What are you trying to attack")
  end

  def meraud_commune(game_state)
    unless (DRSkill.getrank('Theurgy') >= 300 || game_state.npcs.empty?) && !game_state.aimed_skill?
      reset_ability(game_state, 'Meraud')
      return
    end
    if /meraud/i =~ DRC.bput('commune sense', 'roundtime', 'Meraud', 'Meraud\'s')
      reset_ability(game_state, 'Meraud', 60)
      game_state.blessed_room = true
      return
    end
    waitrt?
    @equipment_manager.stow_weapon(game_state.weapon_name)
    unless DRCTH.sprinkle_holy_water?(@theurgy_supply_container, @water_holder, checkname) && DRCTH.wave_incense?(@theurgy_supply_container, @flint_lighter, checkname)
      DRC.message("Holy water sprinkling, or incense waving routine failed, skipping Meraud commune")
      @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill)
      @training_abilities.delete('Meraud')
      return
    end

    pause 1
    @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill)
    DRC.bput('commune meraud', /^You struggle to commune/, 'Nothing happens.', 'you have attempted a commune too recently', 'You close your eyes and concentrate, letting your mind still and feeling your breathing grow shallow', 'the ground is already consecrated')
    pause
    waitrt?
    DRC.fix_standing
    game_state.blessed_room = true
  end

  def pray_mat(game_state)
    unless DRCI.exists?(@prayer_mat, @prayer_mat_container)
      DRC.message("*** Cannot run PrayerMat; need prayer mat in prayer_mat_container or in theurgy_supply_container")
      @training_abilities.delete('PrayerMat')
      return
    end
    waitrt?
    DRC.retreat
    @equipment_manager.stow_weapon(game_state.weapon_name)

    unless DRCI.get_item?(@prayer_mat, @prayer_mat_container)
      DRC.message("*** Cannot run PrayerMat; Cannot get prayer mat from prayer_mat_container, or from theurgy_supply_container.")
      @training_abilities.delete('PrayerMat')
      return
    end
    DRC.fix_standing
    DRC.bput("unroll #{@prayer_mat}", 'reverently lay your', 'need to be holding that first')

    DRC.bput("kneel #{@prayer_mat}", 'You humbly kneel', 'You kneel in the water')
    DRC.bput("kiss #{@prayer_mat}", 'You bend forward to kiss')

    if DRCI.get_item?("wine", @theurgy_supply_container)
      # We suppress_no_match here, and reduce the timeout because some
      # wine needs to be blessed to work. If the wine isn't blessed
      # (when it should be) there is simply no messaging of any kind on
      # pour. In those instances, it always causes a 15 second hang.
      # These settings prevent that hand.
      DRC.bput("pour wine on #{@prayer_mat}", { 'timeout' => 2, 'suppress_no_match' => true }, 'You quietly pour', 'Pour what', 'You set aside')
      DRCTH.empty_cleric_hands(@theurgy_supply_container)
    else
      DRC.message("*** Finishing PrayerMat early; Cannot get wine from theurgy_supply_container")
      @training_abilities.delete('PrayerMat')
    end
    DRC.fix_standing
    DRC.bput("roll #{@prayer_mat}", 'carefully gather up', 'need to be holding that first', 'not on the ground')
    DRCI.put_away_item?(@prayer_mat, @prayer_mat_container)
    @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill)
  end

  def ambush_stun(game_state)
    return false unless game_state.can_ambush_stun?

    dead_count = DRRoom.dead_npcs.size
    unless game_state.weapon_name == @stun_weapon && !game_state.offhand?
      @equipment_manager.stow_weapon(game_state.weapon_name)
      game_state.wield_specific_weapon(@stun_weapon, @stun_weapon_skill)
    end

    if DRC.hide?
      DRC.bput('ambush stun', 'Wouldn\'t it be better if you used a melee weapon?', 'You must be hidden or invisible to ambush', 'You aren\'t close enough to attack', 'You don\'t have enough focus', 'You don\'t think you have enough focus', 'Roundtime', 'is already out cold')
      pause
      waitrt?
    end

    unless game_state.weapon_name == @stun_weapon && !game_state.offhand?
      @equipment_manager.stow_weapon(@stun_weapon)
      game_state.wield_weapon
    end
    DRRoom.dead_npcs.size > dead_count
  end

  def ambush_choke(game_state)
    return unless game_state.can_ambush_stun?
    return unless @dirt_stacker
    return if @dirt_empty

    unless DRC.bput("push my #{@dirt_stacker}",
                    'You push', 'have any dirt', "I don't think pushing") == 'You push'
      @dirt_empty = true
      return
    end

    dirt_in_hand = true
    if DRC.hide?
      dirt_in_hand = DRC.bput(
        'ambush choke',
        'Wouldn\'t it be better if you used a melee weapon?',
        'You must be hidden or invisible to ambush',
        'You aren\'t close enough to attack',
        'You don\'t have enough focus',
        'You don\'t think you have enough focus',
        'Snipe dirt at somebody',
        'Roundtime'
      ) != 'Roundtime'
      pause
      waitrt?
    end

    return unless dirt_in_hand

    DRC.bput("put my dirt in my #{@dirt_stacker}",
             'dumping some dirt', 'What were you referring')
  end

  def analyze(game_state, fail_count)
    return unless game_state.can_engage?
    return if fail_count > @analyze_retry_count
    return if DRSkill.getxp('Tactics') >= @combat_training_abilities_target

    case DRC.bput('analyze', 'roundtime', 'Analyze what', 'Your analysis reveals a massive opening', /You reveal an? .* (?:weakness|opening)/, /Your analysis reveals an? .* (?:weakness|opening)/, 'You fail to find any holes', 'There is nothing else', 'Face what', 'You must be closer', 'You must be standing', 'Strangely, you don\'t feel like fighting right now', 'flying too high for you to attack', 'Bumbling, you slip') # unless
    when 'Analyze what'
      case DRC.bput('face next', 'There is nothing else', 'You turn', 'What are you trying', 'Face what')
      when 'There is nothing else', 'What are you trying'
        game_state.engage
      end
      analyze(game_state, fail_count)
    when 'You must be closer'
      game_state.engage
    when 'Your analysis reveals a massive opening'
      return
    when 'You fail to find any holes'
      analyze(game_state, fail_count + 1)
    when /You reveal an? .* (?:weakness|opening)/, /Your analysis reveals an? .* (?:weakness|opening)/
      analyze(game_state, fail_count)
    end
    waitrt?
  end

  def appraise(game_state, modifier)
    return if game_state.retreating?
    return if game_state.npcs.empty?

    target = (game_state.npcs - @no_app).first
    return unless target
    return if DRSkill.getrank('Appraisal') < 76
    return if DRC.bput("app #{target} #{modifier}", 'Taking stock of', 'It\'s dead', 'You can\'t determine anything about this creature.', 'I could not find', 'You cannot appraise that', 'roundtime', '^Perhaps that', 'Appraise what') != 'Perhaps that'

    @no_app << target
  end

  def moon_mage_perc(game_state)
    return if game_state.retreating?

    DRC.retreat unless DRSkill.getrank('Attunement') > 500 || DRStats.trader?
    DRC.bput('perc mana', 'You reach out')
  end

  def astrology(game_state)
    return if game_state.retreating?

    DRC.retreat
    if DRSkill.getrank('Astrology') <= 120
      DRCMM.predict('weather')
      waitrt?
      game_state.engage if game_state.can_engage?
    else
      DRC.retreat
      check_heavens(game_state)
      Flags.reset('bad-search')
    end
  end

  def check_heavens(game_state)
    @equipment_manager.stow_weapon(game_state.weapon_name)
    if @have_telescope
      case DRCMM.get_telescope(@telescope_storage)
      when 'You get a', 'You untie', 'You remove'
        determine_time
      when 'You need a free hand to pick that up.'
        return
      when 'You are already holding that.'
        determine_time
      end
    else
      determine_time
    end
    @equipment_manager.wield_weapon?(game_state.weapon_name, game_state.weapon_skill)
  end

  def determine_time
    echo 'Determining time' if $debug_mode_ct
    case DRC.bput('time', 'it is dawn', 'morning', 'midday', 'noon', 'afternoon', 'dusk', 'sunset', 'evening', 'midnight', 'night', 'almost dawn', 'approaching sunrise')
    when 'it is dawn', 'morning', 'midday', 'noon', 'afternoon', 'dusk'
      center('elanthian sun')
    when 'sunset', 'evening', 'midnight', 'night', 'almost dawn', 'approaching sunrise'
      center('heart')
    end
  end

  def center(target)
    if @have_telescope
      case DRCMM.center_telescope(target)
      when "That's a bit tough to do when you can't see the sky", 'Your search for', "You must have both hands free"
        DRCMM.store_telescope(@telescope_storage)
      else
        observe
      end
    else
      fput("observe #{target}")
      check_predict
    end
  end

  def observe
    case DRCMM.peer_telescope
    when "You believe you've learned all that you can about survival", 'Too many futures cloud your mind - you learn nothing.'
      waitrt?
      DRCMM.store_telescope(@telescope_storage)
      check_predict
    when 'The pain is too much'
      waitrt?
      DRCMM.store_telescope(@telescope_storage)
      @training_abilities.delete('Astro')
    else
      waitrt?
      DRCMM.store_telescope(@telescope_storage)
    end
  end

  def check_predict
    waitrt?
    pause 1
    return if DRSkill.getxp('Astrology') > 25

    DRCMM.align(@astrology_prediction_skills_survival)
    waitrt?
    pause 1
    execute_predict
  end

  def execute_predict
    DRC.retreat
    case DRCMM.predict('future')
    when 'You are far too occupied by present matters to immerse yourself in matters of the future'
      DRC.retreat
      waitrt?
      execute_predict
    when 'You look inside yourself'
      DRCI.stow_hands
      return
    end
  end

  def invest_in_tessera(game_state)
    return unless DRStats.trader?
    return if game_state.retreating?
    return if game_state.loaded || game_state.offhand?
    return if DRSkill.getxp('Trading') > @tessera_mindstates

    DRC.retreat
    return unless /inside your (.*)\./ =~ DRC.bput("get my tessera", 'You get a .+ tessera from inside your (.*).', 'What were you')

    container = DRC.get_noun(Regexp.last_match(1))
    game_state.starlight_values['level'] = 0 if DRC.bput('ask my tessera about invest', 'You send your') == 'You send your'
    DRC.bput("put my tessera in my #{container}", 'You put', 'What were you')
    DRCI.stow_hand('left') if DRC.left_hand.include?('tessera')
    DRCI.stow_hand('right') if DRC.right_hand.include?('tessera')
  end

  def reset_ability(game_state, ability_name, offset = 0)
    ability_info = @training_abilities.find { |name, _| name == ability_name }.last
    cooldown = ability_info.is_a?(Hash) ? ability_info[:cooldown] : ability_info.to_i
    game_state.cooldown_timers[ability_name] = Time.now - [(cooldown - offset), 0].min
  end

  def select_ability(game_state)
    ability = @training_abilities.find { |name, ability_info| check_ability(name, ability_info, game_state) }.first
    echo("Selected: #{ability}") if ability && $debug_mode_ct
    game_state.cooldown_timers[ability] = Time.now
    ability
  end

  def check_ability(name, ability_info, game_state)
    return false if ['PercMana', 'App Careful'].include?(name) && game_state.casting
    return false if (name =~ /^Berserk /) && (DRStats.mana < @barb_buffs_inner_fire_threshold)

    check = ability_info.is_a?(Hash) ? ability_info[:check] : @skill_map[name]
    check = [check].flatten
    cooldown = ability_info.is_a?(Hash) ? ability_info[:cooldown] : ability_info.to_i
    expcheck = check.nil? || check.any? { |skill_to_check| DRSkill.getxp(skill_to_check) < @combat_training_abilities_target }
    if name == 'Charged Maneuver' && @always_use_maneuvers
      expcheck = true
    end
    return expcheck unless game_state.cooldown_timers[name]

    Time.now - game_state.cooldown_timers[name] >= cooldown ? expcheck : false
  end
end

class AttackProcess
  def initialize(settings)
    echo('New AttackProcess') if $debug_mode_ct

    @fatigue_regen_action = settings.fatigue_regen_action
    echo("  @fatigue_regen_action: #{@fatigue_regen_action}") if $debug_mode_ct

    @stealth_attack_aimed_action = settings.stealth_attack_aimed_action
    echo("  @stealth_attack_aimed_action: #{@stealth_attack_aimed_action}") if $debug_mode_ct

    @hide_type = settings.hide_type
    echo("  @hide_type: #{@hide_type}") if $debug_mode_ct

    @offhand_thrown = settings.offhand_thrown
    echo("  @offhand_thrown: #{@offhand_thrown}") if $debug_mode_ct

    @ambush_location = settings.ambush_location
    echo("  @ambush_location: #{@ambush_location}") if $debug_mode_ct

    @get_actions = %w[get wield]
    echo("  @get_actions: #{@get_actions}") if $debug_mode_ct

    @rt_actions = %w[gouge attack jab feint draw lunge slice lob throw]
    echo("  @rt_actions: #{@rt_actions}") if $debug_mode_ct

    @stow_actions = %w[stow sheath put]
    echo("  @stow_actions: #{@stow_actions}") if $debug_mode_ct

    @use_overrides_for_aiming_trainables = settings.use_overrides_for_aiming_trainables
    echo(" @use_overrides_for_aiming_trainables: #{@use_overrides_for_aiming_trainables}") if $debug_mode_ct

    @firing_delay = settings.firing_delay
    echo(" @firing_delay: #{@firing_delay}") if $debug_mode_ct
    @firing_timer = Time.now
    echo("@firing_timer: #{@firing_timer}") if $debug_mode_ct
    @firing_check = 0

    # Monitor for ammo falling to ground after firing your ranged weapon.
    # Tests: https://regex101.com/r/HkIa8j/1
    # IMPORTANT: 'stone shard' must be listed before 'shard' and 'stone' in the pattern else won't match 'senci stone shard' correctly.
    ammo_pattern = "(?<ammo>arrow|bolt|stone shard|shard|rock|sphere|clump|coral|fist|holder|lump|patella|pellet|pulzone|quadrello|quarrel|quill|stone|stopper|verretto|blowgun dart|crumb|spine|mantrap spike|tiny dragon|icicle|fang|scale|grey-black spike|bacon strip|page|naga|thorn|fragment|talon|cork|button|core|pebble|geode|stub|pit|thimble|doorknob|cone|bell|hunk|piece|present|sleighbell|sprig|star|toy|spiral|tile|marble)s?"
    Flags.add('ct-ranged-ammo', "(you (?<action>fire|poach|snipe) an?|your) (?<prefix>[^\.!]*? )?#{ammo_pattern}(?<altered_poststring>.*)?(?<suffix> [^\.!]*?)?? (at|passes through)")
    Flags.add('ct-powershot-ammo', "With a loud twang, you let fly your #{ammo_pattern}!")
    Flags.add('ct-ranged-loaded', 'You reach into', 'You load', 'You carefully load', 'already loaded', 'in your hand')
    Flags.add('ct-using-repeating-crossbow', /Your repeating crossbow/i, /Your repeating arbalest/i, /Your marksman's arbalest/i, /Your assassin's crossbow/i, /Your riot crossbow/i, /You .* ammunition (chamber|store)/, /already loaded with as much ammunition as it can hold/, /You realize readying more than one/)
    Flags.add('ct-aim-failed', 'you stop aiming', 'stop concentrating on aiming')
    Flags.add('ct-ranged-ready', 'You think you have your best shot possible now.')
    Flags.add('ct-face-what', 'Face what')
    Flags.add('war-stomp-ready', 'You feel ready to perform another War Stomp'); Flags['war-stomp-ready'] = true
    Flags.add('pounce-ready', 'You think you have the strength to pounce upon prey once again.'); Flags['pounce-ready'] = true
    Flags.add('ct-maneuver-cooldown-reduced', "With expert skill you end the attack and maneuver into a better position")
    Flags.add('ct-attack-out-of-range', "You aren't close enough to attack")
  end

  def execute(game_state)
    check_face(game_state)
    if game_state.npcs.uniq.length == 1 && !game_state.stabbable?(game_state.npcs.uniq.first)
      game_state.no_stab_current_mob = true
    elsif game_state.mob_died && game_state.no_stab_current_mob
      game_state.no_stab_current_mob = false
    end

    if game_state.dancing? || game_state.weapon_skill == 'Targeted Magic' || !game_state.is_offense_allowed?
      if game_state.finish_killing?
        echo('AttackProcess::clean_up') if $debug_mode_ct
        game_state.next_clean_up_step
      else
        dance(game_state)
      end
      return false
    end

    if game_state.fatigue_low?
      fput(@fatigue_regen_action)
      return false
    end

    charged_maneuver = check_charged_maneuver(game_state)

    game_state.reset_barb_whirlwind_flags_if_needed

    if game_state.thrown_skill?
      game_state.loaded = false
      @firing_check = 0
      attack_thrown(game_state)
    elsif game_state.aimed_skill?
      attack_aimed(charged_maneuver, game_state)
    else
      game_state.loaded = false
      @firing_check = 0
      attack_melee(charged_maneuver, game_state)
    end
    false
  end

  private

  def check_face(game_state)
    return unless Flags['ct-face-what']

    game_state.engage
    Flags.reset('ct-face-what')
  end

  def attack_melee(charged_maneuver, game_state)
    return unless game_state.can_engage?

    waitrt?

    maneuver_success = false
    if charged_maneuver
      # If you're prioritizing doublestrike but only wielding one melee weapon
      # then temporarily wield a second weapon offhand to perform the maneuver.
      offhand_weapon_name = nil
      if charged_maneuver.casecmp?('doublestrike') && DRC.left_hand.nil?
        skill = game_state.determine_doublestrike_skill
        if skill
          echo "attack_melee::maneuver_doublestrike:skill: #{skill}" if $debug_mode_ct
          offhand_weapon_name = game_state.wield_offhand_weapon(skill)
        end
      end

      maneuver_success = use_charged_maneuver(charged_maneuver, game_state)

      game_state.sheath_offhand_weapon(skill) if offhand_weapon_name
    end

    # If we didn't try a maneuver, or we did but it wasn't successful, then fallback to normal attack.
    unless maneuver_success
      if game_state.backstab? || game_state.use_stealth_attack? || game_state.ambush? || game_state.ambush_stun_training?
        DRC.hide?(@hide_type)
      end

      verb = game_state.melee_attack_verb

      command = game_state.offhand? ? "#{verb} left" : verb

      if (game_state.backstab? || game_state.ambush? || game_state.ambush_stun_training?) && hiding?
        if (game_state.backstab? && game_state.no_stab_current_mob) || (game_state.ambush? && !game_state.backstab?)
          command += " #{@ambush_location}"
        elsif (game_state.ambush_stun_training?)
          command = command.sub(verb, 'ambush stun')
        else
          command = command.sub(verb, 'backstab')
        end
      end

      DRC.bput(command, 'Wouldn\'t it be better if you used a melee weapon?', 'You turn to face', 'Face What?', 'Roundtime', "You aren't close enough to attack", 'It would help if you were closer', 'There is nothing else to face!', 'You must be hidden', 'flying too high for you to attack', 'You can\'t coldcock', 'while it is flying', 'Novel idea, but it\'s a ghost!', 'Bumbling, you slip', 'You can not slam with that', 'You must be hidden or invisible to ambush', 'You don\'t have enough focus', 'You don\'t think you have enough focus', 'is already out cold')
    end

    pause
    waitrt?

    if reget(5, 'flying too high for you to attack')
      case DRC.bput('face next', 'There is nothing', 'You turn to face', 'Face what')
      when 'There is nothing'
        pause 5
      end
    end

    if reget(5, 'You can\'t backstab that')
      if game_state.npcs.uniq.length == 1
        game_state.unstabbable(game_state.npcs.first)
      else
        game_state.no_stab_current_mob = true
      end
    end

    if reget(5, 'You aren\'t close enough to attack', 'It would help if you were closer')
      game_state.engage
    else
      game_state.action_taken
    end
    return unless reget(5, 'You need two hands')

    fput('stow left') if DRC.left_hand && DRC.left_hand !~ /\b#{game_state.weapon_name}/i
    fput('stow right') if DRC.right_hand && DRC.right_hand !~ /\b#{game_state.weapon_name}/i
  end

  def attack_thrown(game_state)
    attack_action = game_state.thrown_attack_verb
    attack_action += ' left' if game_state.offhand?
    DRC.bput(attack_action, 'roundtime', 'What are you trying to')
    waitrt?
    return game_state.action_taken if attack_action.include?('whip')

    if game_state.weapon_name == 'blades'
      until /(Stow what|You put your)/ =~ DRC.bput('stow blade', 'Stow what', 'You pick up .*blade', 'You put your')
      end
    end

    retrieve_action = game_state.thrown_retrieve_verb

    bonded_invoke_success = [ # standard and custom invoke messages
      /reuniting you with your lost belonging/,
      /In its place, you are left with your/,
      /returning .* to your/,
      /depositing .* back to the rightful owner/,
      /Your .* appears within reach/,
      /you are reunited with your/,
      /You catch/,
      /A tiny ripplegate gurgles into being near your/
    ]

    case DRC.bput(retrieve_action,
                  /^You are already holding/,
                  /^You pick up/,
                  /^You get/,
                  /^What were you/,
                  /^You don't have any bonds to invoke/,
                  *bonded_invoke_success)
    when 'What were you'
      # Workaround for a game bug when you lob an unblessed weapon at a noncorporeal mob
      # The weapon lands on the ground, not in the 'at feet' slot, and 'my' will not work
      DRC.bput("get #{game_state.weapon_name}", 'You pick up', 'You get')
    when *bonded_invoke_success
      DRC.bput('swap', 'You move', 'You have nothing') if game_state.offhand?
    end

    game_state.action_taken
  end

  def shoot_aimed(command, game_state)
    echo("Time now: #{Time.now}") if $debug_mode_ct
    echo("@firing_timer: #{@firing_timer}") if $debug_mode_ct
    echo("@firing_delay: #{@firing_delay}") if $debug_mode_ct

    # Occasionally the game borks and the phrases like "Face what?"
    # appear before the text that you fired your weapon.
    # So, we use a flag to see if the message ever appears
    # rather than relying on the first message returned from bput.
    Flags.reset('ct-ranged-ammo')

    result = DRC.bput(command, /you (fire|poach|snipe)/i, /isn't loaded/i, /There is nothing/i, /But your/i, /I could not find/i, /with no effect and falls (to the ground|to your feet)/i, /Face what/i, /How can you (poach|snipe)/i, /you don't feel like fighting right now/i, /That weapon must be in your right hand to fire/i, /But you don't have a ranged weapon in your hand to fire with/i)
    waitrt?

    case result
    when /How can you (poach|snipe)/i
      shoot_aimed('shoot', game_state)
    when /That weapon must be in your right hand to fire|But you don't have a ranged weapon in your hand to fire with/i
      # Explicitly say 'swap right' because if you're holding a swappable weapon (e.g. riste)
      # then just 'swap' will try to switch the weapon mode, not move it to other hand.
      if fput('swap right') =~ /You (swap|move)/i
        shoot_aimed(command, game_state)
      end
    when /you don't feel like fighting right now/i
      pause 1
      shoot_aimed(command, game_state)
    when /with no effect and falls (to the ground|to your feet)/i
      # If you fired without Bless at an incorporeal undead then it'll have no effect.
      # However, that's still considered an action taken, just you missed.
      game_state.action_taken
    when /you (fire|poach|snipe)/i
      # Successful fire, increment action_taken
      game_state.action_taken
    end

    # If detected that you shot, then stow any non-lodged ammo.
    if Flags['ct-ranged-ammo']
      ammo = Flags['ct-ranged-ammo'][:ammo].to_s
      @firing_check = 0
      quantity = game_state.dual_load? ? 2 : 1
      stow_ammo(ammo, quantity)
      Flags.reset('ct-ranged-ammo')
    end
  end

  def attack_aimed(charged_maneuver, game_state)
    # This little conditional appears to have been the source of the aim bug, at least in part.
    # The idea behind this as it is written was to reaquire a new target after a mob dies, with CT assuming you
    # did the killing. The game_state checks were to ignore dead things that necros were playing with.
    # However, in practice, when hunting with someone else, things get dead, things that have nothing
    # to do with you aiming, and sometimes they persist for longer than is strictly necessary. CT would continue
    # quietly returning to this little conditional in a vain attempt to see if you were ready to fire.
    # CT hits this first which would tell CT, falsly, that your ranged weapon was unloaded.
    # So CT dutifully attempted to reload, reaim, and then goes to check, again, if you're ready to fire. This
    # loop only broke if both 1. the bodies departed and 2. CT had reason to reassess game_state.mob_died. Until
    # both occurred, we looped. With this excluded, when a mob dies while we are aiming, we carry on with our aim_fillers
    # until the timer expires, then shoot. If our target died, it's a snap shot at the next available mob. Otherwise, it's
    # just business as usual, a fully aimed shot at our target.
    # if game_state.mob_died && !(game_state.casting_consume || game_state.prepare_consume)
    #   game_state.loaded = false
    #   @firing_check = 0
    # end

    if Flags['ct-aim-failed']
      game_state.loaded = false
      @firing_check = 0
      Flags.reset('ct-aim-failed')
    end

    if game_state.loaded && ((Time.now >= @firing_timer) || Flags['ct-ranged-ready'])
      echo("Current Time > @firing_timer: #{Time.now >= @firing_timer}") if $debug_mode_ct
      echo("Current Time < @firing_timer: #{Time.now <= @firing_timer}") if $debug_mode_ct
      echo("Flag check: ct-ranged-ready: #{Flags['ct-ranged-ready']}") if $debug_mode_ct
      command = if game_state.use_stealth_ranged? && DRC.hide?(@hide_type)
                  @stealth_attack_aimed_action
                elsif game_state.use_stealth_attack? && DRC.hide?(@hide_type)
                  @stealth_attack_aimed_action
                else
                  'shoot'
                end
      shoot_aimed(command, game_state)
      game_state.clear_aim_queue
      game_state.loaded = false
      @firing_check = 0
      echo("@firing_check reset normal fire: #{@firing_check}") if $debug_mode_ct
      waitrt?
    elsif game_state.loaded && !game_state.aiming_trainables.empty?
      skill = game_state.determine_aiming_skill
      echo "attack_aimed::aiming_trainables:skill: #{skill}" if $debug_mode_ct
      return unless skill

      weapon_name = game_state.wield_offhand_weapon(skill)

      actions = if skill.eql?('Tactics')
                  $tactics_actions
                elsif @use_overrides_for_aiming_trainables
                  atk = game_state.attack_override(skill)
                  ["#{atk} left", "#{atk} left", "#{atk} left"]
                elsif skill.include?('Thrown')
                  ['lob left', 'lob left', 'lob left']
                elsif skill.eql?('Brawling')
                  ['gouge left', 'gouge left', 'gouge left']
                else
                  ['jab left', 'jab left', 'jab left']
                end

      actions.each do |action|
        break unless execute_aiming_action?(action, game_state)
        next if atk.include?('whip')
        next unless skill.include?('Thrown')

        retrieve_action = "get my #{weapon_name}"
        retrieve_action = 'invoke' if action.include?('hurl')
        case DRC.bput(retrieve_action, 'You are already holding', 'You pick up', 'You get', 'You catch',\
                      'What were you', "You don't have any bonds to invoke")
        when 'What were you'
          # Workaround for a game bug when you lob an unblessed weapon at a noncorporeal mob
          # The weapon lands on the ground, not in the 'at feet' slot, and 'my' will not work
          DRC.bput("get #{weapon_name}", 'You pick up', 'You get', 'What were')
        end
      end

      game_state.sheath_offhand_weapon(skill)
    elsif game_state.loaded && (Time.now <= @firing_timer)
      actions = game_state.next_aim_action.split(';')
      actions.each do |action|
        first_word = action.split(' ')[0].downcase
        matches = [/^You /]
        matches = ['You get', 'You draw out', 'You draw your', 'You pick up', "You're already holding that", 'You are already holding that'] if @get_actions.include?(first_word)
        matches = ['Roundtime', "You aren't close enough to attack", 'What are you', 'There is nothing'] if @rt_actions.include?(first_word)
        matches = ['You put', 'You sheathe', 'Sheathing a', 'Sheathing some'] if @stow_actions.include?(first_word)
        DRC.bput(action.strip, matches)
        pause 0.25
        waitrt?
      end
    else
      load_weapon_success = [
        /You reach into/,
        /You load/,
        /You carefully load/,
        /already loaded/,
        /in your hand/,
        /A rapid series of clicks/,
        /into firing position/,
        /You realize readying/,
        /As you draw back the string/
      ]

      load_weapon_failure = [
        /As you try to reach/,
        /You don't have the proper ammunition/,
        /You don't have enough .* to load two at once/,
        /What weapon are you trying to load/,
        /You can't do that .* because you aren't trained in the ways of magic/, # energy bow that requires mana
        /you probably need to be more specific on what you are loading/, # energy bows require `load <weapon>` syntax, set `dual_load: false`
        /Such a feat would be impossible without the winds to guide/, # unable to dual load without ability
        /but are unable to draw upon its majesty/, # unable to dual load without ability
        /without steadier hands/, # unable to dual load without ability
        /You can not load .* in your left hand/,
        /You need to hold the .* in your right hand to load it/,
        /You attempt to ready your/,
        /Push what?/,
        /It's best to hold/,
        /pushing that would have any effect/
      ]

      dual_load = game_state.dual_load?

      if dual_load
        # Occasionally, there may be no game output after loading.
        # To be on the safe side, we do two attempts to get output.
        Flags.reset('ct-ranged-loaded')
        load_weapon_result = DRC.bput('load arrows', { 'timeout' => 1, 'suppress_no_match' => true }, *load_weapon_success, *load_weapon_failure)
        load_weapon_result = DRC.bput('load arrows', *load_weapon_success, *load_weapon_failure) unless Flags['ct-ranged-loaded']
        case load_weapon_result
        when *load_weapon_failure
          dual_load = false # fallback to single load
          game_state.loaded = false
          @firing_check = 0
        else
          game_state.loaded = true
        end
      end

      unless dual_load
        # Occasionally, there may be no game output after loading.
        # To be on the safe side, we do two attempts to get output.
        Flags.reset('ct-ranged-loaded')
        Flags.reset('ct-using-repeating-crossbow')

        load_weapon_result = DRC.bput("load my #{game_state.weapon_name}", { 'timeout' => 1, 'suppress_no_match' => true }, *load_weapon_success, *load_weapon_failure)
        load_weapon_result = DRC.bput("load my #{game_state.weapon_name}", *load_weapon_success, *load_weapon_failure) unless Flags['ct-ranged-loaded']
        waitrt?

        case load_weapon_result
        when *load_weapon_failure
          abort_attack_aimed(game_state)
          return
        when *load_weapon_success
          # Check if loading a repeating crossbow because we need to then push ammo into the chamber
          if Flags['ct-using-repeating-crossbow']
            case DRC.bput("push my #{game_state.weapon_name}", *load_weapon_success, *load_weapon_failure)
            when *load_weapon_failure
              abort_attack_aimed(game_state)
              return
            end
          end
          game_state.loaded = true
        end
      end

      waitrt?

      if game_state.loaded
        # If we successfully perform a maneuver then count that as our action.
        # Otherwise begin aiming for normal shot.
        if charged_maneuver && use_charged_maneuver(charged_maneuver, game_state)
          game_state.action_taken
        else
          game_state.set_aim_queue
          aim(game_state)
          Flags.reset('ct-ranged-ready')
        end
      end
    end
  end

  def abort_attack_aimed(game_state)
    DRC.message("Unable to load #{game_state.weapon_name}, you may be out of ammunition, dancing until can switch to next weapon")
    game_state.loaded = false
    @firing_check = 0
    game_state.clear_aim_queue
    dance(game_state)
    # Increment action count so that the script
    # will eventually progress to next skill to train.
    game_state.action_taken(99)
  end

  def execute_aiming_action?(action, game_state)
    case DRC.bput(action, 'Roundtime', 'close enough', 'What are you', 'There is nothing', 'must be closer', 'Bumbling, you slip')
    when 'close enough', 'must be closer'
      return false unless game_state.can_engage?

      game_state.engage
    when 'What are you', 'There is nothing'
      return false unless action.include?('whip')

      fput('face next')
      return false
    end
    true
  end

  def check_firing_time
    @firing_check += 1
    echo("@firing_check: #{@firing_check}") if $debug_mode_ct
    echo("@firing_timer: #{@firing_timer}") if $debug_mode_ct
    @firing_timer = Time.now + @firing_delay if @firing_check == 1
    @firing_timer -= 1
    echo("Check after test - @firing_timer: #{@firing_timer}") if $debug_mode_ct
  end

  def aim(game_state)
    aim_success_messages = [
      /You are already/,
      /You begin to target/,
      /You shift your target/,
      /In one electrifying moment/, # Syamelyo Kuniyo spell effect
      /In one frozen moment/ # Syamelyo Kuniyo spell effect
    ]

    unloaded_messages = [
      /isn't loaded/,
      /You don't have a ranged weapon to aim with/
    ]

    no_enemy_messages = [
      /There is nothing else/,
      /Face what/
    ]

    wait_and_retry_messages = [
      /Strangely, you don't feel like fighting right now/,
      /You don't seem to be able to move to do that/
    ]

    case DRC.bput("aim", *aim_success_messages, *unloaded_messages, *no_enemy_messages, *wait_and_retry_messages)
    when *aim_success_messages
      game_state.loaded = true
      check_firing_time
    when *unloaded_messages
      game_state.loaded = false
      @firing_check = 0
    when *no_enemy_messages
      game_state.clear_aim_queue
    when *wait_and_retry_messages
      pause 1
      aim(game_state)
    else
      game_state.loaded = false
      @firing_check = 0
    end
  end

  def dance(game_state)
    if game_state.can_engage?
      game_state.set_dance_queue
      case DRC.bput(game_state.next_dance_action, 'You must be closer', 'There is nothing else', 'What are you trying', /.*/)
      when 'You must be closer', 'There is nothing else', 'What are you trying'
        game_state.engage
      end
    else
      pause 1
    end
  end

  def check_charged_maneuver(game_state)
    # Determines the next maneuver to do that's not on cooldown
    maneuver = game_state.determine_charged_maneuver
    return nil unless maneuver

    echo "***Ready to use charged maneuver: #{maneuver}***" if $debug_mode_ct
    maneuver
  end

  def use_charged_maneuver(action, game_state)
    return false unless action

    Flags.reset('ct-powershot-ammo')
    Flags.reset('ct-maneuver-cooldown-reduced')
    Flags.reset('ct-attack-out-of-range')

    maneuver_success_messages = [
      /^You raise your weapons before you and prepare to strike/,
      /^Taking a full step back/,
      /^You take a step back/,
      /^You lower your shoulders/,
      /^You angle to the side/,
      /^You square up your feet/,
      /^You crouch down/,
      /^You step to the side/,
      /^Swiftly, you attempt to/,
      /^You brace your .* to increase the power of the next shot/
    ]

    maneuver_failure_messages = [
      # Your ranged weapon is unloaded
      /^You prepare the shot, but stop when you realize/,
      # Maneuver is still on cooldown
      /^You must rest a bit longer before attempting that maneuver again/,
      # Trying to suplex but you're not grappled
      /^You must first be grappled with an enemy/,
      # Trying to doublestrike with a weapon that requires two hands (e.g. quarterstaff or long polearm)
      /^You must free up your left hand first/,
      # Trying to doublestrike without wielding two, one-handed melee weapons
      /^This works best when you use a suitable weapon/,
      /^This works best when you are dual wielding suitable weapons/,
      # Maneuver requires a weapon but you're not wielding any
      /^With your fist? That might hurt/,
      # You can't aim before powershot maneuver
      /^You are unable to focus on performing a maneuver while aiming at an enemy/
    ]

    attempt = DRC.bput("maneuver #{action}", *maneuver_success_messages, *maneuver_failure_messages)

    waitrt?

    if Flags['ct-attack-out-of-range']
      game_state.engage
      return use_charged_maneuver(action, game_state)
    end

    case attempt
    when /^You must rest a bit longer before attempting that maneuver again/
      # Barbarians who reduced the cooldown on this maneuver last time
      # could have reduced it to anywhere between 45-55 seconds.
      # We optimistically assumed 45 seconds. If that wasn't enough then
      # we'll wait another 15 seconds and retry.
      game_state.cooldown_timers[action] += 15
      return false
    when *maneuver_failure_messages
      return false
    when *maneuver_success_messages
      # Only react to the powershot flag if we just did a powershot manuever.
      # This is an added protection in case the flag was tripped by an unrelated
      # action like throwing a weapon. This way we don't try to "stow my throwing hammer"
      # after a 'maneuver cleave' action, for example.
      if Flags['ct-powershot-ammo'] && action == 'powershot'
        # When the flag matches game output then the value of the flag
        # is the regular expression matches. This is how we know the ammo to stow.
        stow_ammo(Flags['ct-powershot-ammo'][:ammo])
        Flags.reset('ct-powershot-ammo')
        # When dual loading, powershot only fires one of the arrows.
        # So let's take advantage of the remaining arrow that's still loaded.
        if game_state.dual_load?
          shoot_aimed('shoot', game_state)
        end
        game_state.loaded = false
        @firing_check = 0
        echo("@firing_check reset on maneuver fire: #{@firing_check}") if $debug_mode_ct
      end

      # Woot! Barbarian reduced their maneuver cooldown so
      # they can retry this specific ability sooner rather than later.
      if Flags['ct-maneuver-cooldown-reduced'] && DRStats.barbarian?
        # The new cooldown is somewhere between 45-55 seconds.
        # We'll be optimistic and hope we got the shorter cooldown.
        # If we didn't then next time around we'll add a few more seconds
        # to finish out a 60 second cooldown.
        game_state.cooldown_timers[action] = Time.now + 45
        Flags.reset('ct-maneuver-cooldown-reduced')
      else
        # No special favors for you. Full cooldown!
        game_state.cooldown_timers[action] = Time.now + 90
      end

      # Toggle off using charged maneuvers until
      # training ability process toggles it back for training
      game_state.use_charged_maneuvers = false

      return true
    end
  end

  def stow_ammo(ammo = nil, quantity = 1)
    echo "Stowing ammo: #{ammo}, #{quantity}" if $debug_mode_ct
    return unless ammo
    return unless quantity > 0

    # The ammo may be 1, 2, or 3 words depending on the item (e.g. rock, crossbow bolt, matte indurium sphere)
    # The majority of the time, if not always, the words to reference the item are the first and last (e.g. matte sphere).
    ammo_parts = ammo.strip.split(' ')
    ammo = [ammo_parts.first, ammo_parts.last].compact.uniq.join(' ')
    case DRC.bput("stow my #{ammo}", 'You pick up', 'You put your', 'Stow what', 'needs to be tended to be removed', 'As you reach for a glowing')
    when 'You pick up', 'You put your'
      stow_ammo(ammo, quantity - 1)
    when 'Stow what'
      # Bug fix for typo with burgled arrows.
      # Messaging will say "you fire a blunt-tipped arrows" (note the trailing 's')
      # when you actually only shot a singular arrow and the item itself
      # only responds to 'stow arrow' (no 's').
      stow_ammo(ammo.slice(0..-2), quantity) if ammo.end_with?('s')
    end
  end
end

class CombatTrainer
  attr_reader :running

  def stop
    echo 'Received stop signal' if $debug_mode_ct
    @stop = true
  end

  def set_args
    arg_definitions = [
      [
        { name: 'debug', regex: /debug/i, optional: true },
        { name: 'construct', regex: /construct/i, optional: true, description: 'Construct setting to override empath no attack settings.' },
        { name: 'undead', regex: /undead/i, optional: true, description: 'Allows hunting of undead by empaths when absolution is up.' },
        { name: 'innocence', regex: /innocence/i, optional: true, description: 'Allows an empath using Innocence to avoid taking actions that end the spell.' },
        { name: 'dance', display: 'd#', regex: /d\d+/i, optional: true, description: 'Dance threshold, d2 would keep two enemies alive.' },
        { name: 'retreat', display: 'r#', regex: /r\d+/i, optional: true, description: 'Retreat threshold, r3 would stay at range with three or more enemies' }
      ]
    ]

    args = parse_args(arg_definitions, true)

    settings = get_settings(args.flex)

    settings.construct = args.construct
    settings.undead = args.undead
    settings.innocence = args.innocence

    settings.debug_mode = args.debug
    set_dance(args.dance, settings)
    set_retreat(args.retreat, settings)

    settings
  end

  def initialize
    settings = set_args
    @equipment_manager = EquipmentManager.new(settings)
    @equipment_manager.empty_hands
    setup(settings)
    settings.storage_containers.each { |container| fput("open my #{container}") }
    worngear = settings.combat_trainer_gear_set || "standard"
    @equipment_manager.wear_equipment_set?(worngear) if settings.cycle_armors_regalia.nil? || DRCA.parse_regalia.empty?
  end

  def set_dance(message, settings)
    return unless message

    message =~ /d(\d+)/
    settings.dance_threshold = Regexp.last_match(1).to_i
  end

  def set_retreat(message, settings)
    return unless message

    message =~ /r(\d+)/
    settings.retreat_threshold = Regexp.last_match(1).to_i
  end

  def setup(settings)
    Flags.add('ct-spellcast', '^Your formation of a targeting pattern around .+ has completed\.', 'Your target pattern has finished forming around the area', '^You feel fully prepared to cast your spell\.', '^Your spell pattern snaps into shape with little preparation!')

    Flags.add('last-stance', 'Setting your Evasion stance to \d+%, your Parry stance to \d+%, and your Shield stance to \d+%.  You have \d+ stance points left')

    DRC.bput("stance set #{settings.default_stance}", 'Setting your')

    @stop = false
    @running = true
    $debug_mode_ct = UserVars.combat_trainer_debug || settings.debug_mode
    @game_state = GameState.new(settings, @equipment_manager)
    @safety_process = SafetyProcess.new(settings, @equipment_manager)
    @combat_processes = make_processes(settings)
  end

  def make_processes(settings)
    [
      SetupProcess.new(settings, @equipment_manager),
      SpellProcess.new(settings, @equipment_manager),
      PetProcess.new(settings),
      AbilityProcess.new(settings),
      LootProcess.new(settings, @equipment_manager),
      ManipulateProcess.new(settings),
      TrainerProcess.new(settings, @equipment_manager),
      AttackProcess.new(settings)
    ]
  end

  def get_process(process)
    case process
    when 'setup' then @combat_processes[0]
    when 'spell' then @combat_processes[1]
    when 'pet' then @combat_processes[2]
    when 'ability' then @combat_processes[3]
    when 'loot' then @combat_processes[4]
    when 'manipulate' then @combat_processes[5]
    when 'trainer' then @combat_processes[6]
    when 'attack' then @combat_processes[7]
    end
  end

  def start_combat
    @equipment_manager.empty_hands
    loop do
      @combat_processes.each do |process|
        @safety_process.execute(@game_state)
        break if process.execute(@game_state)
      end
      pause 0.1
      if @game_state.done_cleaning_up?
        echo('CombatTrainer::clean_up') if $debug_mode_ct
        @running = false
        stop_script('tendme') if Script.running?('tendme')
        break
      end
      next unless @stop && !@game_state.cleaning_up?

      @game_state.next_clean_up_step
      @game_state.stop_weak_attacks
      @game_state.stop_analyze_combo
    end
  end
end

class GameState
  $martial_skills = ['Brawling']
  $edged_skills = ['Small Edged', 'Large Edged', 'Twohanded Edged']
  $blunt_skills = ['Small Blunt', 'Large Blunt', 'Twohanded Blunt']
  $staff_skills = ['Staves']
  $polearm_skills = ['Polearms']
  $melee_skills = $edged_skills + $blunt_skills + $staff_skills + $polearm_skills + ['Melee Mastery']
  $thrown_skills = ['Heavy Thrown', 'Light Thrown']
  $twohanded_skills = ['Twohanded Edged', 'Twohanded Blunt']
  $aim_skills = ['Bow', 'Slings', 'Crossbow']
  $ranged_skills = $thrown_skills + $aim_skills + ['Missile Mastery']
  $non_dance_skills = $ranged_skills + ['Brawling', 'Offhand Weapon']
  $tactics_actions = ['bob', 'weave', 'circle']

  attr_accessor :action_count, :aim_queue, :analyze_combo_array, :blessed_room, :cast_timer,
                :casting, :casting_cfb, :casting_cfw, :casting_nr, :casting_consume, :casting_cyclic, :casting_moonblade,
                :casting_regalia, :casting_sorcery, :casting_weapon_buff, :charges, :charges_total,
                :clean_up_step, :constructs, :cooldown_timers, :current_weapon_skill,
                :currently_whirlwinding, :dance_queue, :dancing, :danger, :hide_on_cast,
                :last_regalia_type, :last_weapon_skill, :loaded, :mob_died, :need_bundle,
                :no_loot, :no_skins, :no_stab_current_mob, :no_stab_mobs, :parrying, :prepare_cfb, :prepare_cfw, :prepare_nr,
                :prepare_consume, :regalia_cancel, :reset_stance, :retreating, :starlight_values,
                :swap_regalia_type, :target_weapon_skill, :use_charged_maneuvers,
                :whirlwind_trainables, :wounds

  attr_reader :aim_fillers, :aim_fillers_stealth, :ambush, :backstab, :balance_regen_threshold,
              :cambrinth, :cambrinth_cap, :charged_maneuvers, :dance_actions, :dance_actions_stealth,
              :dance_skill, :dance_threshold, :dedicated_camb_use, :dual_load, :fatigue_regen_threshold,
              :ignored_npcs, :retreat_threshold, :stances, :stored_cambrinth, :summoned_weapons_element,
              :summoned_weapons_ingot, :target_action_count, :target_increment, :use_analyze_combos,
              :use_stealth_attacks, :use_weak_attacks, :weapons_to_train

  def initialize(settings, equipment_manager)
    @equipment_manager = equipment_manager
    echo('New GameState') if $debug_mode_ct
    # public
    @mob_died = false
    @last_weapon_skill = nil
    @danger = false
    @parrying = false
    @casting = false
    @need_bundle = true
    @cooldown_timers = {}
    @no_stab_current_mob = false
    @loaded = false
    @cast_timer = nil
    @casting_moonblade = false
    @casting_sorcery = false
    @casting_cyclic = false
    @hide_on_cast = false
    @casting_regalia = false
    @regalia_cancel = false
    @last_regalia_type = nil
    @swap_regalia_type = nil
    @starlight_values = nil
    @casting_weapon_buff = false
    @casting_consume = false
    @prepare_consume = false
    @prepare_nr = false
    @casting_nr = false
    @prepare_cfb = false
    @casting_cfb = false
    @prepare_cfw = false
    @casting_cfw = false
    @use_charged_maneuvers = false
    @wounds = {}
    @blessed_room = false
    @charges_total = nil

    # private
    @clean_up_step = nil
    @target_weapon_skill = -1
    @no_skins = []
    @no_dissect = []
    @constructs = []
    @no_stab_mobs = []
    @no_loot = []
    @dancing = false
    @retreating = false
    @action_count = 0
    @charges = nil
    @aim_queue = []
    @dance_queue = []
    @analyze_combo_array = []
    @currently_whirlwinding = false
    @avtalia_cambrinth = {}
    @barb_analyzes = { 'accuracy' => 50, 'damage' => 125, 'balance' => 600, 'flame' => 0 }

    @left_hand_free = settings.left_hand_free
    echo("  @left_hand_free: #{@left_hand_free}") if $debug_mode_ct

    @dynamic_dance_skill = settings.dynamic_dance_skill
    echo("  @dynamic_dance_skill: #{@dynamic_dance_skill}") if $debug_mode_ct

    @dance_skill = settings.dance_skill
    echo("  @dance_skill: #{@dance_skill}") if $debug_mode_ct

    @target_action_count = settings.combat_trainer_action_count
    echo("  @target_action_count: #{@target_action_count}") if $debug_mode_ct

    @dance_threshold = settings.dance_threshold.to_i
    echo("  @dance_threshold: #{@dance_threshold}") if $debug_mode_ct

    @retreat_threshold = settings.retreat_threshold
    echo("  @retreat_threshold: #{@retreat_threshold}") if $debug_mode_ct

    @damaris_weapon_sets = settings.damaris_weapon_sets
    echo("  @damaris_weapon_sets: #{@damaris_weapon_sets}") if $debug_mode_ct

    # Identify the current state the damaris weapons are turned to.
    echo "Identifying the current state of your Damaris weapons..." if @damaris_weapon_sets
    @damaris_weapon_states = Hash.new
    @damaris_weapon_sets.each do |group, weapons|
      weapon = weapons.find do |each_weapon|
        item = @equipment_manager.item_by_desc(each_weapon)
        DRCI.exists?(item.short_name, item.container)
      end
      @damaris_weapon_states[group] = weapon
    end
    echo("  @damaris_weapon_states: #{@damaris_weapon_states}") if $debug_mode_ct

    @summoned_weapons = settings.summoned_weapons
    echo("  @summoned_weapons: #{@summoned_weapons}") if $debug_mode_ct

    @target_increment = settings.combat_trainer_target_increment
    echo("  @target_increment: #{@target_increment}") if $debug_mode_ct

    @strict_weapon_stance = settings.strict_weapon_stance
    echo("  @strict_weapon_stance: #{@strict_weapon_stance}") if $debug_mode_ct

    @stances = settings.stances
    echo("  @stances: #{@stances}") if $debug_mode_ct

    @stances.keys do |key|
      settings = @stances[key]
      unless (settings & %w[evasion parry shield]).empty?
        DRC.message 'Please update to the latest version of stance: settings!'
        settings.map! { |x| { 'parry' => 'Parry Ability', 'shield' => 'Shield Usage', 'evasion' => 'Evasion' }[x] }
      end
      (['Evasion', 'Shield Usage', 'Parry Ability'] - settings).each { |x| settings << x }
      unless settings.size == 3
        DRC.message "Error: stance settings #{settings} include invalid stance."
        exit
      end
    end
    echo("Modified stances: #{@stances}") if $debug_mode_ct

    @weapons_to_train = settings.weapon_training
    echo("  @weapons_to_train: #{@weapons_to_train}") if $debug_mode_ct
    if is_brawling_ranged?
      echo('  Augmenting ranged groups due to brawling with blowgun') if $debug_mode_ct
      $aim_skills << 'Brawling'
      $ranged_skills << 'Brawling'
    end

    @use_stealth_attacks = settings.use_stealth_attacks
    echo("  @use_stealth_attacks: #{@use_stealth_attacks}") if $debug_mode_ct

    @use_stealth_ranged = settings.use_stealth_ranged
    echo("  @use_stealth_ranged: #{@use_stealth_ranged}") if $debug_mode_ct

    @ambush = settings.ambush
    echo("  @ambush: #{@ambush}") if $debug_mode_ct

    @backstab = settings.backstab
    @backstab_past_mindlock = settings.backstab_past_mindlock
    echo("  @backstab: #{@backstab}") if $debug_mode_ct

    @ambush_stun_weapons = settings.ambush_stun_weapons

    @charged_maneuvers = settings.charged_maneuvers
    echo("  @charged_maneuvers: #{@charged_maneuvers}") if $debug_mode_ct
    # Initialize the maneuver timers. This avoids a later issue where a number
    # is assigned to the cooldown rather than a Time and then crash with error
    # when we compare a Time object with a number wanting to know if ability is off cooldown.
    @charged_maneuvers.each_value { |maneuver| @cooldown_timers[maneuver.downcase] = Time.now }

    @prioritize_maneuver_doublestrike = settings.prioritize_maneuver_doublestrike
    echo("  @prioritize_maneuver_doublestrike: #{@prioritize_maneuver_doublestrike}") if $debug_mode_ct

    @doublestrike_trainables = settings.doublestrike_trainables & settings.weapon_training.keys # Intersection of the arrays to make sure weapons are available in the hunt
    echo("  @doublestrike_trainables: #{@doublestrike_trainables}") if $debug_mode_ct

    @fatigue_regen_threshold = settings.fatigue_regen_threshold
    echo("  @fatigue_regen_threshold: #{@fatigue_regen_threshold}") if $debug_mode_ct

    @balance_regen_threshold = settings.balance_regen_threshold
    echo("  @balance_regen_threshold: #{@balance_regen_threshold}") if $debug_mode_ct

    @aim_fillers = settings.aim_fillers
    echo("  @aim_fillers: #{@aim_fillers}") if $debug_mode_ct

    @aim_fillers_stealth = settings.aim_fillers_stealth
    echo("  @aim_fillers_stealth: #{@aim_fillers_stealth}") if $debug_mode_ct

    @dance_actions = settings.dance_actions
    echo("  @dance_actions: #{@dance_actions}") if $debug_mode_ct

    @dance_actions_stealth = settings.dance_actions_stealth
    echo("  @dance_actions_stealth: #{@dance_actions_stealth}") if $debug_mode_ct

    @ignored_npcs = settings.ignored_npcs
    echo("  @ignored_npcs: #{@ignored_npcs}") if $debug_mode_ct

    @dual_load = settings.dual_load
    echo("  @dual_load: #{@dual_load}") if $debug_mode_ct

    @summoned_weapons_element = settings.summoned_weapons_element
    echo("  @summoned_weapons_element: #{@summoned_weapons_element}") if $debug_mode_ct

    @summoned_weapons_ingot = settings.summoned_weapons_ingot
    echo("  @summoned_weapons_ingot: #{@summoned_weapons_ingot}") if $debug_mode_ct

    @stop_on_bleeding = settings.stop_hunting_if_bleeding
    echo("  @stop_on_bleeding: #{@stop_on_bleeding}") if $debug_mode_ct

    @cambrinth = settings.cambrinth
    echo("  @cambrinth: #{@cambrinth}") if $debug_mode_ct

    @stored_cambrinth = settings.stored_cambrinth
    echo("  @stored_cambrinth: #{@stored_cambrinth}") if $debug_mode_ct

    @cambrinth_cap = settings.cambrinth_cap
    echo("  @cambrinth_cap: #{@cambrinth_cap}") if $debug_mode_ct

    @use_weak_attacks = settings.use_weak_attacks
    echo("  @use_weak_attacks: #{@use_weak_attacks}") if $debug_mode_ct

    @use_analyze_combos = settings.use_analyze_combos || settings.use_barb_combos
    echo(" @use_analyze_combos: #{@use_analyze_combos}") if $debug_mode_ct

    @skip_last_kill = settings.skip_last_kill
    echo("  @skip_last_kill: #{@skip_last_kill}") if $debug_mode_ct

    @attack_overrides = settings.attack_overrides
    echo("  @attack_overrides: #{@attack_overrides}") if $debug_mode_ct

    @aiming_trainables = settings.aiming_trainables & settings.weapon_training.keys # Intersection of the arrays to make sure weapons are available in the hunt
    @aiming_trainables.push('Tactics') if settings.aiming_trainables.include?('Tactics') # add back in tactics
    echo("  @aiming_trainables: #{@aiming_trainables}") if $debug_mode_ct

    @using_light_crossbow = settings.using_light_crossbow
    echo("  @using_light_crossbow: #{@using_light_crossbow}") if $debug_mode_ct

    @combat_training_abilities_target = settings.combat_training_abilities_target
    echo("  @combat_training_abilities_target: #{@combat_training_abilities_target}") if $debug_mode_ct

    @whirlwind_trainables = settings.whirlwind_trainables
    echo("  @whirlwind_trainables: #{@whirlwind_trainables}") if $debug_mode_ct

    @flame_inner_fire_threshold = settings.flame_inner_fire_threshold
    echo("  @flame_inner_fire_threshold: #{@flame_inner_fire_threshold}") if $debug_mode_ct

    @flame_for_ww_expertise = !(@whirlwind_trainables && @charged_maneuvers)
    echo("  @flame_for_ww_expertise: #{@flame_for_ww_expertise}") if $debug_mode_ct

    @flame_expertise_training_threshold = settings.flame_expertise_training_threshold
    echo("  @flame_expertise_training_threshold: #{@flame_expertise_training_threshold}") if $debug_mode_ct

    @stomp_on_cooldown = settings.war_stomp_on_cooldown
    echo("  @stomp_on_cooldown: #{@stomp_on_cooldown}") if $debug_mode_ct

    @stomp_to_engage = settings.stomp_to_engage
    echo("  @stomp_to_engage: #{@stomp_to_engage}") if $debug_mode_ct

    @pounce_on_cooldown = settings.pounce_on_cooldown
    echo("  @pounce_on_cooldown: #{@pounce_on_cooldown}") if $debug_mode_ct

    @pounce_to_engage = settings.pounce_to_engage
    echo("  @pounce_to_engage: #{@pounce_to_engage}") if $debug_mode_ct

    @avtalia_array = settings.avtalia_array
    echo("  @avtalia_array: #{@avtalia_array}") if $debug_mode_ct

    @cambrinth_invoke_exact_amount = settings.cambrinth_invoke_exact_amount
    echo("  @cambrinth_invoke_exact_amount: #{@cambrinth_invoke_exact_amount}") if $debug_mode_ct

    if @use_analyze_combos && DRStats.barbarian?
      Flags.add('ct-accuracy-ready', 'You sense your combat accuracy decrease')
      Flags['ct-accuracy-ready'] = true
      Flags.add('ct-damage-ready', 'You sense your ability to land deadly blows decrease')
      Flags['ct-damage-ready'] = true
      Flags.add('ct-balance-ready', 'Your enhanced balance escapes')
      Flags['ct-balance-ready'] = true
    end

    if DRStats.barbarian?
      Flags.add('ct-barbarian-whirlwind', 'Your inner fire roils with a rising desire to unleash a whirlwind attack!')
      Flags.add('ct-barbarian-whirlwind-expired', 'The whirlwind moment passes.')
      echo "Improved whirlwind flags reset" if $debug_mode_ct
    end

    @dedicated_camb_use = settings.dedicated_camb_use
    echo(" @dedicated_camb_use: #{@dedicated_camb_use}") if $debug_mode_ct

    $thrown_skills << 'Offhand Weapon' if settings.offhand_thrown

    @is_empath = DRStats.empath?
    echo("  @is_empath: #{@is_empath}") if $debug_mode_ct

    @construct_mode = settings.construct || false
    echo("  @construct_mode: #{@construct_mode}") if $debug_mode_ct

    @is_permashocked = settings.permashocked
    echo("  @is_permashocked: #{@is_permashocked}") if $debug_mode_ct

    @undead_mode = settings.undead || false
    echo("  @undead_mode: #{@undead_mode}") if $debug_mode_ct

    @innocence_mode = settings.innocence(false)
    echo("  @innocence_mode: #{@innocence_mode}") if $debug_mode_ct
  end

  def next_clean_up_step
    echo("  Changing from clean up step #{@clean_up_step}") if $debug_mode_ct
    case @clean_up_step
    when nil
      @clean_up_step = if @stop_on_bleeding && bleeding?
                         'clear_magic'
                       elsif @skip_last_kill
                         'clear_magic'
                       else
                         'kill'
                       end
    when 'kill'
      @clean_up_step = 'clear_magic'
    when 'clear_magic'
      @clean_up_step = 'dismiss_pet'
    when 'dismiss_pet'
      @clean_up_step = 'stow'
    when 'stow'
      @clean_up_step = 'done'
    end
  end

  def cleaning_up?
    !@clean_up_step.nil?
  end

  def can_engage?
    return false unless can_face?
    return false if retreating?

    true
  end

  def can_face?
    return false if @innocence_mode
    return false if npcs.empty?

    true
  end

  def is_offense_allowed?
    return true if is_permashocked?
    return true if @construct_mode
    return true if @undead_mode && DRSpells.active_spells['Absolution']

    false
  end

  def is_permashocked?
    return true unless @is_empath
    return true if @is_permashocked

    false
  end

  def finish_killing?
    @clean_up_step == 'kill'
  end

  def finish_spell_casting?
    @clean_up_step == 'clear_magic'
  end

  def dismiss_pet?
    @clean_up_step == 'dismiss_pet'
  end

  def stowing?
    @clean_up_step == 'stow'
  end

  def done_cleaning_up?
    @clean_up_step == 'done'
  end

  def update_weapon_info(weapon_skill)
    @last_weapon_skill = @current_weapon_skill
    @current_weapon_skill = weapon_skill
  end

  def attack_override(skill = '')
    return @attack_overrides[skill] unless skill.empty?

    @attack_overrides[weapon_skill]
  end

  def whirlwind_offhand_name
    weapon_training[@current_whirlwind_offhand_skill]
  end

  def update_whirlwind_weapon_info(weapon_skill)
    @last_whirlwind_offhand_skill = @current_whirlwind_offhand_skill
    @current_whirlwind_offhand_skill = weapon_skill
  end

  def whirlwind_offhand_skill
    @current_whirlwind_offhand_skill
  end

  def whirlwind_trainable?
    return false if whirlwind_trainables.empty?

    whirlwind_trainables.include?(weapon_skill)
  end

  def sheath_whirlwind_offhand
    return unless currently_whirlwinding && DRC.left_hand

    @equipment_manager.stow_weapon(whirlwind_offhand_name)
  end

  def sheath_offhand_weapon(skill)
    return if skill.eql?('Brawling')
    return if skill.eql?('Tactics')

    @equipment_manager.stow_weapon(weapon_training[skill])
  end

  def engage
    return if retreating?
    return if stomp
    return if pounce

    case DRC.bput("engage", /^You (are already|begin to) (stealthily )?(advanc(e|ing)|at melee)/, /^There is nothing else/, /is already quite dead/, /^What do you want to advance towards/)
    when /You are already advancing/, /You begin to advance/, /You begin to stealthily advance/
      pause 2
    end
  end

  def stomp
    return if retreating?
    return false unless DRStats.barbarian? && DRStats.circle >= 100 # basic qualifications for use
    return false unless npcs.any? # We should have an NPC to pounce on
    return false unless (@stomp_to_engage || @stomp_on_cooldown) && Flags['war-stomp-ready'] # ability is off cooldown and we've elected to use it

    case DRC.bput("stomp",
                  /^As you feel your inner fire/,
                  /^With a heaving flex of masterfully controlled muscles/,
                  /You leap forward, kicking in a somersault/,
                  /You begin sprinting forward, feeling as the wind/,
                  /You spring lightly into the air. For one frozen moment/,
                  /Like a dust devil sent by Gizzbolf, you hop spinning wildly into the air/,
                  /Bringing your prodigious Togpower to bear on/,
                  /Swift and agile, you handspring into an easy/,
                  /You crouch for but a heartbeat, and then leap with the acrobatic ease/,
                  /Like an indefatigable avatar of Coshivi, you lope across the distance/,
                  /You set yourself, poised for the opportunity that will see you vanquish your adversary/,
                  /^You are not ready to perform another War Stomp/, /^What are you trying to attack/,
                  /^You have not yet been taught the proper techniques to perform a War Stomp/,
                  /^Stomp where/,
                  /^You are too fatigued to perform a War Stomp/)
    when /You have not yet been taught the proper techniques to perform a War Stomp/, /Stomp where/
      DRC.message("You have elected to War Stomp, but you do not know the ability. Learn it or remove war_stomp_on_cooldown from your yaml")
      @stomp_to_engage, @stomp_on_cooldown = [false, false]
      Flags.delete('war-stomp-ready')
      false
    when /You are not ready to perform another War Stomp/, /You are too fatigued to perform a War Stomp/
      false
    else
      Flags.reset('war-stomp-ready')
      true
    end
  end

  def pounce
    return false unless DRStats.ranger? # Current basic qualifications for use
    return false unless npcs.any? # We should have an NPC to pounce on
    return false unless (@pounce_on_cooldown || @pounce_to_engage) && Flags['pounce-ready'] # ability is off cooldown and we've elected to use

    case DRC.bput("pounce",
                  /You angle yourself to knock .* to the ground/,
                  /^You spring towards .*, with the/,
                  /^What are you trying to attack/,
                  /Doing your best impression of a house cat, you pounce on absolutely nothing at all/,
                  /You're too tired from the last time you pounced on some prey/)
    when /Doing your best impression/ # Not a ranger
      Flags.delete('pounce-ready')
      false
    when /You're too tired/ # ability not actually off cooldown
      false
    when /What are you trying to attack/ # nothing to pounce on
      false
    else
      Flags.reset('pounce-ready')
      true
    end
  end

  # Wields a weapon to train the specified skill,
  # but instead of inferring the weapon name from
  # `weapon_training:` config, wields the specified
  # weapon name given.
  #
  # Initially designed to support `ambush_stun` attacks
  # where you need a specific weapon of a particular weight, etc.
  # so the weapon you want to use may differ from your regular weapon
  # for the same skill.
  #
  # @param weapon_name
  #   The <adj> + <noun> of the weapon to wield as configured in your gear.
  # @param skill
  #   The weapon skill to train.
  # @param equip_main_hand
  #   Which hand to equip the weapon into?
  #   True to equip in main hand, false to equip in offhand.
  #   If not specified then defaults to true unless currently training 'Offhand Weapon' skill.
  # @returns name of the wielded weapon
  def wield_specific_weapon(weapon_name, skill, equip_main_hand = !offhand?)
    echo "wield_specific_weapon: weapon_name=#{weapon_name}, skill=#{skill}, equip_main_hand=#{equip_main_hand}" if $debug_mode_ct
    if is_damaris_weapon?(weapon_name)
      return wield_damaris_weapon(weapon_name, equip_main_hand)
    end

    if equip_main_hand
      @equipment_manager.wield_weapon?(weapon_name, skill)
    else
      @equipment_manager.wield_weapon_offhand?(weapon_name, skill)
    end
    return weapon_name
  end

  # Wields a weapon to train the specified skill.
  #
  # @param skill
  #   The weapon skill to train. We infer the weapon to wield based on this.
  #   If not specified then defaults to current `weapon_skill` being trained.
  # @param equip_main_hand
  #   Which hand to equip the weapon into?
  #   True to equip in main hand, false to equip in offhand.
  #   If not specified then defaults to true unless currently training 'Offhand Weapon' skill.
  # @returns name of the wielded weapon
  def wield_weapon(skill = weapon_skill, equip_main_hand = !offhand?)
    return unless skill
    return if skill.eql?('Brawling')
    return if skill.eql?('Tactics')

    weapon_name = weapon_training[skill]
    wield_specific_weapon(weapon_name, skill, equip_main_hand)
  end

  def wield_offhand_weapon(skill = weapon_skill)
    return wield_weapon(skill, false)
  end

  # Assumes the weapon name is a Damaris weapon.
  # Designed to be called from `wield_weapon(skill)`.
  #
  # @param weapon_name
  #   The <adj> + <noun> of the weapon to wield as configured in your gear.
  # @param equip_main_hand
  #   Which hand to equip the weapon into?
  #   True to equip in main hand, false to equip in offhand.
  #   If not specified then defaults to true unless currently training 'Offhand Weapon' skill.
  # @returns name of the wielded weapon
  def wield_damaris_weapon(weapon_name, equip_main_hand = !offhand?)
    # We need to wield based on the weapon's last known state then turn it to the desired noun.
    damaris_weapon_group = get_damaris_weapon_group(weapon_name)
    damaris_weapon_state = get_damaris_weapon_state(damaris_weapon_group)
    echo "wield_damaris_weapon: weapon_to_wield=#{weapon_name}, damaris_group=#{damaris_weapon_group}, damaris_state=#{damaris_weapon_state}, equip_main_hand=#{equip_main_hand}" if $debug_mode_ct
    if equip_main_hand
      @equipment_manager.wield_weapon?(damaris_weapon_state)
    else
      @equipment_manager.wield_weapon_offhand?(damaris_weapon_state)
    end
    # Damaris weapons can be turned until a certain date then need an infuser stone for more time.
    # Only if we successfully turn the weapon to the new noun do we update the damaris weapon state for the group.
    # Otherwise combat-trainer will be confused thinking we're using a different weapon than we really are.
    if @equipment_manager.turn_to_weapon?(DRC.get_noun(damaris_weapon_state), DRC.get_noun(weapon_name))
      set_damaris_weapon_state(damaris_weapon_group, weapon_name)
      return weapon_name # turn successful, return the new weapon name
    else
      DRC.message("Unable to turn #{damaris_weapon_state} into #{weapon_name}. Is the transition possible? Does it require an infuser stone? STUDY the weapon for more details.")
      return damaris_weapon_state # unable to turn, return unchanged weapon name
    end
  end

  # Assumes the weapon name is a Damaris weapon.
  # Designed to be called from `wield_offhand_weapon(skill)`.
  def wield_offhand_damaris_weapon(weapon_name)
    return wield_damaris_weapon(weapon_name, false)
  end

  def wield_whirlwind_offhand
    return if twohanded_weapon_skill?
    return unless currently_whirlwinding

    weapon_name = whirlwind_offhand_name
    echo "wield_whirlwind_offhand: weapon_name=#{weapon_name}" if $debug_mode_ct
    if is_damaris_weapon?(weapon_name)
      return wield_offhand_damaris_weapon(weapon_name)
    else
      @equipment_manager.wield_weapon_offhand?(weapon_name)
    end

    return weapon_name
  end

  def determine_whirlwind_action
    if Flags['ct-barbarian-whirlwind'] && !Flags['ct-barbarian-whirlwind-expired']
      echo "Performing improved whirlwind" if $debug_mode_ct
      Flags.reset('ct-barbarian-whirlwind')
      'whirlwind'
    elsif lacking_inner_fire? || (@flame_for_ww_expertise && need_expertise?)
      update_analyze_array('flame') if @analyze_combo_array.empty?
      @analyze_combo_array.empty? ? 'attack' : @analyze_combo_array.shift
    elsif Flags['ct-accuracy-ready']
      update_analyze_array('accuracy') if @analyze_combo_array.empty?
      @analyze_combo_array.empty? ? 'attack' : @analyze_combo_array.shift
    elsif (npcs.length > 2) && !balance_low?
      'whirlwind'
    else
      action_reduce if npcs.length > 2
      %w[jab feint].sample
    end
  end

  # Get the skill of the weapon currently being trained (e.g. Small Edged).
  def weapon_skill
    @current_weapon_skill
  end

  # Does the current weapon train a two-handed skill (i.e. 2HE/2HB)?
  def twohanded_weapon_skill?
    $twohanded_skills.include?(weapon_skill)
  end

  # Does the current weapon train a non-brawling melee skill (i.e. edged, blunt, staff, polearm)?
  def melee_weapon_skill?
    $melee_skills.include?(weapon_skill)
  end

  # Does the current weapon train a thrown skill (i.e. light/heavy thrown)?
  def thrown_skill?
    $thrown_skills.include?(weapon_skill)
  end

  # Does the current weapon train an aimable skill (i.e. bow/crossbow/sling)?
  def aimed_skill?
    $aim_skills.include?(weapon_skill)
  end

  # Is the offhand weapon skill currently being trained?
  def offhand?
    weapon_skill == 'Offhand Weapon'
  end

  # Is the melee brawling skill currently being trained?
  def brawling?
    weapon_skill == 'Brawling' && !is_brawling_ranged?
  end

  def is_brawling_ranged?
    /(?:\b|^)blowgun(?:\b|$)/i.match(weapon_training['Brawling'])
  end

  def dance
    if @dynamic_dance_skill
      filtered_skills = weapon_training.keys.reject { |skill| $non_dance_skills.include?(skill) }
      @dance_skill = sort_by_rate_then_rank(filtered_skills).first
    end
    update_weapon_info(@dance_skill)
  end

  def skill_done?
    current_exp = DRSkill.getxp(weapon_skill)
    echo("action count: #{@action_count} vs #{@target_action_count}") if $debug_mode_ct
    echo("skill exp: #{current_exp} vs #{@target_weapon_skill}") if $debug_mode_ct

    @action_count >= @target_action_count || current_exp >= @target_weapon_skill
  end

  def update_room_npcs
    @dancing = npcs.length <= @dance_threshold || npcs.empty?
    @retreating = @retreat_threshold && npcs.length >= @retreat_threshold
  end

  def retreat_weapons
    weapon_training.select { |skill, _| $ranged_skills.include?(skill) }
  end

  def summoned_info(weapon_skill)
    @summoned_weapons.find { |summoned_skill| summoned_skill['name'] == weapon_skill }
  end

  def weapon_is_summoned?
    !summoned_info(weapon_skill).nil?
  end

  def update_target_weapon_skill
    @target_weapon_skill = [34, DRSkill.getxp(current_weapon_skill) + @target_increment].min
  end

  def strict_weapon_stance
    @strict_weapon_stance
  end

  def current_weapon_stance
    @stances[weapon_skill]
  end

  def skinnable?(mob_noun)
    @no_skins.none?(mob_noun)
  end

  def unskinnable(mob_noun)
    echo("adding #{mob_noun} to no skin list: #{@no_skins}") if $debug_mode_ct
    @no_skins.append(mob_noun)
  end

  def dissectable?(mob_noun)
    @no_dissect.none?(mob_noun)
  end

  def undissectable(mob_noun)
    echo("adding #{mob_noun} to no dissect list: #{@no_dissect}") if $debug_mode_ct
    @no_dissect.push(mob_noun)
  end

  def construct?(mob_noun)
    @constructs.include?(mob_noun)
  end

  def construct(mob_noun)
    @constructs.push(mob_noun)
  end

  def stabbable?(mob_noun)
    !@no_stab_mobs.include?(mob_noun)
  end

  def unstabbable(mob_noun)
    @no_stab_mobs.push(mob_noun)
  end

  def lootable?(item)
    !@no_loot.include?(item.downcase)
  end

  def unlootable(item)
    @no_loot.push(item.downcase)
  end

  def weapon_training
    @weapons_to_train
  end

  def weapon_name
    weapon_training[weapon_skill]
  end

  def last_weapon_name
    weapon_training[@last_weapon_skill]
  end

  def use_stealth_attack?
    @use_stealth_attacks && use_stealth?
  end

  def use_stealth_ranged?
    @use_stealth_ranged && use_stealth?
  end

  def ambush?
    @ambush && DRSkill.getxp('Backstab') < 34 && !brawling?
  end

  def backstab?
    return @backstab.include?(weapon_skill) if @backstab_past_mindlock

    @backstab.include?(weapon_skill) && DRSkill.getxp('Backstab') < 34
  end

  def ambush_stun_training?
    return @ambush_stun_weapons.include?(weapon_skill)
  end

  def dancing?
    @dancing
  end

  def retreating?
    @retreating
  end

  def charged_maneuver_off_cooldown?(maneuver)
    # Non-Barbarians can perform a maneuver every 90 seconds.
    # Barbarians have a chance to reduce that to 60 seconds.
    # To account for the adjustable cooldown, the timer we store
    # for maneuvers is the future time when it'll be ready rather
    # than the start time as we do with other ability timers.
    # This allows us to shorten or lengthen the "time when it'll be ready".
    timer = @cooldown_timers[maneuver]
    timer.nil? || (Time.now > timer)
  end

  def determine_charged_maneuver
    return nil unless @use_charged_maneuvers

    maneuver = nil
    can_dual_wield_whirlwind = @currently_whirlwinding && !twohanded_weapon_skill?
    can_dual_wield_doublestrike = @prioritize_maneuver_doublestrike && doublestrikable_weapon_skill?
    if charged_maneuver_off_cooldown?(@charged_maneuvers['Dual Wield']) && (can_dual_wield_whirlwind || can_dual_wield_doublestrike)
      maneuver = @charged_maneuvers['Dual Wield']
    elsif charged_maneuver_off_cooldown?(@charged_maneuvers[weapon_skill])
      maneuver = @charged_maneuvers[weapon_skill]
    end
    maneuver
  end

  def fatigue_low?
    echo("***Fatigue: #{DRStats.fatigue}***") if $debug_mode_ct
    echo("***Target: #{@fatigue_regen_threshold}***") if $debug_mode_ct
    DRStats.fatigue < @fatigue_regen_threshold
  end

  def balance_low?
    echo("***Balance: #{DRStats.balance}***") if $debug_mode_ct
    echo("***Target: #{@balance_regen_threshold}***") if $debug_mode_ct
    DRStats.balance < @balance_regen_threshold
  end

  def reset_action_count
    @action_count = 0
    echo "Action Count reset" if $debug_mode_ct
  end

  def action_taken(count = 1)
    @action_count += count
    echo "Action Count incremented to #{@action_count}" if $debug_mode_ct
  end

  def action_reduce(count = 1)
    @action_count -= count
    echo "Action Count reduced to #{@action_count}" if $debug_mode_ct
  end

  def set_aim_queue
    echo("set_aim_queue #{@aim_fillers}:#{@aim_fillers_stealth}") if $debug_mode_ct

    @aim_queue = aim_stealth? ? @aim_fillers_stealth[weapon_skill].dup : @aim_fillers[weapon_skill].dup
  end

  def clear_aim_queue
    @aim_queue = []
  end

  def done_aiming?
    @aim_queue.empty?
  end

  def next_aim_action
    @aim_queue.shift
  end

  def set_dance_queue
    return unless @dance_queue.empty?

    echo("set_dance_queue #{@dance_actions}:#{@dance_actions_stealth}") if $debug_mode_ct

    @dance_queue = dance_stealth? ? @dance_actions_stealth.dup : @dance_actions.dup
  end

  def next_dance_action
    @dance_queue.shift
  end

  def necro_casting?
    return false unless DRStats.necromancer?
    return true if @prepare_nr
    return true if @casting_nr
    return true if @prepare_cfb
    return true if @casting_cfb
    return true if @prepare_cfw
    return true if @casting_cfw
    return true if @prepare_consume
    return true if @casting_consume

    false
  end

  def cambrinth_charges(charges)
    cambrinth = case charges.first
                when Array
                  charges.first
                else
                  charges
                end
    @charges = nil

    return if cambrinth.nil? || cambrinth.empty?

    @charges_total = cambrinth.inject(:+)
    @charges = cambrinth.dup
  end

  def check_charging?
    return false if @charges.nil?

    if @charges.empty?
      echo('check_charging?: done') if $debug_mode_ct
      cambrinth_charges(nil)
      return false
    end

    next_charge = @charges.pop
    next_charge = avtalia_charge(next_charge)

    echo("check_charging?: #{next_charge}") if $debug_mode_ct

    return true if next_charge.zero?

    DRCA.find_cambrinth(@cambrinth, @stored_cambrinth, @cambrinth_cap)
    @charges = [] unless DRCA.charge?(@cambrinth, next_charge)

    DRCA.stow_cambrinth(@cambrinth, @stored_cambrinth, @cambrinth_cap)

    true
  end

  def avtalia_charge(charge_num) # sources mana from filled avtalia cambrinth, then returns the amount left uncharged
    return charge_num unless DRStats.trader?
    return charge_num unless @cambrinth_invoke_exact_amount
    return charge_num if @avtalia_array.empty?
    return charge_num unless DRStats.mana < 80

    remaining_charge = @charges.inject(0, :+) + charge_num
    @avtalia_cambrinth = find_avtalia(remaining_charge) if @avtalia_cambrinth.empty?
    return charge_num if @avtalia_cambrinth.empty?

    # unwrap the charges for the spell. Keep pulling in more cambrinth mana entries until it either hits the camb cap or gets all of it.
    return avtalia_charge(charge_num + @charges.pop) if charge_num < [@avtalia_cambrinth.last['mana'], remaining_charge].min

    # how much will be invoked from the camb, either all the charges of the spell, or the cambrinth cap
    charge_avta = [charge_num, @avtalia_cambrinth.last['mana']].min
    DRCA.invoke_avtalia(@avtalia_cambrinth.first, @dedicated_camb_use, charge_avta)
    # charges_total subtracts what we got from avtalia array, and invokes the rest from normal cambrinth
    @charges_total -= charge_avta
    @avtalia_cambrinth = {}

    echo("avtalia_charge: pulled #{charge_avta} mana from #{@avtalia_cambrinth.first}") if $debug_mode_ct
    return charge_num - charge_avta
  end

  def avtalia_cyclic(prep_mana)
    return unless DRStats.trader?
    return unless @dedicated_camb_use == 'spell'
    return if @avtalia_array.empty?

    @avtalia_cambrinth = find_avtalia(prep_mana * 10) if @avtalia_cambrinth.empty?
    return if @avtalia_cambrinth.empty?

    DRCA.invoke_avtalia(@avtalia_cambrinth.first, 'cyclic', @avtalia_cambrinth.last['cap'])
    @avtalia_cambrinth = {}
  end

  def find_avtalia(charge_needed)
    case DRStats.mana
    when 0..60
      DRCA.choose_avtalia(charge_needed, 0)
    when 60..80
      DRCA.choose_avtalia(charge_needed, 80)
    when 80..100
      {}
    end
  end

  def check_harness
    return if @charges.nil?

    if @charges.empty?
      echo('check_harness?: done') if $debug_mode_ct
      cambrinth_charges(nil)
      return
    end

    DRCA.harness_mana(@charges.flatten)

    @charges = []
  end

  def npcs
    DRRoom.npcs - @ignored_npcs
  end

  def dual_load?
    @dual_load && weapon_skill == 'Bow' &&
      DRSkill.getrank('Bow') >= 201 && DRStats.agility >= 30 && DRStats.reflex >= 30 &&
      (DRSpells.active_spells['See the Wind'] || DRStats.barbarian? || DRSpells.active_spells['Khri Steady'])
  end

  def prepare_summoned_weapon(weapon_already_summoned)
    info = summoned_info(weapon_skill)

    DRCS.summon_weapon(UserVars.moons['visible'].first, @summoned_weapons_element, @summoned_weapons_ingot, weapon_skill) unless weapon_already_summoned
    DRCS.shape_summoned_weapon(weapon_skill, @summoned_weapons_ingot) if weapon_already_summoned || DRStats.moon_mage?
    DRCS.turn_summoned_weapon if info['turn']
    DRCS.push_summoned_weapon if info['push']
    DRCS.pull_summoned_weapon if info['pull']
  end

  def can_ambush_stun?
    !npcs.empty? && !aimed_skill?
  end

  def can_use_barrage_attack?
    return false unless DRStats.warrior_mage?
    return false unless melee_weapon_skill?
    return false unless DRCA.check_elemental_charge >= 5

    true
  end

  def use_weak_attacks?
    @use_weak_attacks
  end

  def stop_weak_attacks
    @use_weak_attacks = false
  end

  def stop_analyze_combo
    @use_analyze_combos = false
  end

  def set_barb_accuracy_flag
    Flags.reset('ct-accuracy-ready')
  end

  def set_barb_damage_flag
    Flags.reset('ct-damage-ready')
  end

  def reset_barb_whirlwind_flags_if_needed
    if Flags['ct-barbarian-whirlwind-expired']
      Flags.reset('ct-barbarian-whirlwind')
      Flags.reset('ct-barbarian-whirlwind-expired')
    end
  end

  def lacking_inner_fire?
    return false unless DRStats.barbarian? && @use_analyze_combos
    return false unless DRStats.mana < @flame_inner_fire_threshold

    true
  end

  def need_expertise?
    return false unless DRStats.barbarian? && @use_analyze_combos
    return false unless DRSkill.getxp('Expertise') < @flame_expertise_training_threshold

    true
  end

  def melee_attack_verb
    if currently_whirlwinding
      determine_whirlwind_action
    elsif (lacking_inner_fire? || need_expertise?) && !brawling?
      update_analyze_array('flame') if @analyze_combo_array.empty?
      @analyze_combo_array.empty? ? 'attack' : @analyze_combo_array.shift
    elsif attack_override
      attack_override
    elsif @use_weak_attacks
      brawling? ? 'gouge' : 'jab'
    # !offhand & !brawling are there because you can't use a weapon for brawling commands
    # This issue will cause problems with the combo array system
    elsif @use_analyze_combos && !offhand? && !brawling? && DRSkill.getxp('Tactics') <= @combat_training_abilities_target
      update_analyze_array if @analyze_combo_array.empty?
      @analyze_combo_array.empty? ? 'attack' : @analyze_combo_array.shift
    else
      'attack'
    end
  end

  def thrown_attack_verb
    if attack_override
      attack_override
    elsif bound_weapon? && !@use_weak_attacks
      'hurl'
    elsif @use_weak_attacks || lodging_weapon?
      'lob'
    else
      'throw'
    end
  end

  def thrown_retrieve_verb
    if bound_weapon?
      'invoke'
    else
      "get my #{weapon_name}"
    end
  end

  def cfb_active?
    DRSpells.active_spells.include?('Call from Beyond')
  end

  def cfw_active?
    DRSpells.active_spells.include?('Call from Within')
  end

  def construct_mode?
    @construct_mode
  end

  # Determine the weapon skill to train offhand while aiming a ranged weapon.
  def determine_aiming_skill
    damaris_weapon_options = get_damaris_weapon_options(weapon_name)
    options = @aiming_trainables
    options -= [weapon_skill] # can't be your mainhand skill, it's in your main hand
    options -= $twohanded_skills # can't be a twohanded skill, you need both hands
    options -= $aim_skills # can't use aimable weapons in your offhand
    options -= $melee_skills if weapon_skill.eql?('Bow') || (weapon_skill.eql?('Crossbow') && !@using_light_crossbow) # can't aim with weapon in your offhand
    options -= $thrown_skills if (weapon_skill.eql?('Bow') && @left_hand_free)
    options -= weapon_training.select { |_skill, weapon| weapon == weapon_training[weapon_skill] }.keys # can't be same weapon that's equipped in your mainhand
    options -= weapon_training.select { |_skill, weapon| damaris_weapon_options.include?(weapon) }.keys # remove all weapons part of the same Damaris weapon group since they're the same item
    options -= weapon_training.select { |_skill, weapon| swappable_weapon?(weapon) }.keys # remove swappable weapons because they might be swapped into a two-handed state
    options -= @summoned_weapons.map { |info| info['name'] } # remove summoned weapons because they may not exist for offhand use
    echo "determine_aiming_skill::options: #{options}" if $debug_mode_ct
    sort_by_rate_then_rank(options).first
  end

  # Determine the weapon skill to equip offhand to perform a doublestrike maneuver.
  def determine_doublestrike_skill
    damaris_weapon_options = get_damaris_weapon_options(weapon_name)
    options = @doublestrike_trainables
    options -= [weapon_skill] # can't be your main hand skill, it's in your main hand
    options -= $twohanded_skills # can't be a twohanded skill, you need both hands
    options -= $aim_skills # can't use aimable weapons in your offhand
    options -= $martial_skills # shouldn't be brawling, you need a weapon in your offhand
    options -= weapon_training.select { |_skill, weapon| weapon == weapon_training[weapon_skill] }.keys # can't be same weapon that's equipped in your mainhand
    options -= weapon_training.select { |_skill, weapon| damaris_weapon_options.include?(weapon) }.keys # remove all weapons part of the same Damaris weapon group since they're the same item
    options -= weapon_training.select { |_skill, weapon| swappable_weapon?(weapon) }.keys # remove swappable weapons because they might be swapped into a two-handed state
    options -= @summoned_weapons.map { |info| info['name'] } # remove summoned weapons because they may not exist for offhand use
    echo "determine_doublestrike_skill::options: #{options}" if $debug_mode_ct
    sort_by_rate_then_rank(options).first
  end

  # Is the main hand weapon skill suitable to perform a doublestrike maneuver?
  # For example, the two-handed variants of Staves and Polearms are not,
  # but their shorter, one-handed variants are.
  # If the main hand weapon skill is doublestrikable then `determine_doublestrike_skill`
  # is used to determine what to equip offhand to perform the maneuver.
  def doublestrikable_weapon_skill?
    @doublestrike_trainables.include?(weapon_skill) && # mainhand weapon is listed for doublestrikes
      (melee_weapon_skill? || thrown_skill?) && # mainhand weapon is a one-handed, melee weapon
      !twohanded_weapon_skill? && # mainhand weapon is not a twohanded weapon (extra precaution)
      determine_doublestrike_skill # there's at least one weapon skill that can be equipped offhand that's different from the mainhand (can't equip same weapon in both hands)
  end

  # Determine the weapon skill to equip offhand to use while whirlwinding.
  def determine_whirlwind_weapon_skill
    return if twohanded_weapon_skill?

    damaris_weapon_options = get_damaris_weapon_options(weapon_name)
    options = @whirlwind_trainables
    options -= [weapon_skill] # can't be your main hand skill, it's in your main hand
    options -= $twohanded_skills # can't be a twohanded skill, you need both hands
    options -= weapon_training.select { |_skill, weapon| weapon == weapon_training[weapon_skill] }.keys # can't be same weapon that's equipped in your mainhand
    options -= weapon_training.select { |_skill, weapon| damaris_weapon_options.include?(weapon) }.keys # remove all weapons part of the same Damaris weapon group since they're the same item
    options -= weapon_training.select { |_skill, weapon| swappable_weapon?(weapon) }.keys # remove swappable weapons because they might be swapped into a two-handed state
    options -= @summoned_weapons.map { |info| info['name'] } # remove summoned weapons because they may not exist for offhand use
    echo "determine_whirlwind_weapon_skill::options: #{options}" if $debug_mode_ct
    sort_by_rate_then_rank(options).first
  end

  # Determines if the given weapon name is part of a Damaris weapon group.
  def is_damaris_weapon?(weapon_name)
    get_damaris_weapon_group(weapon_name) != nil
  end

  # Returns the Damaris weapon group the weapon name belongs to.
  # Initially designed so that we can check if two weapons
  # are part of the same set or not to know if we can `turn {x} to {y}`.
  def get_damaris_weapon_group(weapon_name)
    @damaris_weapon_sets.find { |_group, weapons| weapons.find { |weapon| weapon == weapon_name } }.first
  end

  # What can the given weapon turn into?
  def get_damaris_weapon_options(weapon_name)
    @damaris_weapon_sets[get_damaris_weapon_group(weapon_name)]
  end

  # For the given Damaris weapon group, what is the last known state it's in?
  def get_damaris_weapon_state(group)
    @damaris_weapon_states[group]
  end

  # Record the last known state the Damaris weapon has been turned to.
  def set_damaris_weapon_state(group, weapon_name)
    @damaris_weapon_states[group] = weapon_name
  end

  def use_stealth?
    DRSkill.getxp('Stealth') < @combat_training_abilities_target
  end

  # Given an array of skills, sorts them first by
  # their learning rate and then by their rank.
  # For example, if two skills have the same learning rate (e.g. 12/34)
  # then the skill with fewer ranks will be sorted first.
  # This avoids repeatedly picking a high rank skill whose learn rate
  # will be 0/34 because not being challenged and consequently
  # starving lower rank skills from being chosen.
  def sort_by_rate_then_rank(skills, priorities = [])
    skills.sort_by do |skill|
      [
        DRSkill.getxp(skill),                 # choose first by skills with lowest learning rate
        priorities.include?(skill) ? -1 : 0,  # and of those, choose skills that are to be prioritized
        DRSkill.getrank(skill)                # and lastly, choose by skills with lowest ranks
      ]
    end
  end

  attr_reader :aiming_trainables, :summoned_weapons

  private

  # Is the weapon swappable, like a riste?
  # If don't pass in an item to check, defaults to current weapon being trained.
  def swappable_weapon?(name = weapon_name)
    item = @equipment_manager.item_by_desc(name)
    item && item.swappable
  end

  # Does the weapon lodge when thrown?
  # If don't pass in an item to check, defaults to current weapon being trained.
  def lodging_weapon?(name = weapon_name)
    item = @equipment_manager.item_by_desc(name)
    # Assume it's lodging unless the config says otherwise.
    item.nil? || item.lodges
  end

  # Is the weapon bound such that you could `invoke {weapon}` to retrieve it?
  # If don't pass in an item to check, defaults to current weapon being trained.
  def bound_weapon?(name = weapon_name)
    item = @equipment_manager.item_by_desc(name)
    item && item.bound
  end

  def perform_analyze?(combo_type, expertise_requirement)
    return false if combo_type != 'flame' && !Flags["ct-#{combo_type}-ready"] && DRStats.barbarian?
    return false if DRSkill.getrank('Expertise') < expertise_requirement
    return false unless can_engage?

    result = DRC.bput("analyze #{combo_type}", 'cannot repeat', 'Analyze what\?', 'by landing an? .*', 'You need to hold', 'You must be closer', 'You fail to find any', 'What are you trying to attack\?')
    waitrt?

    case result
    when 'cannot repeat'
      Flags.reset("ct-#{combo_type}-ready")
      return false
    when 'You must be closer'
      engage
    when 'You fail to find any'
      perform_analyze?(combo_type, expertise_requirement)
    when 'Analyze what?'
      case DRC.bput('face next', 'There is nothing else', 'You turn', 'What are you trying', 'Face what')
      when 'You turn'
        return perform_analyze?(combo_type, expertise_requirement)
      end
      return true
    when 'What are you trying to attack?'
      return true
    end

    text = result.match(/by landing an? (.*)\.$/).to_a[1]
    @analyze_combo_array = DRC.list_to_nouns(text)

    true
  end

  def update_analyze_array(type = nil)
    if DRStats.barbarian?
      # Try to perform the desired combo, and if successful then return.
      return if type && (perform_analyze?(type, @barb_analyzes[type]) || currently_whirlwinding)

      # Otherwise, let system try to decide which combo to perform based on your expertise ranks.
      @barb_analyzes.each do |combo, expertise|
        break if perform_analyze?(combo, expertise)
      end
    else
      perform_analyze?('', 0)
    end
  end

  def dance_stealth?
    @dance_actions_stealth && !@dance_actions_stealth.empty? && use_stealth?
  end

  def aim_stealth?
    @aim_fillers_stealth && @aim_fillers_stealth[weapon_skill] && use_stealth?
  end
end

before_dying do
  DRCA.release_cyclics(get_settings.cyclic_no_release)
  DRCA.shatter_regalia?
  fput('close fissure') if DRStats.warrior_mage? && DRRoom.room_objs.any? { |x| /fissure/ =~x }
  Flags.delete('using-corpse')
  Flags.delete('pouch-full')
  Flags.delete('container-full')
  Flags.delete('ct-lodged')
  Flags.delete('ct-parasite')
  Flags.delete('ct-engaged')
  Flags.delete('active-mitigation')
  Flags.delete('ct-spelllost')
  Flags.delete('need-tkt-ammo')
  Flags.delete('ct-spellcast')
  Flags.delete('glyph-mana-expired')
  Flags.delete('ct-face-what')
  Flags.delete('ct-aim-failed')
  Flags.delete('ct-powershot-ammo')
  Flags.delete('ct-ranged-ammo')
  Flags.delete('ct-ranged-loaded')
  Flags.delete('ct-using-repeating-crossbow')
  Flags.delete('ct-ranged-ready')
  Flags.delete('ct-accuracy-ready')
  Flags.delete('ct-damage-ready')
  Flags.delete('ct-need-bless')
  Flags.delete('last-stance')
  Flags.delete('ct-regalia-expired')
  Flags.delete('ct-starlight-depleted')
  Flags.delete('ct-regalia-succeeded')
  Flags.delete('ct-germshieldlost')
  Flags.delete('ct-itemdropped')
  Flags.delete('ct-shock-warning')
  Flags.delete('ct-maneuver-cooldown-reduced')
  Flags.delete('ct-attack-out-of-range')
  Flags.delete('ct-battle-cry-not-facing')
  Flags.delete('ct-barbarian-whirlwind')
  Flags.delete('ct-barbarian-whirlwind-expired')
  Flags.delete('war-stomp-ready')
  Flags.delete('pounce-ready')
end

$COMBAT_TRAINER = CombatTrainer.new
$COMBAT_TRAINER.start_combat
