=begin
  Documentation: https://elanthipedia.play.net/Lich_script_development#drinfomon
=end

$DRINFOMON_VERSION = '2.0.29'

no_kill_all
no_pause_all

setpriority(0)

class DRStats
  @@race = nil
  @@guild = nil
  @@gender = nil
  @@age ||= 0
  @@circle ||= 0
  @@strength ||= 0
  @@stamina ||= 0
  @@reflex ||= 0
  @@agility ||= 0
  @@intelligence ||= 0
  @@wisdom ||= 0
  @@discipline ||= 0
  @@charisma ||= 0
  @@favors ||= 0
  @@tdps ||= 0
  @@encumbrance = nil
  @@balance ||= 8
  # Assume vitals are 100%. If they aren't then the game will rather quickly
  # pulse with vitals updates and the correct values will be set.
  # If you're already at 100% then the game may not send the vitals until
  # you take an action to consume or restore a vital. Because of this, you
  # can get stuck by common-arcana waiting for your concentration or mana
  # to increase to at least 80% even though you logged in with 100%.
  @@concentration ||= 100
  @@health ||= 100
  @@mana ||= 100
  @@fatigue ||= 100
  @@spirit ||= 100

  def self.race
    @@race
  end

  def self.race=(val)
    @@race = val
  end

  def self.guild
    @@guild
  end

  def self.guild=(val)
    @@guild = val
  end

  def self.gender
    @@gender
  end

  def self.gender=(val)
    @@gender = val
  end

  def self.age
    @@age
  end

  def self.age=(val)
    @@age = val
  end

  def self.circle
    @@circle
  end

  def self.circle=(val)
    @@circle = val
  end

  def self.strength
    @@strength
  end

  def self.strength=(val)
    @@strength = val
  end

  def self.stamina
    @@stamina
  end

  def self.stamina=(val)
    @@stamina = val
  end

  def self.reflex
    @@reflex
  end

  def self.reflex=(val)
    @@reflex = val
  end

  def self.agility
    @@agility
  end

  def self.agility=(val)
    @@agility = val
  end

  def self.intelligence
    @@intelligence
  end

  def self.intelligence=(val)
    @@intelligence = val
  end

  def self.wisdom
    @@wisdom
  end

  def self.wisdom=(val)
    @@wisdom = val
  end

  def self.discipline
    @@discipline
  end

  def self.discipline=(val)
    @@discipline = val
  end

  def self.charisma
    @@charisma
  end

  def self.charisma=(val)
    @@charisma = val
  end

  def self.concentration
    @@concentration
  end

  def self.concentration=(val)
    @@concentration = val
  end

  def self.favors
    @@favors
  end

  def self.favors=(val)
    @@favors = val
  end

  def self.tdps
    @@tdps
  end

  def self.tdps=(val)
    @@tdps = val
  end

  def self.balance
    @@balance
  end

  def self.balance=(val)
    @@balance = val
  end

  def self.encumbrance
    @@encumbrance
  end

  def self.encumbrance=(val)
    @@encumbrance = val
  end

  def self.health
    @@health
  end

  def self.health=(val)
    @@health = val
  end

  def self.mana
    @@mana
  end

  def self.mana=(val)
    @@mana = val
  end

  def self.native_mana
    case DRStats.guild
    when 'Necromancer'
      'arcane'
    when 'Barbarian', 'Thief'
      nil
    when 'Moon Mage', 'Trader'
      'lunar'
    when 'Warrior Mage', 'Bard'
      'elemental'
    when 'Cleric', 'Paladin'
      'holy'
    when 'Empath', 'Ranger'
      'life'
    end
  end

  def self.fatigue
    @@fatigue
  end

  def self.fatigue=(val)
    @@fatigue = val
  end

  def self.spirit
    @@spirit
  end

  def self.spirit=(val)
    @@spirit = val
  end

  def self.serialize
    [@@race, @@guild, @@gender, @@age, @@circle, @@strength, @@stamina, @@reflex, @@agility, @@intelligence, @@wisdom, @@discipline, @@charisma, @@concentration, @@favors, @@tdps, @@encumbrance, @@health, @@mana, @@fatigue, @@spirit]
  end

  def self.load_serialized=(array)
    @@race, @@guild, @@gender, @@age = array[0..3]
    @@circle, @@strength, @@stamina, @@reflex, @@agility, @@intelligence, @@wisdom, @@discipline, @@charisma, @@concentration, @@favors, @@tdps, @@encumbrance, @@health, @@mana, @@fatigue, @@spirit = array[5..21]
  end

  def self.barbarian?
    @@guild == 'Barbarian'
  end

  def self.bard?
    @@guild == 'Bard'
  end

  def self.cleric?
    @@guild == 'Cleric'
  end

  def self.commoner?
    @@guild == 'Commoner'
  end

  def self.empath?
    @@guild == 'Empath'
  end

  def self.moon_mage?
    @@guild == 'Moon Mage'
  end

  def self.necromancer?
    @@guild == 'Necromancer'
  end

  def self.paladin?
    @@guild == 'Paladin'
  end

  def self.ranger?
    @@guild == 'Ranger'
  end

  def self.thief?
    @@guild == 'Thief'
  end

  def self.trader?
    @@guild == 'Trader'
  end

  def self.warrior_mage?
    @@guild == 'Warrior Mage'
  end
end

class DRSkill
  @@skills_data ||= get_data('skills')
  @@gained_skills ||= []
  @@start_time ||= Time.now
  @@list ||= []
  @@exp_modifiers ||= {}

  attr_reader :name, :rank, :exp, :percent, :current, :baseline, :skillset
  attr_writer :rank, :exp, :percent, :current, :baseline

  def initialize(name, rank, exp, percent)
    @name = name # skill name like 'Evasion'
    @rank = rank.to_i # earned ranks in the skill
    @exp = exp.to_i # learning rate in the skill from 0 to 34
    @percent = percent.to_i # percent to next rank from 0 to 100
    @baseline = rank.to_i + (percent.to_i / 100.0)
    @current = rank.to_i + (percent.to_i / 100.0)
    @skillset = lookup_skillset(@name)
    @@list.push(self) unless @@list.find { |skill| skill.name == @name }
  end

  def self.reset
    @@gained_skills = []
    @@start_time = Time.now
    @@list.each { |skill| skill.baseline = skill.current }
  end

  # Primarily used by `learned` script to track how long it's
  # been tracking your experience gains this session.
  def self.start_time
    @@start_time
  end

  # List of skills that have increased their learning rates.
  # Primarily used by `exp-monitor` script to echo which skills
  # gained experience after you performed an action.
  def self.gained_skills
    @@gained_skills
  end

  # Returns the amount of ranks that have been gained since
  # the baseline was last reset. This allows you to track
  # rank gain for a given play session.
  #
  # Note, don't confuse the 'exp' in this method name with DRSkill.getxp(..)
  # which returns the current learning rate of the skill.
  def self.gained_exp(val)
    skill = self.find_skill(val)
    if skill
      return skill.current ? (skill.current - skill.baseline).round(2) : 0.00
    end
  end

  # Updates DRStats.gained_skills if the learning rate increased.
  # The original consumer of this data is the `exp-monitor` script.
  def self.handle_exp_change(name, new_exp)
    return unless UserVars.echo_exp

    old_exp = DRSkill.getxp(name)
    change = new_exp.to_i - old_exp.to_i
    if change > 0
      DRSkill.gained_skills << { skill: name, change: change }
    end
  end

  def self.include?(val)
    !self.find_skill(val).nil?
  end

  def self.update(name, rank, exp, percent)
    self.handle_exp_change(name, exp)
    skill = self.find_skill(name)
    if skill
      skill.rank = rank.to_i
      skill.exp = exp.to_i
      skill.percent = percent.to_i
      skill.current = rank.to_i + (percent.to_i / 100.0)
    else
      DRSkill.new(name, rank, exp, percent)
    end
  end

  def self.update_mods(name, rank)
    self.exp_modifiers[self.lookup_alias(name)] = rank.to_i
  end

  def self.exp_modifiers
    @@exp_modifiers
  end

  def self.clear_mind(val)
    self.find_skill(val).exp = 0
  end

  def self.getrank(val)
    self.find_skill(val).rank.to_i
  end

  def self.getmodrank(val)
    skill = self.find_skill(val)
    if skill
      rank = skill.rank.to_i
      modifier = self.exp_modifiers[skill.name].to_i
      rank + modifier
    end
  end

  def self.getxp(val)
    skill = self.find_skill(val)
    skill.rank.to_i >= 1750 ? 34 : skill.exp.to_i
  end

  def self.getpercent(val)
    self.find_skill(val).percent.to_i
  end

  def self.getskillset(val)
    self.find_skill(val).skillset
  end

  def self.listall
    @@list.each do |i|
      echo "#{i.name}: #{i.rank}.#{i.percent}% [#{i.exp}/34]"
    end
  end

  def self.list
    @@list
  end

  private_class_method def self.find_skill(val)
    @@list.find { |data| data.name == self.lookup_alias(val) }
  end

  # Some guilds rename skills, like Barbarians call "Primary Magic" as "Inner Fire".
  # Given the canonical or colloquial name, this method returns the value
  # that's usable with the other methods like `getxp(skill)` and `getrank(skill)`.
  private_class_method def self.lookup_alias(skill)
    @@skills_data.guild_skill_aliases[DRStats.guild][skill] || skill
  end

  # This is an instance method, do not prefix with `self`.
  # It is called from the initialize method (constructor).
  # When it was defined as a class method then the initialize method
  # complained that this method didn't yet exist.
  def lookup_skillset(skill)
    @@skills_data.skillsets.find { |_skillset, skills| skills.include?(skill) }.first
  end
end

class DRRoom
  @@npcs ||= []
  @@pcs ||= []
  @@group_members ||= []
  @@pcs_prone ||= []
  @@pcs_sitting ||= []
  @@dead_npcs ||= []
  @@room_objs ||= []
  @@exits ||= []
  @@title = ''
  @@description = ''

  def self.npcs
    @@npcs
  end

  def self.npcs=(val)
    @@npcs = val
  end

  def self.pcs
    @@pcs
  end

  def self.pcs=(val)
    @@pcs = val
  end

  def self.exits
    @@exits
  end

  def self.exits=(val)
    @@exits = val
  end

  def self.title
    @@title
  end

  def self.title=(val)
    @@title = val
  end

  def self.description
    @@description
  end

  def self.description=(val)
    @@description = val
  end

  def self.group_members
    @@group_members
  end

  def self.group_members=(val)
    @@group_members = val
  end

  def self.pcs_prone
    @@pcs_prone
  end

  def self.pcs_prone=(val)
    @@pcs_prone = val
  end

  def self.pcs_sitting
    @@pcs_sitting
  end

  def self.pcs_sitting=(val)
    @@pcs_sitting = val
  end

  def self.dead_npcs
    @@dead_npcs
  end

  def self.dead_npcs=(val)
    @@dead_npcs = val
  end

  def self.room_objs
    @@room_objs
  end

  def self.room_objs=(val)
    @@room_objs = val
  end
end

def convert2copper(amt, denomination)
  if denomination =~ /platinum/
    (amt.to_i * 10_000)
  elsif denomination =~ /gold/
    (amt.to_i * 1000)
  elsif denomination =~ /silver/
    (amt.to_i * 100)
  elsif denomination =~ /bronze/
    (amt.to_i * 10)
  else
    amt
  end
end

def convert2plats(copper)
  denominations = [[10_000, 'platinum'], [1000, 'gold'], [100, 'silver'], [10, 'bronze'], [1, 'copper']]
  denominations.inject([copper, []]) do |result, denomination|
    remaining = result.first
    display = result.last
    if remaining / denomination.first > 0
      display << "#{remaining / denomination.first} #{denomination.last}"
    end
    [remaining % denomination.first, display]
  end.last.join(', ')
end

def clean_and_split(room_objs)
  room_objs.sub(/You also see/, '').sub(/ with a [\w\s]+ sitting astride its back/, '').strip.split(/,|\sand\s/)
end

def find_pcs(room_players)
  room_players.sub(/ and (.*)$/) { ", #{Regexp.last_match(1)}" }
              .split(', ')
              .map { |obj| obj.sub(/ (who|whose body)? ?(has|is|appears|glows) .+/, '').sub(/ \(.+\)/, '') }
              .map { |obj| obj.strip.scan(/\w+$/).first }
end

def find_pcs_prone(room_players)
  room_players.sub(/ and (.*)$/) { ", #{Regexp.last_match(1)}" }
              .split(', ')
              .select { |obj| obj =~ /who is lying down/i }
              .map { |obj| obj.sub(/ who (has|is) .+/, '').sub(/ \(.+\)/, '') }
              .map { |obj| obj.strip.scan(/\w+$/).first }
end

def find_pcs_sitting(room_players)
  room_players.sub(/ and (.*)$/) { ", #{Regexp.last_match(1)}" }
              .split(', ')
              .select { |obj| obj =~ /who is sitting/i }
              .map { |obj| obj.sub(/ who (has|is) .+/, '').sub(/ \(.+\)/, '') }
              .map { |obj| obj.strip.scan(/\w+$/).first }
end

def find_npcs(room_objs)
  room_objs.sub(/You also see/, '').sub(/ with a [\w\s]+ sitting astride its back/, '').strip
           .scan(%r{<pushBold/>[^<>]*<popBold/> which appears dead|<pushBold/>[^<>]*<popBold/> \(dead\)|<pushBold/>[^<>]*<popBold/>})
           .reject { |obj| obj =~ /which appears dead|\(dead\)/ }
           .map { |obj| obj.sub(/.*alfar warrior.*/, 'alfar warrior') }
           .map { |obj| obj.sub(/.*sinewy leopard.*/, 'sinewy leopard') }
           .map { |obj| obj.sub('<pushBold/>', '').sub(%r{<popBold/>.*}, '') }
           .map { |obj| obj.split(/\sand\s/).last.sub(/(?:\sglowing)?\swith\s.*/, '') }
           .map { |obj| obj.strip.scan(/[A-z'-]+$/).first }
end

def find_dead_npcs(room_objs)
  room_objs.sub(/You also see/, '').sub(/ with a [\w\s]+ sitting astride its back/, '')
           .strip.scan(%r{<pushBold/>[^<>]*<popBold/> which appears dead|<pushBold/>[^<>]*<popBold/> \(dead\)|<pushBold/>[^<>]*<popBold/>})
           .select { |obj| obj =~ /which appears dead|\(dead\)/ }
           .map { |obj| obj.sub('<pushBold/>', '').sub(%r{<popBold/>.*}, '') }
           .map { |obj| obj.split(/\sand\s/).last.sub(/(?:\sglowing)?\swith\s.*/, '') }
           .map { |obj| obj.strip.scan(/[A-z'-]+$/).first }
end

def find_objects(room_objs)
  room_objs.sub!("<pushBold/>a domesticated gelapod<popBold/>", 'domesticated gelapod')
  clean_and_split(room_objs)
    .reject { |obj| obj =~ /pushBold/ }
    .map { |obj| obj.sub(/\.$/, '').strip.sub(/^a /, '').strip.sub(/^some /, '') }
end

sleep(0.1) until Char.name && !Char.name.empty?
CharSettings['bank_accounts'] = {} unless CharSettings['bank_accounts'].class == Hash
CharSettings['vault_info'] = {} unless CharSettings['vault_info'].class == Hash

kronar_banks = ['Crossings', 'Dirge', 'Ilaya Taipa', 'Leth Deriel']
lirum_banks = ["Aesry Surlaenis'a", "Hara'jaal", "Mer'Kresh", "Muspar'i", "Ratha", "Riverhaven", "Rossman's Landing", "Therenborough", "Throne City"]
dokora_banks = ["Ain Ghazal", "Boar Clan", "Chyolvea Tayeu'a", "Hibarnhvidar", "Fang Cove", "Raven's Point", "Shard"]

bank_titles = {
  "Aesry Surlaenis'a" => ["[[Tona Kertigen, Deposit Window]]"],
  "Ain Ghazal"        => ["[[Ain Ghazal, Private Depository]]"],
  "Boar Clan"         => ["[[Ranger Guild, Bank]]"],
  "Chyolvea Tayeu'a"  => ["[[Chyolvea Tayeu'a, Teller]]"],
  "Crossings"         => ["[[Provincial Bank, Teller]]"],
  "Dirge"             => ["[[Dirge, Traveller's Bank]]"],
  "Fang Cove"         => ["[[First Council Banking, Vault]]"],
  "Hara'jaal"         => ["[[Baron's Forset, Teller]]"],
  "Hibarnhvidar"      => ["[[Second Provincial Bank of Hibarnhvidar, Teller]]", "[[Hibarnhvidar, Teller Windows]]", "[[First Arachnid Bank, Lobby]]"],
  "Ilaya Taipa"       => ["[[Ilaya Taipa, Trader Outpost Bank]]"],
  "Leth Deriel"       => ["[[Imperial Depository, Domestic Branch]]"],
  "Mer'Kresh"         => ["[[Harti Clemois Bank, Teller's Window]]"],
  "Muspar'i"          => ["[[Old Lata'arna Keep, Teller Windows]]"],
  "Ratha"             => ["[[Lower Bank of Ratha, Cashier]]", "[[Sshoi-sson Palace, Grand Provincial Bank, Bursarium]]"],
  "Raven's Point"     => ["[[Bank of Raven's Point, Depository]]"],
  "Riverhaven"        => ["[[Bank of Riverhaven, Teller]]"],
  "Rossman's Landing" => ["[[Traders' Guild Outpost, Depository]]"],
  "Shard"             => ["[[First Bank of Ilithi, Teller's Windows]]"],
  "Therenborough"     => ["[[Bank of Therenborough, Teller]]"],
  "Throne City"       => ["[[Faldesu Exchequer, Teller]]"]
}

vault_titles = {
  "Crossings"     => ["[[Crossing, Carousel Chamber]]"],
  "Fang Cove"     => ["[[Fang Cove, Carousel Chamber]]"],
  "Leth Deriel"   => ["[[Leth Deriel, Carousel Chamber]]"],
  "Mer'Kresh"     => ["[[Mer'Kresh, Carousel Square]]"],
  "Muspar'i"      => ["[[Muspar'i, Carousel Square]]"],
  "Ratha"         => ["[[Ratha, Carousel Square]]"],
  "Riverhaven"    => ["[[Riverhaven, Carousel Chamber]]"],
  "Shard"         => ["[[Shard, Carousel Chamber]]"],
  "Therenborough" => ["[[Therenborough, Carousel Chamber]]"]
}

# Register ;banks ;vault commands
drinfomon_upstream_hook = proc do |client_string|
  if client_string =~ /^(?:<c>)?#{$clean_lich_char}((?:banks|vault).*)/i
    if (scr = Script.running.find { |val| val.name == 'drinfomon' })
      scr.downstream_buffer.shove("#{$clean_lich_char}#{Regexp.last_match(1)}") # if this script is still running send the command
    else
      UpstreamHook.remove('drinfomon') # if the script isnt running remove the hook
    end
    nil # its a command that shouldnt be sent to the game
  else
    client_string # didnt find a command we should watch for send the string as normal
  end
end

# For parsing `info` output
parsing_info_output = false
squelch_info_output = false

# For parsing `ltb info` output
parsing_ltb_info_output = false
squelch_ltb_info_output = false

# For parsing `played` output
parsing_played_output = false
squelch_played_output = false

# For parsing `exp all` output
parsing_exp_output = false
squelch_exp_output = false

# For parsing `exp mods` output
parsing_exp_mods_output = false
squelch_exp_mods_output = false

# How long to wait between info/exp checks.
drinfomon_passive_delay = get_settings.drinfomon_passive_delay

# To track when the last time was we checked experience/info.
info_check_interval = drinfomon_passive_delay
info_check_time = Time.now

# Experience learning rates in order from 0/34 to 34/34
learning_rates = [
  'clear',
  'dabbling',
  'perusing',
  'learning',
  'thoughtful',
  'thinking',
  'considering',
  'pondering',
  'ruminating',
  'concentrating',
  'attentive',
  'deliberative',
  'interested',
  'examining',
  'understanding',
  'absorbing',
  'intrigued',
  'scrutinizing',
  'analyzing',
  'studious',
  'focused',
  'very focused',
  'engaged',
  'very engaged',
  'cogitating',
  'fascinated',
  'captivated',
  'engrossed',
  'riveted',
  'very riveted',
  'rapt',
  'very rapt',
  'enthralled',
  'nearly locked',
  'mind lock'
]

# We use this to right pad learning rate names when formatting
# the output to show gained ranks in the experience window in Wrayth/StormFront.
# This variable tells us how wide to make the column.
longest_learning_rate_length = learning_rates.sort_by(&:length).last.length

# Balance levels in order from 0/11 to 11/11
balance_values = [
  'completely',
  'hopelessly',
  'extremely',
  'very badly',
  'badly',
  'somewhat off',
  'off',
  'slightly off',
  'solidly',
  'nimbly',
  'adeptly',
  'incredibly'
]

# This hook parses `exp all` to track your experience.
#
# Sample XML:
#
# Note, depending on your frontend and possibly other settings,
# the <component> tags may include <preset> tags.
# The examples below show both variants.
#
# FLAG BRIEFEXP ON
regex_flag_briefexp_on = %r{<component id='exp .*?<d cmd='skill (?<skill>[a-zA-Z\s]+)'.*:\s+(?<rank>\d+)\s+(?<percent>\d+)%\s*\[\s?(?<rate>\d+)\/34\].*?<\/component>}
# <component id='exp Augmentation'><preset id='whisper'><d cmd='skill Augmentation'>     Aug</d>:  565 39%  [ 2/34]</preset></component>
# <component id='exp Utility'><d cmd='skill Utility'>    Util</d>:  562 56%  [ 3/34]</component>
# ---
# FLAG BRIEFEXP OFF
regex_flag_briefexp_off = %r{<component id='exp .*?\b(?<skill>[a-zA-Z\s]+)\b:\s+(?<rank>\d+)\s+(?<percent>\d+)%\s+\b(?<rate>[a-zA-Z\s]+)\b.*?<\/component>}
# <component id='exp Augmentation'><preset id='whisper'>    Augmentation:  565 39% learning     </preset></component>
# <component id='exp Utility'>         Utility:  562 57% learning     </component>
# ---
# Empty mindstate
regex_exp_clear_mindstate = %r{<component id='exp (?<skill>[a-zA-Z\s]+)'><\/component>}
# <component id='exp Augmentation'></component>
# ---
# EXP ALL
regex_exp_columns = /(?:\s*(?<skill>[a-zA-Z\s]+)\b:\s*(?<rank>\d+)\s+(?<percent>\d+)%\s+(?<rate>[a-zA-Z\s]+)\b)/
# <output class="mono"/>
# Circle: 80
# Showing all skills that you have skill in.
#
#           SKILL: Rank/Percent towards next rank/Amount learning/Mindstate Fraction
#      Shield Usage:    292 31% clear          (0/34)     Light Armor:    288 30% clear          (0/34)
#       Chain Armor:    289 77% clear          (0/34)      Brigandine:    231 58% clear          (0/34)
#       Plate Armor:    206 32% clear          (0/34)       Defending:    294 68% clear          (0/34)
#     Parry Ability:    310 19% clear          (0/34)     Small Edged:    317 46% clear          (0/34)
#       Large Edged:    295 03% clear          (0/34) Twohanded Edged:    299 00% clear          (0/34)
#       Small Blunt:    308 20% clear          (0/34)     Large Blunt:    299 83% clear          (0/34)
#   Twohanded Blunt:    295 36% clear          (0/34)          Slings:    298 36% clear          (0/34)
#               Bow:    298 53% clear          (0/34)        Crossbow:    296 69% ruminating     (8/34)
#            Staves:    288 58% thinking       (5/34)        Polearms:    285 08% clear          (0/34)
#      Light Thrown:    286 62% clear          (0/34)    Heavy Thrown:    297 24% clear          (0/34)
#          Brawling:    287 45% clear          (0/34)  Offhand Weapon:    305 59% clear          (0/34)
#     Melee Mastery:    401 95% clear          (0/34) Missile Mastery:    376 32% clear          (0/34)
#       Inner Magic:    569 68% thinking       (5/34)          Arcana:    431 54% engrossed     (27/34)
#      Augmentation:    565 39% thinking       (5/34)    Debilitation:    325 76% clear          (0/34)
#           Utility:    562 57% thoughtful     (4/34)         Warding:    436 62% learning       (3/34)
#           Evasion:    364 49% clear          (0/34)       Athletics:    499 10% clear          (0/34)
#        Perception:    425 25% clear          (0/34)         Stealth:    651 83% clear          (0/34)
#      Locksmithing:    547 06% clear          (0/34)        Thievery:    650 86% interested    (12/34)
#         First Aid:    423 60% clear          (0/34) Outdoorsmanship:    375 03% clear          (0/34)
#          Skinning:    426 71% clear          (0/34)        Backstab:    361 96% clear          (0/34)
#           Forging:    136 30% learning       (3/34)     Engineering:    131 96% clear          (0/34)
#        Outfitting:    135 62% clear          (0/34)         Alchemy:    134 53% clear          (0/34)
#        Enchanting:    129 82% clear          (0/34)     Scholarship:    429 58% clear          (0/34)
#         Appraisal:    491 82% clear          (0/34)     Performance:    373 14% clear          (0/34)
#           Tactics:    325 63% clear          (0/34)
#
# Total Ranks Displayed: 17032
# Time Development Points: 12  Favors: 10  Deaths: 1  Departs: 1
# Rested EXP Stored: 4:25 hours  Usable This Cycle: 3:57 hours  Cycle Refreshes: 1:11 hour
# Overall state of mind: clear
# EXP HELP for more information
# <output class=""/>
# ---
exp_hook = proc do |server_string|
  # Due to non-thread safe issues with Ruby, Regexp.last_match, and procs,
  # explicit match variables are defined and used instead.
  # https://github.com/psu-libraries/psulib_traject/issues/132
  # https://github.com/traject/traject/issues/139
  match_briefexp_on         = regex_flag_briefexp_on.match(server_string)
  match_briefexp_off        = regex_flag_briefexp_off.match(server_string)
  match_exp_clear_mindstate = regex_exp_clear_mindstate.match(server_string)

  # These sections are parsing xml tags sent to experience window.
  # The game sends these tags automatically and we don't need
  # to conditionally parse them based on value of `parsing_exp_output`.
  if match_briefexp_on
    skill = match_briefexp_on[:skill]
    rank = match_briefexp_on[:rank]
    rate = match_briefexp_on[:rate] # already a number
    percent = match_briefexp_on[:percent]
    DRSkill.update(skill, rank, rate, percent)
    # Show to the right of the experience learning rate the gained ranks this session.
    if UserVars.track_exp || UserVars.track_exp.nil?
      # Historically, this feature to show gained exp was on by default
      # and could be turned off by setting `UserVars.track_exp = false`.
      # As of February 2022, we want features to be opt-in to minimize
      # impact to players who don't want Lich to change out from under them.
      # To get to that point with this feature, we need to correct the data
      # and set to true if it was already nil. In a subsequent update we'll
      # change the IF condition to only run if `UserVars.track_exp` is true
      # as well as remove this comment block and the initialization assignment.
      UserVars.track_exp ||= true
      server_string.sub!(/(\/34\])/, "\\1 #{sprintf('%0.2f', DRSkill.gained_exp(skill))}")
    end
  elsif match_briefexp_off
    skill = match_briefexp_off[:skill]
    rank = match_briefexp_off[:rank]
    rate_word = match_briefexp_off[:rate]
    rate = learning_rates.index(rate_word) # convert word to number
    percent = match_briefexp_off[:percent]
    DRSkill.update(skill, rank, rate, percent)
    # Show to the right of the experience learning rate the gained ranks this session.
    if UserVars.track_exp
      server_string.sub!(/(%\s+)(#{rate_word})/, "\\1 #{rate_word.ljust(longest_learning_rate_length)} #{sprintf('%0.2f', DRSkill.gained_exp(skill))}")
    end
  elsif match_exp_clear_mindstate
    skill = match_exp_clear_mindstate[:skill]
    DRSkill.clear_mind(skill)
  end

  case server_string
  when /^(Circle: (\d+)|Showing all skills that you have skill in)/
    parsing_exp_output = true
  when regex_exp_columns
    if parsing_exp_output
      server_string.scan(regex_exp_columns) do |skill_value, rank_value, percent_value, rate_as_word|
        rate_as_number = learning_rates.index(rate_as_word) # convert word to number
        DRSkill.update(skill_value, rank_value, rate_as_number, percent_value)
      end
    end
  when /^EXP HELP for more information/
    if parsing_exp_output && squelch_exp_output
      server_string = nil
    end
    if parsing_exp_output
      parsing_exp_output = false
      squelch_exp_output = false
    end
  when %r{^<output class=""/>}
    # This signals the end of `exp all` but
    # don't squelch this line because the frontends (e.g. Genie)
    # need it to properly close out parsing the mono font.
    if parsing_exp_output
      parsing_exp_output = false
      squelch_exp_output = false
      # Don't remove the `exp all` hook here, leave it active.
      # It's designed to parse the continuous stream of exp pulses.
    end
  end

  if parsing_exp_output && squelch_exp_output
    server_string = nil
  end
  server_string
end

# This hook parses `exp mods` to track your exp buffs or curses.
#
# Sample XML:
#
# Note, "speech" presets are positive modifiers and use one `+` plus sign.
# and "thought" presets are negative modifiers and use two `-` minus signs.
# Note, sometimes the phrase "The following skills..." is prefixed with another xml tag.
# ---
# The following skills are currently under the influence of a modifier:
# <output class="mono"/>
# <preset id="speech">+78 Athletics</preset>
# <preset id="speech">+84 Perception</preset>
# <preset id="thought">--11 First Aid</preset>
# <output class=""/>
# ---
# The following skills are currently under the influence of a modifier:
# <output class="mono"/>
#   None
# <output class=""/>
# ---
exp_mods_hook = proc do |server_string|
  case server_string
  when /^(<.*?\/>)?The following skills are currently under the influence of a modifier/
    parsing_exp_mods_output = true
    DRSkill.exp_modifiers.clear
  when %r{^<preset id="speech">}, %r{^<preset id="thought">}
    if parsing_exp_mods_output
      match = /(?<sign>\+|\-)+(?<value>\d+) \b(?<skill>[\w\s]+)\b/.match(server_string)
      if match
        skill = match[:skill]
        sign = match[:sign]
        value = match[:value].to_i
        value = (value * -1) if sign == '-'
        DRSkill.update_mods(skill, value)
      end
    end
  when %r{^<output class=""/>}
    # This signals the end of `exp mods` but
    # don't squelch this line because the frontends (e.g. Genie)
    # need it to properly close out parsing the mono font.
    if parsing_exp_mods_output
      parsing_exp_mods_output = false
      squelch_exp_mods_output = false
      # We've parsed what we need, remove this hook for performance.
      DownstreamHook.remove('exp_mods_hook')
    end
  end

  if parsing_exp_mods_output && squelch_exp_mods_output
    server_string = nil
  end
  server_string
end

# This hook parses `info` to track your stats.
#
# Sample XML:
#
# ---
# <output class="mono"/>
# Name: Agonar Dokona   Race: Human   Guild: Barbarian
# Gender: Male   Age: 44   Circle: 80
# You were born on the 36th day of the 3rd month of Lirisa the Archer in the year of the Iron Toad, 396 years after the victory of Lanival the Redeemer.
#
# Your birthday is more than 4 months away.
#
# <preset id="speech">     Strength :  50 +10</preset>       Reflex :  62
#       Agility :  62            Charisma :  27
#    Discipline :  46              Wisdom :  46
#  Intelligence :  46             Stamina :  50
#
# Concentration : 428    Max : 428
#
#        Favors : 40
#          TDPs : 438
#   Encumbrance : None (0/11)
#          Luck : Average (0/3)
#
# Wealth:
#   No Kronars.
#   No Lirums.
#   No Dokoras.
#
# Debt:
#   No debt.
#
# You and XXX affirmed your vows before the gods in the 1st month of Akroeg the Ram in the year of the Emerald Dolphin, 439.
#   PIRP Points : XX
#
# You have 1 active purchase:
#   HEALME Usage, charges remaining: 5
# <output class=""/>
# ---
regex_info_name_race_guild = /^Name:\s+\b(?<name>.+)\b\s+Race:\s+\b(?<race>.+)\b\s+Guild:\s+\b(?<guild>.+)\b\s+/
regex_info_gender_age_circle = /^Gender:\s+\b(?<gender>.+)\b\s+Age:\s+\b(?<age>.+)\b\s+Circle:\s+\b(?<circle>.+)/
# Note, in the following regex do not capture 'Concentration' because you'll get your literal amount available, like 419,
# but what our scripts operate on is the percentage which comes through as an xml tag parsed by the `status_hook`.
regex_info_stat_value = /(?<stat>Strength|Agility|Discipline|Intelligence|Reflex|Charisma|Wisdom|Stamina|Favors|TDPs)\s+:\s+(?<value>\d+)/
regex_info_encumbrance = /^\s*Encumbrance\s+:\s+(?<encumbrance>[\w\s'?!]+)$/
regex_info_balance = /^(?:You are|\[You're) (?<balance>#{Regexp.union(balance_values)}) balanced?/
# ---
info_hook = proc do |server_string|
  # Due to non-thread safe issues with Ruby, Regexp.last_match, and procs,
  # explicit match variables are defined and used instead.
  # https://github.com/psu-libraries/psulib_traject/issues/132
  # https://github.com/traject/traject/issues/139
  match_info_name_race_guild   = regex_info_name_race_guild.match(server_string)
  match_info_gender_age_circle = regex_info_gender_age_circle.match(server_string)
  match_info_stat_value        = regex_info_stat_value.match(server_string)
  match_info_encumbrance       = regex_info_encumbrance.match(server_string)

  if match_info_name_race_guild
    parsing_info_output = true
    if parsing_info_output
      DRStats.race = match_info_name_race_guild[:race]
      DRStats.guild = match_info_name_race_guild[:guild]
    end
  elsif match_info_gender_age_circle
    if parsing_info_output
      DRStats.gender = match_info_gender_age_circle[:gender]
      DRStats.age = match_info_gender_age_circle[:age].to_i
      DRStats.circle = match_info_gender_age_circle[:circle].to_i
    end
  elsif match_info_stat_value
    if parsing_info_output
      server_string.scan(regex_info_stat_value) do |stat, value|
        DRStats.send("#{stat.downcase}=", value.to_i)
      end
    end
  elsif match_info_encumbrance
    if parsing_info_output
      DRStats.encumbrance = match_info_encumbrance[:encumbrance]
    end
  end

  case server_string
  when %r{^<output class=""/>}
    # This signals the end of `info` but
    # don't squelch this line because the frontends (e.g. Genie)
    # need it to properly close out parsing the mono font.
    if parsing_info_output
      parsing_info_output = false
      squelch_info_output = false
      # Don't remove the `info` hook here, leave it active.
      # It's designed to parse the data anytime `info` command runs.
    end
  end

  if parsing_info_output && squelch_info_output
    server_string = nil
  end
  server_string
end

# This hook parses `ltb info` to determine your premium benefits.
#
# Note, if you were premium but now aren't then `played` may still
# show your account subscription level as premium (ugh).
#
# Sample XML:
#
# ---
# As of your last logon:
#   Your premium service has been<pushBold/> continuous (consecutive)<popBold/> since 10/14/2021.
#   You have a cumulative Premium time of 18 months.
#   You have a cumulative Platinum time of 5 months.
#
#   Premium Points Earned: 1800
#    Platinum Points Earned: 500
#       Total Points Earned: 2300
#
#       Total Points Spent: 900
#
#  Unfinished Scroll Points: 0
# Available Points to Spend: 1400
#
# For more information on LTBs, please check <d cmd="PREMIUM 7">PREMIUM 7</d>.
# ---
# You are not currently a Premium or Platinum subscriber.  Join today to take to advantage of the benfits!
# Premium: http://www.play.net/dr/premium/
# Platinum: http://www.play.net/dr/platinum/
# You have a cumulative Premium time of 11 months.
# ---
ltb_info_hook = proc do |server_string|
  case server_string
  when /^As of your last logon:/, /^You are not currently/
    parsing_ltb_info_output = true
    # This needs to be the string 'true' or 'false', not the boolean
    # because it's used in the map.json like `UserVars.premium == 'true'`.
    # So, right or wrong, the path of least resistance is to just
    # set the variable to a string here even if you think it should be boolean.
    #
    # Special case, The Fallen is considered premium because they have
    # access to Fang Cove and in order for maps.json paths to use Fang Cove
    # then you need this variable set.
    UserVars.premium = (XMLData.game == 'DRF').to_s
  when /Your premium service has been/
    if parsing_ltb_info_output
      UserVars.premium = 'true'
    end
  when /^For more information on LTBs/
    if parsing_ltb_info_output && squelch_ltb_info_output
      server_string = nil
    end
    if parsing_ltb_info_output
      parsing_ltb_info_output = false
      squelch_ltb_info_output = false
      # We've parsed what we need, remove this hook for performance.
      DownstreamHook.remove('ltb_info_hook')
    end
  end

  if parsing_ltb_info_output && squelch_ltb_info_output
    server_string = nil
  end
  server_string
end

# This hook parses `played` to determine your subscription level.
#
# Sample XML:
#
# Note, sometimes the phrase "Account Info for..." is prefixed with another xml tag.
# ---
# Account Info for AGONAR:
#   Current Account Status: Premium
#         Basic Start Date: 11/14/2021
#             Basic Months: 34
#       Premium Start Date: 10/14/2021
#           Premium Months: 18
#      Platinum Start Date: --/--/----
#          Platinum Months: 5
#
# Start dates reflect the most recent date of subscription.
# # of months are your cumulative totals over the course of the account's life.
# Date formats are MM/DD/YYYY.
#
# <pushBold/>Note: In-game staff has no control over these dates or totals.  It's information populated automatically at login.
# <popBold/><prompt time="1644375066">&gt;</prompt>
# ---
played_hook = proc do |server_string|
  case server_string
  when /^(?:<.*?\/>)?Account Info for (?<account>\w+):/
    parsing_played_output = true
    UserVars.account = Regexp.last_match[:account]
  when /Current Account Status: (?<subscription>\w+)/
    if parsing_played_output
      subscription = Regexp.last_match[:subscription]
      UserVars.subscription = subscription
    end
  when /In-game staff has no control over these dates or totals/
    if parsing_played_output && squelch_played_output
      server_string = nil
    end
    if parsing_played_output
      parsing_played_output = false
      squelch_played_output = false
      # We've parsed what we need, remove this hook for performance.
      DownstreamHook.remove('played_hook')
    end
  end

  if parsing_played_output && squelch_played_output
    server_string = nil
  end
  server_string
end

# Monitors for periodic status updates (health, mana, fatigue, spirit)
# and changes to pcs or npcs in the room.
status_hook = proc do |server_string|
  if server_string =~ /<progressBar id='mana' value='(\d+)'/
    DRStats.mana = Regexp.last_match(1).to_i
  elsif server_string =~ /<progressBar id='stamina' value='(\d+)'/
    DRStats.fatigue = Regexp.last_match(1).to_i
  elsif server_string =~ /<progressBar id='health' value='(\d+)'/
    DRStats.health = Regexp.last_match(1).to_i
  elsif server_string =~ /<progressBar id='concentration' value='(\d+)'/
    DRStats.concentration = Regexp.last_match(1).to_i
  elsif server_string =~ /<progressBar id='spirit' value='(\d+)'/
    DRStats.spirit = Regexp.last_match(1).to_i
  elsif server_string =~ %r{\'room players\'>Also here: (.*)\.</component>}
    DRRoom.pcs = find_pcs(Regexp.last_match(1).dup)
    DRRoom.pcs_prone = find_pcs_prone(Regexp.last_match(1).dup)
    DRRoom.pcs_sitting = find_pcs_sitting(Regexp.last_match(1).dup)
  elsif server_string =~ %r{\'room players\'></component>}
    DRRoom.pcs = []
  elsif server_string =~ %r{\'room objs\'>(.*)</component>}
    DRRoom.npcs = find_npcs(Regexp.last_match(1).dup)
    UserVars.npcs = DRRoom.npcs
    DRRoom.dead_npcs = find_dead_npcs(Regexp.last_match(1).dup)
    DRRoom.room_objs = find_objects(Regexp.last_match(1).dup)
  elsif server_string =~ %r{\'room objs\'></component>}
    DRRoom.npcs = []
    DRRoom.dead_npcs = []
    DRRoom.room_objs = []
  elsif server_string =~ %r{<pushStream id="group"/>Members of your group:}
    DRRoom.group_members = []
  elsif server_string =~ %r{<pushStream id="group"/>  (\w+):}
    DRRoom.group_members << Regexp.last_match(1)
  elsif server_string =~ /Obvious exits:/ || server_string =~ /Obvious paths:/
    exit_string = server_string.gsub('<d>', '').gsub('</d>', '').gsub('Obvious exits: ', '').gsub('Obvious paths: ', '').delete('.').gsub("\r\n", '')
    DRRoom.exits = exit_string.split(', ') - ['none']
  end
  DRRoom.title = XMLData.room_title
  DRRoom.description = XMLData.room_description.strip
  server_string
end

# Invoking `CharSettings` from a downstream hook (proc)
# will cause lich.rbw to print "--- error: Settings: unknown calling script".
# As workaround, the serialization from DRStats to settings will be
# part of the save proc that's run every few minutes.
save_settings_proc = proc do
  CharSettings['Stats'] = DRStats.serialize
  CharSettings.save
end

# Save current status every five minutes in case of crash.
Thread.new do
  begin
    loop do
      sleep 300
      save_settings_proc.call
    end
  rescue
    echo $ERROR_INFO
    echo $ERROR_INFO.backtrace[0..1]
  end
end

before_dying do
  save_settings_proc.call
  UpstreamHook.remove('drinfomon')
  DownstreamHook.remove('exp_hook')
  DownstreamHook.remove('exp_mods_hook')
  DownstreamHook.remove('info_hook')
  DownstreamHook.remove('ltb_info_hook')
  DownstreamHook.remove('played_hook')
  DownstreamHook.remove('status_hook')
  Object.send(:remove_const, :DRINFOMON) if Object.const_defined?(:DRINFOMON)
end

UpstreamHook.add('drinfomon', drinfomon_upstream_hook)
DownstreamHook.add('exp_hook', exp_hook)
DownstreamHook.add('exp_mods_hook', exp_mods_hook)
DownstreamHook.add('info_hook', info_hook)
DownstreamHook.add('ltb_info_hook', ltb_info_hook)
DownstreamHook.add('played_hook', played_hook)
DownstreamHook.add('status_hook', status_hook)

# Now silence any commands the script is running
# to reduce spam to the player. We don't do this at top of script
# because not everything is easily squelched so it ends up looking
# like random output shown to screen but no clues to the user as to why.
# Waiting until now to silence the script avoids that ambiguity.
silence_me

# Checks `info`, squelching the output to the user.
# A downstream hook defined above parses the data.
check_info = proc do
  DownstreamHook.add('info_hook', info_hook)
  squelch_info_output = !UserVars.drinfomon_debug
  fput('info')
end

# Designed to be called by other scripts
# that want `info` to be parsed.
# We use this method because it has access to
# set the squelch variable to reduce spamming the player.
define_singleton_method(:check_info) do
  check_info.call
end

# Checks `ltb info`, squelching the output to the user.
# A downstream hook defined above parses the data.
check_ltb_info = proc do
  DownstreamHook.add('ltb_info_hook', ltb_info_hook)
  squelch_ltb_info_output = !UserVars.drinfomon_debug
  fput('ltb info')
end

# Designed to be called by other scripts
# that want `ltb info` to be parsed.
# We use this method because it has access to
# set the squelch variable to reduce spamming the player.
define_singleton_method(:check_ltb_info) do
  check_ltb_info.call
end

# Checks `played`, squelching the output to the user.
# A downstream hook defined above parses the data.
check_played = proc do
  DownstreamHook.add('played_hook', played_hook)
  squelch_played_output = !UserVars.drinfomon_debug
  fput('played')
end

# Designed to be called by other scripts
# that want `played` to be parsed.
# We use this method because it has access to
# set the squelch variable to reduce spamming the player.
define_singleton_method(:check_played) do
  check_played.call
end

# Checks `exp all`, squelching the output to the user.
# A downstream hook defined above parses the data.
check_exp_all = proc do
  DownstreamHook.add('exp_hook', exp_hook)
  squelch_exp_output = !UserVars.drinfomon_debug
  fput('exp all')
end

# Designed to be called by other scripts
# that want `exp all` to be parsed.
# We use this method because it has access to
# set the squelch variable to reduce spamming the player.
define_singleton_method(:check_exp_all) do
  check_exp_all.call
end

# Checks `exp mods`, squelching the output to the user.
# A downstream hook defined above parses the data.
check_exp_mods = proc do
  DownstreamHook.add('exp_mods_hook', exp_mods_hook)
  squelch_exp_mods_output = !UserVars.drinfomon_debug
  fput('exp mods')
end

# Designed to be called by other scripts
# that want `exp mods` to be parsed to learn
# current buffs/curses affecting effective ranks.
# We use this method because it has access to
# set the squelch variable to reduce spamming the player.
# For example, `skill-recorder` script.
define_singleton_method(:check_exp_mods) do
  check_exp_mods.call
end

# Now call our procs to do an initial parsing
# of the character's info, experience, and subscritpion level.
# However, don't call `check_exp_mods` here; that's handled by `skill-recorder` script.
check_info.call unless dead?
check_ltb_info.call
check_played.call
check_exp_all.call

# Wait for exp/info to have been parsed before we continue
# otherwise scripts that rely on this data will error.
pause 0.05 while DRSkill.list.empty?
# Note, while dead we cannot check your info, so we skip in that scenario.
# If you're alive, we wait til a reasonable sample of info has been populated.
# Race and Guild represent the start of info lines, Favors and TDPs represent the end.
pause 0.05 while !dead? && (DRStats.race.nil? || DRStats.guild.nil? || DRStats.favors.nil? || DRStats.tdps.nil?)
# Formally signal that we've loaded so that other scripts can start.
# See `bootstrap` script for more details about the constants logic.
Object.const_set(:DRINFOMON, true) unless constant_defined?(:DRINFOMON)

# Start loop to process incoming data.
while (line = script.gets)
  begin
    if line =~ /^\* Log-on system converted \d+% of your character/
      check_exp_all.call
    elsif line =~ /^#{$clean_lich_char}banks$/
      if CharSettings['bank_accounts'].empty?
        respond
        respond 'No bank account info recorded.'
        respond
      else
        respond
        CharSettings['bank_accounts'].each do |town, amount|
          respond "#{town.rjust(27)}: #{amount.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.rjust(13)}" + ' or ' + convert2plats(amount).to_s
        end
        respond '              ------------------------------------------------------------------------------------------'
        total = 0
        kronar_banks
          .select { |city| CharSettings['bank_accounts'][city] }
          .each { |city| total += CharSettings['bank_accounts'].fetch(city) }
        respond "               Kronar Total: #{total.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.rjust(13)}" + ' or ' + convert2plats(total).to_s
        total = 0
        lirum_banks
          .select { |city| CharSettings['bank_accounts'][city] }
          .each { |city| total += CharSettings['bank_accounts'].fetch(city) }
        respond "                Lirum Total: #{total.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.rjust(13)}" + ' or ' + convert2plats(total).to_s
        total = 0
        dokora_banks
          .select { |city| CharSettings['bank_accounts'][city] }
          .each { |city| total += CharSettings['bank_accounts'].fetch(city) }
        respond "               Dokora Total: #{total.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.rjust(13)}" + ' or ' + convert2plats(total).to_s
      end
    elsif line =~ /^#{$clean_lich_char}vault$/
      respond
      if CharSettings['vault_info'].empty?
        respond 'No vault info recorded.'
      else
        respond "          Your vault is located in #{CharSettings['vault_info']['location']}"
        respond "          ---------------------------------------"
        respond "          #{CharSettings['vault_info']['contents']}"
      end
      respond
    elsif line =~ /(?:In the secure vault you see|You rummage through a secure vault and see)\s(.*)\./
      vault_titles
        .select { |_town, titles| titles.include?(checkroom) }
        .each do |town, _titles|
          contents = Regexp.last_match(1)
          line.scan(/a.*?(?<furniture>\w+ \w+) with some stuff (?<location>\w+) it/).each do |furniture, location|
            fput "look #{location} #{furniture}"
            if get =~ /#{location} the #{furniture} you see(.*)\./i
              contents += ',' + Regexp.last_match(1).sub(/ and(.*)/, ',\1')
            end
          end
          CharSettings['vault_info']['location'] = town
          CharSettings['vault_info']['contents'] = contents.sub(/,$/, '')
        end
    elsif line =~ /^Circle: (\d+)/
      DRStats.circle = Regexp.last_match(1).to_i
      CharSettings['Stats'] = DRStats.serialize
    elsif line =~ regex_info_balance
      DRStats.balance = balance_values.index(Regexp.last_match[:balance])
      CharSettings['Stats'] = DRStats.serialize
    elsif line =~ regex_info_encumbrance
      DRStats.encumbrance = Regexp.last_match[:encumbrance]
      CharSettings['Stats'] = DRStats.serialize
    elsif line =~ /You have (\d+) TDPs\./
      DRStats.tdps = Regexp.last_match(1).to_i
      CharSettings['Stats'] = DRStats.serialize
    elsif line =~ /The clerk slides a small metal box across the counter into which you drop (\d+) (\w+) (?:Kronars|Lirums|Dokoras)/
      # you deposited a portion of your money
      bank_titles
        .find { |_town, titles| titles.include?(checkroom) }
        .each_key do |town|
          copper = convert2copper(Regexp.last_match(1).to_i, Regexp.last_match(2))
          CharSettings['bank_accounts'][town] = CharSettings['bank_accounts'][town].to_i + copper
        end
    elsif line =~ /^The clerk slides a small metal box across the counter into which you drop all your (?:Kronars|Lirums|Dokoras).  She counts them carefully and records the deposit in her ledger|You cross through the old balance on the label and update it to reflect your new balance/
      # you deposited all your money
      fput 'balance'
    elsif line =~ /(?:The clerk counts|You count) out ([0-9]+) (platinum|gold|silver|bronze|copper) (?:Kronars|Lirums|Dokoras) (?:and hands them over, making a notation in her ledger|and quickly pocket them, updating the notation on your jar)/
      # you withdrew some money
      bank_titles
        .find { |_town, titles| titles.include?(checkroom) }
        .each_key do |town|
          copper = convert2copper(Regexp.last_match(1).to_i, Regexp.last_match(2))
          CharSettings['bank_accounts'][town] = CharSettings['bank_accounts'][town].to_i - copper
        end
    elsif line =~ /(?:The clerk counts out all your|You count out all of your) (?:Kronars|Lirums|Dokoras) (?:and hands them over, making a notation in her ledger|and quickly pocket them)/
      # you withdrew all your money
      bank_titles.each do |town, titles|
        if titles.include?(checkroom)
          CharSettings['bank_accounts'][town] = 0
          break
        end
      end
    elsif line =~ /(?:(?:it looks like|\"Here we are.)\s[y]our current balance is|As expected, there are) (.*)\s(?:Kronars|Lirums|Dokoras)/i
      # you checked your balance
      copper = 0
      Regexp.last_match(1).each_line(', ') do |m|
        m.to_s
        a = m.match(/([0-9]+).[a-z]+/)
        copper += convert2copper(a.to_s.to_i, m)
      end
      bank_titles.each do |town, titles|
        if titles.include?(checkroom)
          CharSettings['bank_accounts'][town] = copper.to_i
          break
        end
      end
    elsif line =~ /you do not seem to have an account with us|you should find a new deposit jar for your financial needs/
      # you have no account
      bank_titles.each do |town, titles|
        if titles.include?(checkroom)
          CharSettings['bank_accounts'][town] = 0
          break
        end
      end
    end
    # If we don't know the character's guild yet, keep checking.
    # The polling interval reduces spamming commands while we wait
    # for your dead body to be resurrected so that we can run `info` again.
    if DRStats.guild.nil? && !dead? && (Time.now - info_check_time > info_check_interval)
      check_exp_all.call
      check_info.call
      info_check_time = Time.now
    end
  rescue
    echo $ERROR_INFO
    echo $ERROR_INFO.backtrace.first
    sleep 1
  end
end
