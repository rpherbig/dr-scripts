# quiet
=begin
  Documentation: https://elanthipedia.play.net/Lich_script_development#drinfomon
=end

no_kill_all
no_pause_all
# hide_me
setpriority(0)

class DRStats
  @@race = nil
  @@guild = nil
  @@gender = nil
  @@age ||= 0
  @@circle ||= 0
  @@strength ||= 0
  @@stamina ||= 0
  @@reflex ||= 0
  @@agility ||= 0
  @@intelligence ||= 0
  @@wisdom ||= 0
  @@discipline ||= 0
  @@charisma ||= 0
  @@concentration ||= 0
  @@favors ||= 0
  @@tdps ||= 0
  @@encumbrance = nil
  @@balance ||= 8
  @@health ||= 100
  @@mana ||= 100
  @@fatigue ||= 100
  @@spirit ||= 100

  def self.race
    @@race
  end

  def self.race=(val)
    @@race = val
  end

  def self.guild
    @@guild
  end

  def self.guild=(val)
    @@guild = val
  end

  def self.gender
    @@gender
  end

  def self.gender=(val)
    @@gender = val
  end

  def self.age
    @@age
  end

  def self.age=(val)
    @@age = val
  end

  def self.circle
    @@circle
  end

  def self.circle=(val)
    @@circle = val
  end

  def self.strength
    @@strength
  end

  def self.strength=(val)
    @@strength = val
  end

  def self.stamina
    @@stamina
  end

  def self.stamina=(val)
    @@stamina = val
  end

  def self.reflex
    @@reflex
  end

  def self.reflex=(val)
    @@reflex = val
  end

  def self.agility
    @@agility
  end

  def self.agility=(val)
    @@agility = val
  end

  def self.intelligence
    @@intelligence
  end

  def self.intelligence=(val)
    @@intelligence = val
  end

  def self.wisdom
    @@wisdom
  end

  def self.wisdom=(val)
    @@wisdom = val
  end

  def self.discipline
    @@discipline
  end

  def self.discipline=(val)
    @@discipline = val
  end

  def self.charisma
    @@charisma
  end

  def self.charisma=(val)
    @@charisma = val
  end

  def self.concentration
    @@concentration
  end

  def self.concentration=(val)
    @@concentration = val
  end

  def self.favors
    @@favors
  end

  def self.favors=(val)
    @@favors = val
  end

  def self.tdps
    @@tdps
  end

  def self.tdps=(val)
    @@tdps = val
  end

  def self.balance
    @@balance
  end

  def self.balance=(val)
    @@balance = val
  end

  def self.encumbrance
    @@encumbrance
  end

  def self.encumbrance=(val)
    @@encumbrance = val
  end

  def self.health
    @@health
  end

  def self.health=(val)
    @@health = val
  end

  def self.mana
    @@mana
  end

  def self.mana=(val)
    @@mana = val
  end

  def self.native_mana
    case DRStats.guild
    when 'Necromancer'
      'arcane'
    when 'Barbarian', 'Thief'
      nil
    when 'Moon Mage', 'Trader'
      'lunar'
    when 'Warrior Mage', 'Bard'
      'elemental'
    when 'Cleric', 'Paladin'
      'holy'
    when 'Empath', 'Ranger'
      'life'
    end
  end

  def self.fatigue
    @@fatigue
  end

  def self.fatigue=(val)
    @@fatigue = val
  end

  def self.spirit
    @@spirit
  end

  def self.spirit=(val)
    @@spirit = val
  end

  def self.serialize
    [@@race, @@guild, @@gender, @@age, @@circle, @@strength, @@stamina, @@reflex, @@agility, @@intelligence, @@wisdom, @@discipline, @@charisma, @@concentration, @@favors, @@tdps, @@encumbrance, @@health, @@mana, @@fatigue, @@spirit]
  end

  def self.load_serialized=(array)
    @@race, @@guild, @@gender, @@age = array[0..3]
    @@circle, @@strength, @@stamina, @@reflex, @@agility, @@intelligence, @@wisdom, @@discipline, @@charisma, @@concentration, @@favors, @@tdps, @@encumbrance, @@health, @@mana, @@fatigue, @@spirit = array[5..21]
  end

  def self.barbarian?
    @@guild == 'Barbarian'
  end

  def self.bard?
    @@guild == 'Bard'
  end

  def self.cleric?
    @@guild == 'Cleric'
  end

  def self.commoner?
    @@guild == 'Commoner'
  end

  def self.empath?
    @@guild == 'Empath'
  end

  def self.moon_mage?
    @@guild == 'Moon Mage'
  end

  def self.necromancer?
    @@guild == 'Necromancer'
  end

  def self.paladin?
    @@guild == 'Paladin'
  end

  def self.ranger?
    @@guild == 'Ranger'
  end

  def self.thief?
    @@guild == 'Thief'
  end

  def self.trader?
    @@guild == 'Trader'
  end

  def self.warrior_mage?
    @@guild == 'Warrior Mage'
  end
end

class DRSkill
  @@gained_skills ||= []
  @@start_time ||= Time.now
  @@list ||= []
  attr_reader :name, :rank, :exp, :percent, :current, :baseline
  attr_writer :rank, :exp, :percent, :current, :baseline
  def initialize(name, rank, exp, percent)
    # UserVars.athletics = ra.to_i if name == 'Athletics'
    @name = name
    @rank = rank
    @exp = exp
    @percent = percent
    @baseline = rank.to_i + (percent.to_i / 100.0)
    @current = rank.to_i + (percent.to_i / 100.0)
    @@list.push(self) unless @@list.find { |skill| skill.name == @name }
  end

  def self.reset
    @@gained_skills = []
    @@start_time = Time.now
    @@list.each { |skill| skill.baseline = skill.current }
  end

  def self.start_time
    @@start_time
  end

  def self.gained_skills
    @@gained_skills
  end

  def self.gained_exp(val)
    ary = @@list.collect(&:name)
    if i = ary.index(val)
      return @@list[i].current ? (@@list[i].current - @@list[i].baseline).round(2) : 0.00
    end
  end

  def self.include?(val)
    ary = @@list.collect(&:name)
    ary.include?(val)
  end

  def self.update(name, ra, xp, per)
    # UserVars.athletics = ra.to_i if name == 'Athletics'
    ary = @@list.collect(&:name)
    if i = ary.index(name)
      @@list[i].rank = ra
      @@list[i].exp = xp
      @@list[i].percent = per
      @@list[i].current = ra.to_i + (per.to_i / 100.0)
    end
  end

  def self.clear_mind(name)
    ary = @@list.collect(&:name)
    if i = ary.index(name)
      @@list[i].exp = 0
    end
  end

  def self.getrank(val)
    ary = @@list.collect(&:name)
    if i = ary.index(val)
      return @@list[i].rank.to_i
    end
    0
  end

  def self.getxp(val)
    ary = @@list.collect(&:name)
    return 34 if getrank(val) == 1750
    if i = ary.index(val)
      return @@list[i].exp.to_i
    end
    0
  end

  def self.getpercent(val)
    ary = @@list.collect(&:name)
    if i = ary.index(val)
      return @@list[i].percent
    end
  end

  def self.listall
    @@list.each do |i|
      puts i.name + ': ' + i.rank + '.' + i.percent + '% [' + i.exp + '/34] --'
    end
  end

  def self.list
    @@list
  end
end

class DRRoom
  @@npcs ||= []
  @@pcs ||= []
  @@group_members ||= []
  @@pcs_prone ||= []
  @@pcs_sitting ||= []
  @@dead_npcs ||= []
  @@room_objs ||= []
  @@exits ||= []
  @@title = ''
  @@description = ''

  def self.npcs
    @@npcs
  end

  def self.npcs=(val)
    @@npcs = val
  end

  def self.pcs
    @@pcs
  end

  def self.pcs=(val)
    @@pcs = val
  end

  def self.exits
    @@exits
  end

  def self.exits=(val)
    @@exits = val
  end

  def self.title
    @@title
  end

  def self.title=(val)
    @@title = val
  end

  def self.description
    @@description
  end

  def self.description=(val)
    @@description = val
  end

  def self.group_members
    @@group_members
  end

  def self.group_members=(val)
    @@group_members = val
  end

  def self.pcs_prone
    @@pcs_prone
  end

  def self.pcs_prone=(val)
    @@pcs_prone = val
  end

  def self.pcs_sitting
    @@pcs_sitting
  end

  def self.pcs_sitting=(val)
    @@pcs_sitting = val
  end

  def self.dead_npcs
    @@dead_npcs
  end

  def self.dead_npcs=(val)
    @@dead_npcs = val
  end

  def self.room_objs
    @@room_objs
  end

  def self.room_objs=(val)
    @@room_objs = val
  end
end

def convert2copper(amt, denomination)
  if denomination =~ /platinum/
    (amt.to_i * 10_000)
  elsif denomination =~ /gold/
    (amt.to_i * 1000)
  elsif denomination =~ /silver/
    (amt.to_i * 100)
  elsif denomination =~ /bronze/
    (amt.to_i * 10)
  else
    amt
  end
end

def convert2plats(copper)
  denominations = [[10_000, 'platinum'], [1000, 'gold'], [100, 'silver'], [10, 'bronze'], [1, 'copper']]
  denominations.inject([copper, []]) do |result, denomination|
    remaining = result.first
    display = result.last
    if remaining / denomination.first > 0
      display << "#{remaining / denomination.first} #{denomination.last}"
    end
    [remaining % denomination.first, display]
  end.last.join(', ')
end

def clean_and_split(room_objs)
  room_objs.sub(/You also see/, '').sub(/ with a [\w\s]+ sitting astride its back/, '').strip.split(/,|\sand\s/)
end

def find_pcs(room_players)
  room_players.sub(/ and (.*)$/) { ", #{Regexp.last_match(1)}" }
              .split(', ')
              .map { |obj| obj.sub(/ (who|whose body) (has|is|appears|glows) .+/, '').sub(/ \(.+\)/, '') }
              .map { |obj| obj.strip.scan(/\w+$/).first }
end

def find_pcs_prone(room_players)
  room_players.sub(/ and (.*)$/) { ", #{Regexp.last_match(1)}" }
              .split(', ')
              .select { |obj| obj =~ /who is lying down/i }
              .map { |obj| obj.sub(/ who (has|is) .+/, '').sub(/ \(.+\)/, '') }
              .map { |obj| obj.strip.scan(/\w+$/).first }
end

def find_pcs_sitting(room_players)
  room_players.sub(/ and (.*)$/) { ", #{Regexp.last_match(1)}" }
              .split(', ')
              .select { |obj| obj =~ /who is sitting/i }
              .map { |obj| obj.sub(/ who (has|is) .+/, '').sub(/ \(.+\)/, '') }
              .map { |obj| obj.strip.scan(/\w+$/).first }
end

def find_npcs(room_objs)
  room_objs.sub(/You also see/, '').sub(/ with a [\w\s]+ sitting astride its back/, '').strip
           .scan(%r{<pushBold/>[^<>]*<popBold/> which appears dead|<pushBold/>[^<>]*<popBold/> \(dead\)|<pushBold/>[^<>]*<popBold/>})
           .reject { |obj| obj =~ /which appears dead|\(dead\)/ }
           .map { |obj| obj.sub('<pushBold/>', '').sub(%r{<popBold/>.*}, '') }
           .map { |obj| obj.split(/\sand\s/).last.sub(/\swith\s.*/, '') }
           .map { |obj| obj.strip.scan(/[A-z'-]+$/).first }
end

def find_dead_npcs(room_objs)
  room_objs.sub(/You also see/, '').sub(/ with a [\w\s]+ sitting astride its back/, '')
           .strip.scan(%r{<pushBold/>[^<>]*<popBold/> which appears dead|<pushBold/>[^<>]*<popBold/> \(dead\)|<pushBold/>[^<>]*<popBold/>})
           .select { |obj| obj =~ /which appears dead|\(dead\)/ }
           .map { |obj| obj.sub('<pushBold/>', '').sub(%r{<popBold/>.*}, '') }
           .map { |obj| obj.split(/\sand\s/).last.sub(/\swith\s.*/, '') }
           .map { |obj| obj.strip.scan(/[A-z'-]+$/).first }
end

def find_objects(room_objs)
  clean_and_split(room_objs)
    .reject { |obj| obj =~ /pushBold/ }
    .map { |obj| obj.sub(/\.$/, '').strip.sub(/^a /, '').strip.sub(/^some /, '') }
end

sleep(0.1) until Char.name && !Char.name.empty?
CharSettings['bank_accounts'] = {} unless CharSettings['bank_accounts'].class == Hash
CharSettings['vault_info'] = {} unless CharSettings['vault_info'].class == Hash

kronar_banks = ['Crossings', 'Dirge', 'Ilaya Taipa', 'Leth Deriel']
lirum_banks = ["Aesry Surlaenis'a", "Hara'jaal", "Mer'Kresh", "Muspar'i", "Ratha", "Riverhaven", "Rossman's Landing", "Therenborough", "Throne City"]
dokora_banks = ["Ain Ghazal", "Boar Clan", "Chyolvea Tayeu'a", "Hibarnhvidar", "Fang Cove", "Raven's Point", "Shard"]

bank_titles = {
  "Aesry Surlaenis'a"  => ["[[Tona Kertigen, Deposit Window]]"],
  "Ain Ghazal"         => ["Unknown Description"],
  "Boar Clan"          => ["Unknown Description"],
  "Chyolvea Tayeu'a"   => ["[[Chyolvea Tayeu'a, Teller]]"],
  "Crossings"          => ["[[Provincial Bank, Teller]]"],
  "Dirge"              => ["[[Dirge, Traveller's Bank]]"],
  "Fang Cove"          => ["[[First Council Banking, Vault]]"],
  "Hara'jaal"          => ["Unknown Description"],
  "Hibarnhvidar"       => ["[[Second Provincial Bank of Hibarnhvidar, Teller]]", "[[Hibarnhvidar, Teller Windows]]", "[[First Arachnid Bank, Lobby]]"],
  "Ilaya Taipa"        => ["Unknown Description"],
  "Leth Deriel"        => ["[[Imperial Depository, Domestic Branch]]"],
  "Mer'Kresh"          => ["[[Harti Clemois Bank, Teller's Window]]"],
  "Muspar'i"           => ["[[Old Lata'arna Keep, Teller Windows]]"],
  "Ratha"              => ["[[Lower Bank of Ratha, Cashier]]", "[[Sshoi-sson Palace, Grand Provincial Bank, Bursarium]]"],
  "Raven's Point"      => ["[[Bank of Raven's Point, Depository]]"],
  "Riverhaven"         => ["[[Bank of Riverhaven, Teller]]"],
  "Rossman's Landing"  => ["Unknown Description"],
  "Shard"              => ["[[First Bank of Ilithi, Teller's Windows]]"],
  "Therenborough"      => ["[[Bank of Therenborough, Teller]]"],
  "Throne City"        => ["[[Faldesu Exchequer, Teller]]"]
}

vault_titles = {
  "Crossings"          => ["[[Crossing, Carousel Chamber]]"],
  "Fang Cove"          => ["[[Fang Cove, Carousel Chamber]]"],
  "Leth Deriel"        => ["[[Leth Deriel, Carousel Chamber]]"],
  "Mer'Kresh"          => ["[[Mer'Kresh, Carousel Square]]"],
  "Muspar'i"           => ["[[Muspar'i, Carousel Square]]"],
  "Ratha"              => ["[[Ratha, Carousel Square]]"],
  "Riverhaven"         => ["[[Riverhaven, Carousel Chamber]]"],
  "Shard"              => ["[[Shard, Carousel Chamber]]"],
  "Therenborough"      => ["[[Therenborough, Carousel Square]]"]
}
#
# Register ;banks ;vault commands
action = proc do |client_string|
  if client_string =~ /^(?:<c>)?#{$lich_char}((?:banks|vault).*)/i
    if scr = Script.running.find { |val| val.name == 'drinfomon' }
      scr.downstream_buffer.shove("#{$clean_lich_char}#{Regexp.last_match(1)}") # if this script is still running send the command
    else
      UpstreamHook.remove('drinfomon') # if the script isnt running remove the hook
    end
    nil # its a command that shouldnt be sent to the game
  else
    client_string # didnt find a command we should watch for send the string as normal
  end
end
UpstreamHook.add('drinfomon', action)
# End Register commands
xp_pools = ['clear', 'dabbling', 'perusing', 'learning', 'thoughtful', 'thinking', 'considering', 'pondering', 'ruminating',
            'concentrating', 'attentive', 'deliberative', 'interested', 'examining', 'understanding', 'absorbing', 'intrigued',
            'scrutinizing', 'analyzing', 'studious', 'focused', 'very focused', 'engaged', 'very engaged', 'cogitating', 'fascinated',
            'captivated', 'engrossed', 'riveted', 'very riveted', 'rapt', 'very rapt', 'enthralled', 'nearly locked', 'mind lock']

exp_reg = /<component id='exp [^<>]+'>\s+(.*).*:\s+(\d+)\s+(\d+)%\s(\w+\s\w+|\w+)/
new_exp_reg = /<component id='exp [^<>]+'><preset id='whisper'>\s+(.*).*:\s+(\d+)\s+(\d+)%\s(\w+\s\w+|\w+)/
exp_brief_reg = %r{<component id='exp [^<>]+'><d cmd..skill (.*)\'.*:\s+(.*)\s(\d+)%\s*\[\s?(\d+)/34\]<}
new_exp_brief_reg = %r{<component id='exp [^<>]+'><preset id='whisper'><d cmd..skill (.*)\'.*:\s+(.*)\s(\d+)%\s*\[\s?(\d+)/34\]<}
clear_exp_reg = %r{<component id='exp (.*)'></component>}
two_col_exp_reg = %r{^\s+([^:\(\)]+):\s+(\d+)\s(\d+)%[^\(\)]*\((\d+)/\d+\)([^:\(\)]+):\s+(\d+)\s(\d+)%[^\(\)]*\((\d+)/\d+\)}
single_col_exp_reg = %r{^\s+([^:\(\)]+):\s+(\d+)\s(\d+)%[^\(\)]*\((\d+)/\d+\)}
skip_inv_update = /^<clearContainer/

xp_action = proc do |server_string|
  next server_string if server_string =~ skip_inv_update
  if server_string.strip.empty? && UserVars.XPSquelch
    nil
    next
  end

  if UserVars.echo_exp && (server_string =~ new_exp_brief_reg || server_string =~ new_exp_reg)
    skill = Regexp.last_match(1)
    DRSkill.gained_skills << skill
  end

  if server_string =~ new_exp_brief_reg || server_string =~ exp_brief_reg
    server_string = nil if UserVars.XPSquelch
    skill = Regexp.last_match(1)
    rank = Regexp.last_match(2)
    xp = Regexp.last_match(4)
    perc = Regexp.last_match(3)
    if DRSkill.include?(skill)
      DRSkill.update(skill, rank, xp, perc)
    else
      DRSkill.new(skill, rank, xp, perc)
    end
    if UserVars.track_exp || UserVars.track_exp.nil?
      server_string.sub!(/\]</, "] #{DRSkill.gained_exp(skill)}<")
    end
  elsif server_string =~ exp_reg || server_string =~ new_exp_reg
    server_string = nil if UserVars.XPSquelch
    skill = Regexp.last_match(1)
    rank = Regexp.last_match(2)
    xp = xp_pools.index(Regexp.last_match(4))
    perc = Regexp.last_match(3)
    if DRSkill.include?(skill)
      DRSkill.update(skill, rank, xp, perc)
    else
      DRSkill.new(skill, rank, xp, perc)
    end
  elsif server_string =~ clear_exp_reg
    server_string = nil if UserVars.XPSquelch
    skill = Regexp.last_match(1)
    DRSkill.clear_mind(skill)
  elsif server_string =~ two_col_exp_reg
    server_string = nil if UserVars.XPSquelch
    skill = Regexp.last_match(1).strip
    rank = Regexp.last_match(2)
    xp = Regexp.last_match(4)
    perc = Regexp.last_match(3)
    skill2 = Regexp.last_match(5).strip
    rank2 = Regexp.last_match(6)
    xp2 = Regexp.last_match(8)
    perc2 = Regexp.last_match(7)
    if DRSkill.include?(skill)
      DRSkill.update(skill, rank, xp, perc)
    else
      DRSkill.new(skill, rank, xp, perc)
    end
    if DRSkill.include?(skill2)
      DRSkill.update(skill2, rank2, xp2, perc2)
    else
      DRSkill.new(skill2, rank2, xp2, perc2)
    end
  elsif server_string =~ single_col_exp_reg
    server_string = nil if UserVars.XPSquelch
    skill = Regexp.last_match(1).strip
    rank = Regexp.last_match(2)
    xp = Regexp.last_match(4)
    perc = Regexp.last_match(3)
    if DRSkill.include?(skill)
      DRSkill.update(skill, rank, xp, perc)
    else
      DRSkill.new(skill, rank, xp, perc)
    end
  elsif server_string =~ /Circle.*|Showing all skills that you have skill in|SKILL: .*|Total Ranks Displayed.*|Rested EXP Stored.*|Overall state of mind.*|Time Development Points.*|EXP HELP for more information/ && UserVars.XPSquelch
    UserVars.XPSquelch = nil if server_string =~ /EXP HELP for more information/
    server_string = nil
  end

  server_string
end
UserVars.XPSquelch = true unless UserVars.drinfomon_debug
DownstreamHook.add('xp_action', xp_action)

info_silence = proc do |server_string|
  if server_string.strip.empty?
    server_string = nil
    next
  end

  if server_string =~ /You owe|No debt/
    DownstreamHook.remove('info_silence')
    server_string = nil
  elsif server_string =~ /Having over 500 items in your inventory seriously increases your character/
    DownstreamHook.remove('info_silence')
  elsif server_string =~ /Name: .*|Gender:.*|You were born.*|Your birthday.*|Strength.*|Agility.*|Discipline.*|Intelligence.*|Concentration.*|Favors.*|TDPs.*|Encumbrance.*|Luck.*|Wealth:.*|Kronars.*|Lirums.*|Dokoras.*|Debt:.*/
    server_string = nil
  end
  server_string
end

status_action = proc do |server_string|
  if server_string =~ /<progressBar id='mana' value='(\d+)'/
    DRStats.mana = Regexp.last_match(1).to_i
  elsif server_string =~ /<progressBar id='stamina' value='(\d+)'/
    DRStats.fatigue = Regexp.last_match(1).to_i
  elsif server_string =~ /<progressBar id='health' value='(\d+)'/
    DRStats.health = Regexp.last_match(1).to_i
  elsif server_string =~ /<progressBar id='concentration' value='(\d+)'/
    DRStats.concentration = Regexp.last_match(1).to_i
  elsif server_string =~ /<progressBar id='spirit' value='(\d+)'/
    DRStats.spirit = Regexp.last_match(1).to_i
  elsif server_string =~ %r{\'room players\'>Also here: (.*)\.</component>}
    DRRoom.pcs = find_pcs(Regexp.last_match(1).dup)
    DRRoom.pcs_prone = find_pcs_prone(Regexp.last_match(1).dup)
    DRRoom.pcs_sitting = find_pcs_sitting(Regexp.last_match(1).dup)
  elsif server_string =~ %r{\'room players\'></component>}
    DRRoom.pcs = []
  elsif server_string =~ %r{\'room objs\'>(.*)</component>}
    DRRoom.npcs = find_npcs(Regexp.last_match(1).dup)
    UserVars.npcs = DRRoom.npcs
    DRRoom.dead_npcs = find_dead_npcs(Regexp.last_match(1).dup)
    DRRoom.room_objs = find_objects(Regexp.last_match(1).dup)
  elsif server_string =~ %r{\'room objs\'></component>}
    DRRoom.npcs = []
    DRRoom.dead_npcs = []
    DRRoom.room_objs = []
  elsif server_string =~ /^you \w+ (west|east|north|south|northeast|northwest|southeast|southwest|out)\./i
    DRRoom.group_members = []
  elsif server_string =~ %r{<pushStream id="group"/>  (\w+): <popStream/>}
    DRRoom.group_members << Regexp.last_match(1)
  elsif server_string =~ /Obvious exits:/ || server_string =~ /Obvious paths:/
    exit_string = server_string.gsub('<d>', '').gsub('</d>', '').gsub('Obvious exits: ', '').gsub('Obvious paths: ', '').delete('.').gsub("\r\n", '')
    DRRoom.exits = exit_string.split(', ') - ['none']
  end
  DRRoom.title = XMLData.room_title
  DRRoom.description = XMLData.room_description.strip
  server_string
end
DownstreamHook.add('status_action', status_action)

save_proc = proc do
  CharSettings.save
end
#
# Save current status every five minutes in case of crash
#
Thread.new do
  begin
    loop do
      sleep 300
      save_proc.call
    end
  rescue
    echo $ERROR_INFO
    echo $ERROR_INFO.backtrace[0..1]
  end
end # end save ever 5 min

before_dying do
  save_proc.call
  UpstreamHook.remove('drinfomon')
  DownstreamHook.remove('xp_action')
  DownstreamHook.remove('status_action')
  DownstreamHook.remove('premiumcheck_silence')
  DownstreamHook.remove('info_silence')
end

put('exp all')
pause 0.25
info_check_time = Time.now - 30
unless dead?
  DownstreamHook.add('info_silence', info_silence) unless UserVars.drinfomon_debug
  put('info')
  info_check_time = Time.now
  pause 0.25
end

premiumcheck_silence = proc do |server_string|
  if server_string.strip.empty?
    nil
    next
  end
  if server_string =~ /Your premium service has been.*/
    UserVars.premium = 'true'
    server_string = nil
  elsif server_string =~ /You are not currently a Premium or Platinum subscriber.*/
    UserVars.premium = nil
    server_string = nil
  elsif server_string =~ /Having over 500 items in your inventory seriously increases your character/
    DownstreamHook.remove('premiumcheck_silence')
  elsif server_string =~ /For more information on LTBs.*/
    DownstreamHook.remove('premiumcheck_silence')
    server_string = nil
  elsif server_string =~ /As of your last logon:|(Premium|Platinum): http:\/\/www.play.net\/dr\/(premium|platinum)\/|You have a cumulative (Premium|Platinum) time of .* months.|(Premium|Platinum) Points Earned: .*|Total Points Earned: .*|Total Points Spent: .*|Unfinished Scroll Points: .*|Available Points to Spend: .*/
    server_string = nil
  end
  server_string
end

DownstreamHook.add('premiumcheck_silence', premiumcheck_silence)
fput 'ltb info'

while line = script.gets
  begin
    if line =~ /^\* Log-on system converted \d+% of your character/
      UserVars.XPSquelch = true unless UserVars.drinfomon_debug
      put('exp all')
    elsif line =~ /^#{$lich_char}banks$/
      if CharSettings['bank_accounts'].empty?
        respond
        respond 'No bank account info recorded.'
        respond
      else
        respond
        CharSettings['bank_accounts'].each do |town, amount|
          respond "#{town.rjust(27)}: #{amount.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.rjust(13)}" + ' or ' + convert2plats(amount).to_s
        end
        respond '              ------------------------------------------------------------------------------------------'
        total = 0
        kronar_banks
          .select { |city| CharSettings['bank_accounts'][city] }
          .each { |city| total += CharSettings['bank_accounts'].fetch(city) }
        respond "               Kronar Total: #{total.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.rjust(13)}" + ' or ' + convert2plats(total).to_s
        total = 0
        lirum_banks
          .select { |city| CharSettings['bank_accounts'][city] }
          .each { |city| total += CharSettings['bank_accounts'].fetch(city) }
        respond "                Lirum Total: #{total.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.rjust(13)}" + ' or ' + convert2plats(total).to_s
        total = 0
        dokora_banks
          .select { |city| CharSettings['bank_accounts'][city] }
          .each { |city| total += CharSettings['bank_accounts'].fetch(city) }
        respond "               Dokora Total: #{total.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse.rjust(13)}" + ' or ' + convert2plats(total).to_s
      end
    elsif line =~ /^#{$lich_char}vault$/
      respond
      if CharSettings['vault_info'].empty?
        respond 'No vault info recorded.'
      else
        respond "          Your vault is located in #{CharSettings['vault_info']['location']}"
        respond "          ---------------------------------------"
        respond "          #{CharSettings['vault_info']['contents']}"
      end
      respond
    elsif line =~ /(?:In the secure vault you see|You rummage through a secure vault and see)\s(.*)\./
      vault_titles
        .select { |_town, titles| titles.include?(checkroom) }
        .each do |town, _titles|
          contents = Regexp.last_match(1)
          line.scan(/a.*?(?<furniture>\w+ \w+) with some stuff (?<location>\w+) it/).each do |furniture, location|
            fput "look #{location} #{furniture}"
            if get =~ /#{location} the #{furniture} you see(.*)\./i
              contents += ',' + Regexp.last_match(1).sub(/ and(.*)/, ',\1')
            end
          end
          CharSettings['vault_info']['location'] = town
          CharSettings['vault_info']['contents'] = contents.sub(/,$/, '')
        end
    elsif line =~ /^Circle: (\d+)/
      DRStats.circle = Regexp.last_match(1).to_i
    elsif line =~ /(completely|hopelessly|extremely|very badly|badly|somewhat off|off|slightly off|solidly|nimbly|adeptly|incredibly) balanced?/
      balance_map = ['completely', 'hopelessly', 'extremely', 'very badly', 'badly', 'somewhat off', 'off', 'slightly off', 'solidly', 'nimbly', 'adeptly', 'incredibly']
      DRStats.balance = balance_map.index(Regexp.last_match(1).strip)
    elsif line =~ /^Name:\s+.+Race:\s+(.+)\s+Guild:\s+(.+)/
      # info checked record stats
      DRStats.race = Regexp.last_match(1).strip
      DRStats.guild = Regexp.last_match(2).strip
      if get =~ /Gender:\s+([A-z]+)\s+Age:\s+([0-9]+)\s+Circle:\s+([0-9]+)/
        DRStats.gender = Regexp.last_match(1)
        DRStats.age = Regexp.last_match(2).to_i
        DRStats.circle = Regexp.last_match(3).to_i
        loop do
          line = get

          if line =~ /(Strength|Agility|Discipline|Intelligence|Concentration)\s:\s{1,3}([0-9]+)/
            DRStats.send("#{Regexp.last_match(1).downcase}=", Regexp.last_match(2).to_i)
          end

          if line =~ /(Stamina|Reflex|Charisma|Wisdom)\s:\s{1,3}([0-9]+)/
            DRStats.send("#{Regexp.last_match(1).downcase}=", Regexp.last_match(2).to_i)
          end

          if line =~ /(Favors|TDPs)\s:\s(.*)/
            DRStats.send("#{Regexp.last_match(1).downcase}=", Regexp.last_match(2).to_i)
          end

          if line =~ /(Encumbrance)\s:\s(.*)/
            DRStats.send("#{Regexp.last_match(1).downcase}=", Regexp.last_match(2))
          end

          break if line =~ /Wealth:/
        end
      end
      CharSettings['Stats'] = DRStats.serialize
    elsif line =~ /(Encumbrance)\s:\s(.*)/
      DRStats.send("#{Regexp.last_match(1).downcase}=", Regexp.last_match(2))
      CharSettings['Stats'] = DRStats.serialize
    elsif line =~ /You have (\d+) TDPs\./
      DRStats.tdps = Regexp.last_match(1).to_i
    elsif line =~ /The clerk slides a small metal box across the counter into which you drop (\d+) (\w+) (?:Kronars|Lirums|Dokoras)/
      # you deposited a portion of your money
      bank_titles
        .select { |_town, titles| titles.include?(checkroom) }
        .each_key do |town|
          copper = convert2copper(Regexp.last_match(1).to_i, Regexp.last_match(2))
          CharSettings['bank_accounts'][town] = CharSettings['bank_accounts'][town].to_i + copper
          break
        end
    elsif line =~ /^The clerk slides a small metal box across the counter into which you drop all your (?:Kronars|Lirums|Dokoras).  She counts them carefully and records the deposit in her ledger|You cross through the old balance on the label and update it to reflect your new balance/
      # you deposited all your money
      fput 'balance'
    elsif line =~ /(?:The clerk counts|You count) out ([0-9]+) (platinum|gold|silver|bronze|copper) (?:Kronars|Lirums|Dokoras) (?:and hands them over, making a notation in her ledger|and quickly pocket them, updating the notation on your jar)/
      # you withdrew some money
      bank_titles
        .select { |_town, titles| titles.include?(checkroom) }
        .each_key do |town|
          copper = convert2copper(Regexp.last_match(1).to_i, Regexp.last_match(2))
          CharSettings['bank_accounts'][town] = CharSettings['bank_accounts'][town].to_i - copper
          break
        end
    elsif line =~ /(?:The clerk counts out all your|You count out all of your) (?:Kronars|Lirums|Dokoras) (?:and hands them over, making a notation in her ledger|and quickly pocket them)/
      # you withdrew all your money
      bank_titles.each do |town, titles|
        if titles.include?(checkroom)
          CharSettings['bank_accounts'][town] = 0
          break
        end
      end
    elsif line =~ /(?:(?:it looks like|\"Here we are.)\s[y]our current balance is|As expected, there are) (.*)\s(?:Kronars|Lirums|Dokoras)/i
      # you checked your balance
      copper = 0
      Regexp.last_match(1).each_line(', ') do |m|
        m.to_s
        a = m.match(/([0-9]+).[a-z]+/)
        copper += convert2copper(a.to_s.to_i, m)
      end
      bank_titles.each do |town, titles|
        if titles.include?(checkroom)
          CharSettings['bank_accounts'][town] = copper.to_i
          break
        end
      end
    elsif line =~ /you do not seem to have an account with us|you should find a new deposit jar for your financial needs/
      # you have no account
      bank_titles.each do |town, titles|
        if titles.include?(checkroom)
          CharSettings['bank_accounts'][town] = 0
          break
        end
      end
    end
    if DRStats.guild.nil? && !dead? && Time.now - info_check_time > 30
      UserVars.XPSquelch = true unless UserVars.drinfomon_debug
      DownstreamHook.add('info_silence', info_silence) unless UserVars.drinfomon_debug
      put('exp all')
      pause 0.25
      put('info')
      info_check_time = Time.now
      pause 0.25
    end
  rescue
    echo $ERROR_INFO
    echo $ERROR_INFO.backtrace.first
    sleep 1
  end
end
