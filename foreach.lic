=begin
  Executes a series of commands for each item matching the criteria you specify.

  Some examples:
    ;foreach box in inv; move to locker
    ;foreach box in locker; move to backpack
    ;foreach gem in cloak; get item; appraise item; put item in container
    ;foreach gem in red sack; move to gemcutter; turn gemcutter; move to blue sack
    ;foreach scroll in inv; read item
    ;foreach gem in backpack; get item; prep 704; cast item; put item in container   (Note: won't check mana)
    ;foreach reagent in inv; get item; sell item
    ;foreach gem in backpack; get item; ;my_script item; put item in container
    ;foreach name=*quartz orb in inv; get item; put item in locker

  Basic usage:
    ;foreach [[ATTRIBUTE]=VALUE] in <CONTAINER>[; command; command; ...]

  Type ;foreach or ;foreach help for more details and information on functionality, or visit:
  https://github.com/dewiniaid/gs4-lich-scripts/blob/master/Foreach.md

  ;foreach is blind to closed containers.

	  author: LostRanger (thisgenericname@gmail.com)
	  game: any
	  tags: utility
	  required: Lich >= 4.6.0.

  version: 0.6.2 (2017-06-69)

  changelog:
    version 0.6.2 (2017-06-29)
      * Fix an issue where every command after a script would be interpreted as a script.

    version 0.6.1 (2017-06-29)
      * Reminder to self to do better testing
      * Fix foreach not working on anything but item types bug introduced in 0.6

    version 0.6 (2017-06-29)
      * Add first-time setup walkthrough.
      * Add STASH, which tries storing the item in your lootsacks (in order)
      * MOVE, FASTMOVE now internally use _DRAG when they can, which reduces them to one command instead of two.
      * DROP/DROP ITEM now internally uses _DRAG when it is the first command in the list.
      * Increased inventory command timeout from 5 seconds to 15.
      *

    version 0.5.4 (2017-06-25)
      * Another small bugfix to preemptive GET commands.

    version 0.5.3 (2017-06-25)
      * Small bugfix to preemptive GET commands.

    version 0.5.2 (2017-06-25)
      * Now properly handles containers with FLAG SORTEDVIEW ON.

    version 0.5.1 (2017-06-25)
      * Cosmetic bugfix to help summary.

    version 0.5 (2017-06-24)
      * `;foreach in inventory` now uses and parses INV FULL rather than the tedious scanning process and relying on
        Lich's container management.  This is MUCH faster than the old approach.
      * You can now use t=, n= and m= as shorthand for 'type', 'noun=' and 'name=', respectively
      * Added fullname= and f= to matches an item's FULL name.  (This was actually an unadvertised addition in an
          earlier update)
      * You can now filter on multiple values (;foreach noun=diamond,emerald,sapphire in ...)
      * MOVE TO container  and  MOVE ITEM TO container will no longer attempt to get the item first if you're already
          holding it.
      * MOVE TO GROUND/FLOOR and MOVE ITEM TO GROUND/FLOOR will now place items on the ground.
      * Added GIVEITEM [TO] <player> command, which gives the matched item to a player and waits for them to accept.
          Roughly a shortcut for 'give item to player; waitfor player has accepted'
      * Added RETURN, which returns the item to its original container (or the floor) if you are still holding it
      * DROP, PLACE, SELL and APPRAISE will now expand to DROP ITEM, PLACE ITEM, SELL ITEM and APPRAISE ITEM
          respectively.
      * DROP ITEM, PLACE ITEM, SELL ITEM, APPRAISE ITEM, GIVEITEM will now GET the item first if they are the first
          command in the list.
      * APPRAISE ITEM will return the item to its orginal container if it is the only command.
      * Overhauled documentation, including a link to web-viewable documentation

    version 0.4.3 (2017-06-23)
      * Added MV shortcut for MOVE
      * Added FASTMOVE, FMV and FASTMV which are slightly faster methods for moving items but may be a bit fragile.

    version 0.4.2 (2017-06-23)
      * Support negative container IDs.  Allows use on pawnshop tables, among other things.

    version 0.4.1 (2017-06-21)
      * Cosmetic fixes to help messaging.

    version 0.4 (2017-06-21)
      * Add PAUSE command, which announces the current item and then pauses the script.  Unpausing the script picks up
          where it left off.
      * Added a safeguard against operating against every single item in your inventory.
      * Added foreach in last;... which operates against the same set of items the last copy of the script found.
          Handy if you want to e.g. undo moving items, and the list can be additionally filtered as well.
      * Added prettier formatting for Stormfront users.
      * Item lists now include links for Stormfront users.
      * When scanning a large number of containers, make periodic progress updates.
      * When processing a large number of items, make periodic progress updates.
      * Fix a cosmetic bug where container scanning might cause excessive amounts of blank lines to be sent to the client.

    version 0.3.1 (2017-06-20)
      * Actually re-enable code disabled by accident in 0.3.  So foreach actually works again.

    version 0.3 (2017-06-20)
      * Added convenience shortcut commands MOVE, WAITRT, WAITFOR, WAITRE, and ECHO.  See help for examples.
        Example of move: ;foreach item in loot;move to backpack

    version 0.2.1 (2017-06-19)
      * Fix 'on ground/on floor', and add 'room' as an alias

    version 0.2 (2017-06-19)
      * Add support for invoking Lich scripts.  (foreach gem in inv;;script item)
      * Add improvements to handling commands that create Roundtime.
      * Using foreach with no commands now produces a somewhat better inventory list.
      * Minor text fixes.

    version 0.1 (2017-06-18)
      * Initial release
=end

module ForeachScript
    VERSION = '0.6.2 (2017-06-29)'
    CONFIG_VERSION = 1
    FILTER_PATTERN = /^(?:(?:(?:(.+)=)?(.+)\s+([io]n)\s+)|([io]n)\s+)(.+)$/
    INV_PATTERN = /(?:(?:Peering into|[IO]n) .* <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>,? you see )|(?:[OI]n the <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>:\s*$)|There is nothing [io]n there|That is closed.|I could not find what you were referring to\./
    HOOK = 'foreach_script_temp_hook'
    HELP_URL = "https://github.com/dewiniaid/gs4-lich-scripts/blob/master/Foreach.md"


    INVFULL_PATTERN = /^( {2,})([^<]*)<a exist="(-?\d+)" noun="([^"]*)">([^<]*)<\/a>(?: ([^(]*)(?:$|(?= \()))?(?: (\(.*\)))?$/
    # Matches: 1 = leading space, 2 = prename, 3 = id, 4 = noun, 5 = name, 6 = postname, 7 = registered/marked attributes
    # You are carrying nothing at this time.  -- no inventory

    CONTAINER_UPDATE_INTERVAL = 10  # How often do we notify how many more containers are being scanned
    ITEM_UPDATE_INTERVAL = 10  # How often do we notify how many more items are being processed?

    COMMAND_PATTERNS = {
        :move => /^(f(?:ast)?)?(?:move|mv)\s+(?:(.+)\s+)?to\s+(.*)$/i,


    }

    @previous = nil unless defined?(@previous)
    @previous_names = nil unless defined?(@previous_names)

    def self.anon_hook(prefix = '')
        now = Time.now
        "Foreach::#{prefix}-#{now.tv_sec}.#{now.tv_usec}-#{Random.rand(10000)}"
    end

    def self.cleanup
        [DownstreamHook, UpstreamHook].each{|provider|
            provider.list.find_all{|name| name.start_with?('Foreach::')}.each{|name| provider.remove(name)}
        }
    end

    def self.send_formatted(msg, mono=true)
        if @stormfront
            msg = REXML::Text.new(msg, respect_whitespace: true).to_s
            msg.gsub!(/\*\*(.*?)\*\*/, '<preset id="whisper">\1</preset>')
            msg = "<output class=\"mono\" />\n#{msg}\n<output class=\"\" />" if mono
            puts msg
        else
            msg.gsub!('**', '')
            respond msg
        end
    end

    def self.first_time_setup(force = false)
        return if GameSettings['version'] == CONFIG_VERSION and not force

        send = "#{$lich_char}send to #{@script.name}"

        option = proc{|what|
            cmd = "#{send} #{what.upcase}"
            if @stormfront
                puts "    <d cmd=\"#{cmd}\">#{cmd}</d>"
            else
                puts "    #{cmd}"
            end
        }


        echo "Starting one time setup..."
        clear

        msg = ["**Welcome to ForEach version #{VERSION}**"]
        msg << "**#{'-' * (msg[0].length-4)}**"
        msg << "This one-time setup process will help you get started with ForEach and configure it for future use."
        msg << "Once you've answered a few quick questions, you won't see these messages again."
        msg << ''
        if @stormfront
            msg << "Click on your answers to the questions, or type '#{send} <answer>, where <answer> is your answer."
        else
            msg << "Type '#{send} <answer>' to answer these questions, where <answer> is your answer."
        end
        msg << ''
        send_formatted(msg.join("\n"), false)

        while true
            puts "Would you like Lich to check for updates to this script on startup?\n"
            option.call('yes')
            option.call('no')
            response = unique_get.strip.downcase
            if response =~ /^y(?:es)?$/
                Script.run('repository', "set-updatable #{@script.name}.lic")
                respond "If you change your mind later, enter #{$lich_char}repository unset-updatable #{@script.name}.lic"
                break
            elsif response =~ /^no?$/
                Script.run('repository', "unset-updatable #{@script.name}.lic")
                respond "If you change your mind later, enter #{$lich_char}repository set-updatable #{@script.name}.lic"
                break
            else
                echo 'Please answer YES or NO'
            end
        end
        puts ''
        sleep 1
        gameobjadd = false
        gameobjaddmore = false
        while true
            puts [
                "ForEach has the ability to filter items by type using some functionality built-in to Lich.  However,",
                " the data included in Lich is a bit outdated so some items may have the wrong type -- or have no type",
                " at all.\n",
                "\n",
                "There's a third-party script called GameObjAdd that is designed to run on startup and add updated item",
                " type data to Lich.  The script exits afterwards and requires no additional resources beyond that point.",
                "  If you use Bigshot or some other scripts, you may already have this set up.",
                "\n",
                "Would you like me to setup GameObjAdd for you?\n",
            ].join('')
            option.call('yes')
            option.call('no')
            option.call('info')
            response = unique_get.strip.downcase
            if response =~ /^y(?:es)?$/
                Script.run('repository', "download GameObjAdd.lic")
                Script.run('autostart', "add --global GameObjAdd")
                Script.run('GameObjAdd')
                gameobjadd = true

                respond "If you change your mind later, you can remove GameObjAdd from Autostart with: ${lich_char}autostart remove --global GameObjAdd"
                break
            elsif response =~ /^no?$/
                respond "If you change your mind later, enter the following commands:"
                respond "#{$lich_char}repository download GameObjAdd"
                respond "#{$lich_char}repository set-updatable GameObjAdd"
                respond "#{$lich_char}autostart add --global GameObjAdd"
                break
            elsif response =~ /^(?:info|help|details)$/
                Script.run('repository', 'info GameObjAdd.lic')
            else
                echo 'Please answer YES, NO or INFO'
            end
        end

        while gameobjadd
            puts "Would you like Lich to check for updates to GameObjAdd on startup?\n"
            option.call('yes')
            option.call('no')
            response = unique_get.strip.downcase
            if response =~ /^y(?:es)?$/
                Script.run('repository', "set-updatable GameObjAdd.lic")
                respond "If you change your mind later, enter #{$lich_char}repository unset-updatable GameObjAdd.lic"
                break
            elsif response =~ /^no?$/
                Script.run('repository', "unset-updatable GameObjAdd.lic")
                respond "If you change your mind later, enter #{$lich_char}repository set-updatable GameObjAdd.lic"
                break
            else
                echo 'Please answer YES or NO'
            end
        end


        while true
            puts [
                     "In addition to GameObjAdd, I've written a script called GameObjAddMore that makes some further",
                     " refinements to Lich's item type data.  It is an addition to GameObjAdd and is not a replacement for it.\n",
                     "\n",
                     "The current version of GameObjAddMore (as if this version of Foreach) mainly refines the criteria for",
                     " what counts as a 'box', and adds a 'phased' category (items beginning with 'shifting').\n",
                     "\n",
                     "Like GameObjAdd, GameObjAddMore runs at startup, does its thing, and then immediately exits.\n",
                     "\n",
                     "Would you like me to setup GameObjAddMore for you?\n",
                 ].join('')
            option.call('yes')
            option.call('no')
            option.call('info')
            response = unique_get.strip.downcase
            if response =~ /^y(?:es)?$/
                Script.run('repository', "download GameObjAddMore.lic")
                Script.run('autostart', "add --global GameObjAddMore")
                Script.run('GameObjAddMore')
                gameobjaddmore = true

                respond "If you change your mind later, you can remove GameObjAddMore from Autostart with: ${lich_char}autostart remove --global GameObjAddMore"
                break
            elsif response =~ /^no?$/
                respond "If you change your mind later, enter the following commands:"
                respond "#{$lich_char}repository download GameObjAddMore"
                respond "#{$lich_char}repository set-updatable GameObjAddMore"
                respond "#{$lich_char}autostart add --global GameObjAddMore"
                break
            elsif response =~ /^(?:info|help|details)$/
                Script.run('repository', 'info GameObjAddMore.lic')
            else
                echo 'Please answer YES, NO or INFO'
            end
        end

        while gameobjaddmore
            puts "Would you like Lich to check for updates to GameObjAddMore on startup?\n"
            option.call('yes')
            option.call('no')
            response = unique_get.strip.downcase
            if response =~ /^y(?:es)?$/
                Script.run('repository', "set-updatable GameObjAddMore.lic")
                respond "If you change your mind later, enter #{$lich_char}repository unset-updatable GameObjAddMore.lic"
                break
            elsif response =~ /^no?$/
                Script.run('repository', "unset-updatable GameObjAddMore.lic")
                respond "If you change your mind later, enter #{$lich_char}repository set-updatable GameObjAddMore.lic"
                break
            else
                echo 'Please answer YES or NO'
            end
        end

        sleep 1
        echo "Just a few more things..."
        puts "You may want to check out some of my other scripts.  Here's a list:"
        Script.run('repository', 'list --author=LostRanger')
        puts ''
        puts [
            "If ForEach is a trusted script, it will hide the commands it is sending to scan inventories and thus",
            " reduce a tiny bit of screen spam.  This is entirely optional and doesn't otherwise affect the script at all.",
            "  You can trust the script with\n",
        ].join('')
        respond "    #{$lich_char}trust foreach"
        puts "(LostRanger recommends that you review the code for scripts before trusting them!)"
        puts "\nTo view information and examples on how to use #{$lich_char}foreach, read the following:"
        respond "    #{HELP_URL}"
        puts "\nTo see a short reminder on how to use #{$lich_char}foreach in game, type:"
        respond "    #{$lich_char}#{@script.name} help"
        puts "\nTo run this setup process again at any time, type:"
        respond "    #{$lich_char}#{@script.name} setup"

        if @script.vars[0].strip.length > 0 and not force
           puts "\nTo run the command you were about to run when Foreach launched its first-time setup, type:"
           respond "    #{$lich_char}#{@script.name} #{@script.vars[0]}"
        end
        GameSettings['version'] = CONFIG_VERSION
        exit
    end

    def self.show_help(full)
        msg = []
        name = "#{$lich_char}#{@script.name}"
        msg << "**This is ForEach version #{VERSION}**"
        msg << "**Usage:**"
        msg << "    #{name} [[ATTRIBUTE=]VALUE] in <TARGET>[; command; command; ...]"
        msg << " or #{name} [[ATTRIBUTE=]VALUE] in <TARGET>[/ command/ command/ ...]"
        msg << " or #{name} [[ATTRIBUTE=]VALUE] in <TARGET>[| command| command| ...]"
        msg << ''
        if full
            msg << "**ATTRIBUTE** can be one of: noun, name, or type.  If unspecified, it is type."
            msg << "**VALUE** is what the attribute's value must match.  Wildcards (with *) are supported."
            msg << "**TARGET** can be a name of a container or one of the following:"
            msg << ''
            msg << "    **INV** or **INVENTORY**  - Contents of all containers in your inventory."
            msg << "    **WORN**              - All worn items in your inventory."
            msg << "    **FLOOR/GROUND/ROOM** - Items in the room.  (Not their contents)"
            msg << "    **LOCKER** or **LOOT**    - Contents of items in the room.  (e.g. locker containers)"
            msg << "    **PREVIOUS** or **LAST**  - All items that matched the previous run of Foreach."
            msg << ''
            msg << "Each command will be executed on the item in sequence.  Within each command, the following replacements will be be made:"
            msg << ''
            msg << "    **ITEM**      - An exact reference to the item."
            msg << "    **NAME**      - The full name of the item.  Not suitable for commands, suitable for speech."
            msg << "    **NOUN**      - The item's noun.  Not suitable for commands, suitable for speech."
            msg << "    **CONTAINER** - An exact reference to the container the item was found in.  Not if using FLOOR/GROUND."
            msg << "                If using PREVIOUS, this is the container the item WAS in, not its current location."
            msg << ''
            msg << "If no commands are specified, #{name} will show a list of all matching items instead."
            msg << "This list will show item types, so '#{name} in backpack' can help you determine which item type to use."
            msg << ''
            msg << "If no attribute or value are specified, #{name} examines all items in the relevant locations."
            msg << ''
            msg << "Each command can be a game command, a lich script (invoked as if typing it in the client), or one of the following"
            msg << "convenience commands:"
            msg << ''
            msg << "    **ECHO <message>**                 - Echo a line of text."
            msg << "    **GIVEITEM <player>**              - Give an item to a player and wait for them to accept it."
            msg << "    **[FAST]MOVE [<item>] TO <where>** - Convenience shortcut for 'get item; put item in container`.  <where> can also be GROUND or FLOOR`"
            msg << "    **STASH [<item>]**                 - Attempts to move the item to your lootsack(s), trying them in order if they are full."
            msg << "    **PAUSE**                          - Pause the script.  #{name} will resume where it left off when unpaused."
            msg << "    **WAITRT**                         - Wait for roundtime to finish.  Hangs if not in roundtime."
            msg << "    **WAITFOR <phrase>**               - Waits to see the specified phrase.  Case insensitive."
            msg << "    **WAITRE <pattern>**               - Waits to see the specified regular expression."
            msg << ''
            msg << "There are some other convenience shortcuts with certain regular game commands, details are in the online documentation."
            msg << "#{name} is blind to closed containers."
            msg << ''
            msg << "If #{name} is trusted ('#{$lich_char}trust #{@script.name}'), its initial inventory scan output will be silenced."
            msg << ''
            msg << "Item types are based on Lich's definition of item types, also seen in #{$lich_char}sorter.  The current list is:"
            msg << GameObj.type_data.map{|k,v| k}.sort.join(', ')
        else
            msg << "**ATTRIBUTEs** include **type**(default), **noun**, **name**, **fullname**, or shorthand equivalents **t**, **n**, **m**, and **f**"
            msg << "**TARGETs** include any inventory container or **INV**, **WORN**, **ROOM**, **LOOT**, and **LAST** (and various synonyms listed in the full help)"
            msg << "**COMMANDs** are any game command, or convenience shortcuts **ECHO**, **GIVEITEM**, **STASH**, **FASTMOVE**, **MOVE**, **PAUSE**, **WAITRT**, **WAITFOR** and **WAITRE**"
            msg << ''
        end

        if full
            msg << "**To view detailed documentation and examples online, visit:**"
        else
            msg << "**This is the short version of the documentation.  For more, see #{name} help or visit:**"
        end
        msg << "https://github.com/dewiniaid/gs4-lich-scripts/blob/master/Foreach.md"
        msg << ''

        msg = msg.join("\n")

        if @stormfront
            msg = REXML::Text.new(msg, respect_whitespace: true).to_s
            msg.gsub!(/\*\*(.*?)\*\*/, '<preset id="whisper">\1</preset>')
            puts "<output class=\"mono\" />\n#{msg}\n<output class=\"\" />"
        else
            msg.gsub!('**', '')
            respond msg
        end
    end

    def self.quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout=5)
        hook = self.mask_output(start_pattern, end_pattern, include_end)
        xml = dothistimeout(command, timeout, start_pattern)
        unless xml
            DownstreamHook.remove(hook)
            return nil
        end
        result = [xml]
        while true
            xml = get
            if xml =~ end_pattern
                result << xml if include_end
                return result
            end
            result << xml
        end
    end

    def self.mask_output(start_pattern, end_pattern = /<prompt/, include_end = true)
        filter = false
        name = self.anon_hook
        DownstreamHook.add(name, proc {|xml|
            if filter
                if xml =~ end_pattern
                    DownstreamHook.remove(name)
                    filter = false
                    next(include_end ? nil : xml)
                else
                    next(nil)
                end
            elsif xml =~ start_pattern
                filter = true
                next(nil)
            else
                xml
            end
        })
        return name
    end

    def self.quiet_inv_scan_hook(xml)
        if @in_sorted_view
            @in_sorted_view = false if xml =~ /Total items: \d+$/
            return nil
        end

        return nil if xml =~ /^<prompt|^s*$/
        return xml unless xml =~ INV_PATTERN
        @in_sorted_view = true if $3
        return nil
        #
        # (xml =~ INV_PATTERN or xml =~ /^<prompt/ or xml =~ /^\s*$/) ? nil : xml
    end

    def self.stop_scripts
        ['sorter'].each{|s|
            if Script.running?(s)
                Script.kill(s)
                @stopped_scripts << s
            end
        }
    end

    def self.resume_scripts
        @stopped_scripts.each{|s| Script.start(s) }
        @stopped_scripts = []
    end

    def self.holding?(id)
        id == GameObj.right_hand.id or id == GameObj.left_hand.id
    end

    def self.find_sacks(base = 'lootsack')
        # Adapted from ;loot
        sacks = []
        ix = nil
        while true
            var = "#{base}#{ix}"
            ix = 1 if ix.nil?
            ix += 1
            name = Vars[var].strip
            return sacks unless name.length > 0
            if name =~ /^my\s+(.*)$/i
                name = $1
            end
            pattern = Regexp::escape(name)
            sack = nil
            [ /\b#{pattern}$/i, /\b#{pattern.sub(' ', '.*')}$/i, /\b#{pattern.sub(' ', '.*')}/i ].each{|pattern|
                sack = GameObj.inv.find {|obj| obj.name =~ pattern }
                break if sack
            }
            if sack
                sacks << sack
            else
                echo "warning: failed to find #{var} '#{name}'"
            end
        end
    end

    def self.build_filter(value, attr, target)
        attr = 'type' unless attr
        return proc {|item| true} unless value

        pattern = /^(?:#{value.split(/\s*,\s*/).map{|x| "(?:#{Regexp::escape(x).gsub('\*', '.*')})"}.join('|')})$/
        case attr
            when 'type', 't'
                unless GameObj.type_data.find{|k, v| k.split(',').find{|t| t =~ pattern}}
                    echo "No item types match the pattern '#{value}'.  Did you perhaps mean '#{$lich_char}#{@script.name} #{value =~ /\s/ ? 'name' : 'noun'}=#{value} in #{target};...'?"
                    echo "Type '#{$lich_char}#{@script.name}' by itself for more options and a list of item types."
                    exit
                end
                return proc {|item| item.type.split(',').find{|t| t =~ pattern}}
            when 'name', 'm'
                return proc {|item| item.name =~ pattern}
            when 'fullname', 'f'
                return proc {|item| item.full_name =~ pattern}
            when 'noun', 'n'
                return proc {|item| item.noun =~ pattern}
            else
                return nil
        end
    end


    def self.run(script)
        @stormfront = ($frontend == 'stormfront')
        @profanity = ($frontend == 'profanity')
        @script = script
        @script.want_downstream = false
        @script.want_downstream_xml = true

        self.first_time_setup(@script.vars[0] =~ /^\s*setup\s*$/i ? true : false)

        @stopped_scripts = []
        before_dying {
            self.cleanup
            resume_scripts
        }

        @script.vars[0] =~ /^\s*(.+?)\s*(?:([;\/|])\s*(.*?)\s*)?$/
        filter = $1
        separator = $2
        commands = $3

        # Determine filter and container bits.
        unless filter =~ FILTER_PATTERN
            self.show_help((filter =~ /^help$/i) ? true : false)
            exit
        end

        filter_proc = nil
        filter_attr = ($1.downcase or 'type')
        filter_value = $2
        position = ($3 or $4)
        target = $5
        explicit_all = false  # Safety bypass.

        if filter_attr == 'type' and filter_value =~ /all|any|everything/i
            explicit_all = true
            filter_attr = nil
            filter_value = nil
        end

        filter_proc = self.build_filter(filter_value, filter_attr, target)
        unless filter_proc
            echo "Unknown attribute '#{filter_attr}'"
            exit
        end

        # Process commands
        lootsacks = nil

        if separator and commands
            commands = commands.split(/\s*#{Regexp::escape(separator)}\s*/)
            next_is_script = false
            new_commands = []
            commands.each_with_index{|command, ix|
                if command == ''  # Blank.
                    # Due to the split, a Lich script will appear as a blank command followed by the script invocation
                    # as the next command -- if the separator and $lich_char are the same.  Flag this for the next run
                    next_is_script = ($lich_char == separator)
                    # Continue to the next iteration rather than adding this command, too.
                    next
                end
                if next_is_script
                    next_is_script = false
                    # Convert to script invocation
                    command = "#{$lich_char}#{command}"
                end
                if command =~ /^(drop|place|sell|appraise|stash)$/i
                    # Add implicit ITEM if no modifiers.
                    command = "#{$1} item"
                end
                if command =~ /^stash\s+/i and not lootsacks
                    # Adapted from ;loot, with heavy modifications
                    lootsacks = self.find_sacks('lootsack')
                    unless lootsacks.length > 0  # Already did the search
                        echo "Failed to find any lootsacks, STASH will not work."
                        echo "Configure lootsacks with ;vars set lootsack=container, ;vars set lootsack2=container, etc...."
                        exit
                    end
                end
                if ix == 0
                    # Add implicit GETs if no modifiers.
                    if command =~ /^drop\s+item$/i
                        command = '_drag item drop'
                    elsif command =~ /^(?:giveitem)|^(?:(place|sell|app(?:raise)?)\s+item)$/i
                        if target =~ /^worn$/
                            new_commands << 'remove item'
                        else
                            new_commands << 'get item'
                        end
                    end
                end
                new_commands << command
                if commands.length == 1 and command =~ /^app(?:raise)?\s+item$/i
                    new_commands << 'return'
                end
            }
            commands = new_commands
        end

        # Find possible item IDs
        to_scan  = []
        to_filter = {}
        container_names = {nil => 'On the ground'}
        silence_me if $SAFE == 0


        if target =~ /^inv(?:entory)?$/i  # Entire inventory
            # Sanity check
            if commands.length > 0 and filter_value.nil?
                echo 'WARNING: THIS COMMAND WILL ACT ON EVERY ITEM THAT YOU HAVE IN YOUR ENTIRE INVENTORY!'
                if explicit_all
                    echo "'#{$lich_char}kill #{@script.name}' to abort!"
                    sleep 0.5  # A moment before it all scrolls off
                else
                    echo "If you REALLY want to do this, you must explicitly say so by using '#{$lich_char}#{@script.name} ALL in #{target}';..."
                    exit
                end
            end

            # Parse INV FULL output, sort of.
            data = self.quiet_command(
                'inv full',
                /^(?:You are carrying nothing at this time|You are currently wearing and carrying)/,
                /<prompt/,
                true,
                5
            )
            unless data
                echo "Inventory request timed out."
                exit
            end
            last_container = nil
            last_container_name = nil
            data.each{|xml|
                next unless xml =~ INVFULL_PATTERN
                # echo $~.inspect
                case $1.length
                    when 2
                        last_container = $3
                        last_container_name = $5
                    when 6
                        unless last_container
                            echo "I found an item in a container before I found my first container.  This shouldn't happen."
                            echo "Please save a copy of INV FULL and contact LostRanger"
                            exit
                        end
                        item = GameObj.new($3.dup, $4.dup, $5.dup, $2.dup, $6.dup)
                        unless to_filter[last_container]
                            to_filter[last_container] = []
                            container_names[last_container] = last_container_name
                        end
                        to_filter[last_container] << item
                    else
                        nil  # noop
                end
            }
        elsif target =~ /^(?:prev(?:ious)?|last)$/i  # Previous run
            unless @previous
                echo "No previous run data is available."
                exit
            end
            to_filter = @previous
            container_names = @previous_names
        elsif target =~ /^(?:loot|locker)$/i  # Loot/locker/containers on ground
            to_scan = GameObj.loot.map{|item| item.id}
            GameObj.loot.each{|item| container_names[item.id] = item.full_name}
        elsif target =~ /^(?:floor|ground|room)$/i  # Items on ground
            to_filter[nil] = GameObj.loot
        elsif target =~ /^worn$/i  # Worn items
            to_filter[nil] = GameObj.inv
            container_names[nil] = 'On your person'
        else   # A specific container
            stop_scripts
            xml = dothistimeout("look #{position} #{target}", 15, INV_PATTERN)
            unless xml =~ INV_PATTERN
                echo "Timed out waiting for inventory command."
                exit
            end
            exist = ($1 or $3)
            name = ($2 or $4)
            unless exist
                echo "Error locating item or item inventory."
                exit
            end
            unless GameObj.containers[exist]
                echo "Error loading item inventory."
                exit
            end
            to_filter[exist] = GameObj.containers[exist]
            container_names[exist] = name
        end

        if to_scan.length > 0
            stop_scripts
            remaining = to_scan.length
            echo "Scanning #{remaining} inventor#{remaining==1 ? 'y' : 'ies'}, please wait..."  # if $SAFE == 0
            # echo 'Scanning inventory...' if $SAFE == 0
            hook = self.anon_hook
            @in_sorted_view = false
            DownstreamHook.add(hook, proc {|xml| self.quiet_inv_scan_hook(xml)})
            to_scan.each{|exist|
                if remaining != to_scan.length and remaining % CONTAINER_UPDATE_INTERVAL == 0
                    echo "Still scanning #{remaining} inventor#{remaining==1 ? 'y' : 'ies'}, please wait..."  # if $SAFE == 0
                end
                remaining -= 1
                fput "look #{position} ##{exist}" }
            waitfor '<prompt'
            DownstreamHook.remove(hook)
            to_scan.each{|exist|
                to_filter[exist] = GameObj.containers[exist]
            }
        end

        resume_scripts
        silence_me if $SAFE == 0

        total_items = 0
        filtered = {}
        to_filter.each{|container, items|
            unless items.length > 0
                container_names.delete(container)
                next
            end
            items = items.find_all{|item| filter_proc.call(item)}
            unless items.length > 0
                container_names.delete(container)
                next
            end
            total_items += items.length
            filtered[container] = items
        }

        if total_items == 0
            echo 'No matching items found!'
            exit
        end

        @previous = filtered
        @previous_names = container_names

        before_next = nil  # Possibly skippable things to do before the next command.

        move_container_cache = {}

        processed_items = 0
        filtered.each{|container, items|
            # next unless items.length > 0
            # items = items.find_all{|item| filter.call(item)}
            # next unless items.length > 0
            if commands.length > 0
                items.each{|item|
                    ref = "##{item.id}"
                    if processed_items % ITEM_UPDATE_INTERVAL == 0
                        percent = (100.0 * processed_items / total_items).to_i
                        echo "Item #{processed_items + 1} of #{total_items}.  (#{percent}% complete)"
                    end
                    commands.each_with_index{|original, ix|
                        command = (
                            original
                            .gsub(/\bitem\b/i, ref)
                            .gsub(/\bnoun\b/i, item.noun)
                            .gsub(/\bname\b/i, item.name)
                            .gsub(/\bcontainer\b/i, ("##{container}"))
                        )
                        if command.start_with?($lich_char)
                            before_next.call if before_next
                            before_next = proc { waitrt? }
                            scriptname, args = command.split(/\s+/, 2)
                            scriptname = scriptname[1..-1]
                            echo "Running #{$lich_char}#{scriptname} #{args}"
                            Script.run(scriptname, args)
                        elsif command =~ COMMAND_PATTERNS[:move]
                            before_next.call if before_next
                            before_next = nil
                            fast = $1 ? true : false
                            what = ($2 or ref)
                            where = $3
                            holding = (what == ref and self.holding?(item.id))
                            floor = (where =~ /^(?:ground|floor)$/i) ? true : false
                            if what[0] == '#'
                                if floor
                                    fput "_drag #{what} drop"
                                    waitfor '<right>Empty', '<left>Empty'
                                    next
                                end
                                where = move_container_cache[where] if move_container_cache[where]
                                if where[0] == '#'
                                    fput "_drag #{what} #{where}"
                                    waitfor '<right>Empty', '<left>Empty'
                                    next
                                end
                            end
                            get_command = "get #{what}"
                            put_command = floor ? "place #{what}" : "put #{what} in #{where}"

                            unless holding
                                if fast
                                    put get_command
                                else
                                    fput get_command
                                end
                            end
                            if fast
                                put put_command
                            else
                                fput put_command
                            end
                            waitfor '<right>', '<left>'
                            next if floor

                            unless where[0] == '#' or move_container_cache.include?(where)
                                nil until get =~ /^(?:(?:<.*>)?You (?:put|absent-mindedly drop) (?:[^<]*)<a exist="(-?\d+).*?<\/a>.*<a exist="(-?\d+).*?<\/a)|<prompt/
                                move_container_cache[where] = ($2 and GameObj.inv.find{|x| x.id == $2}) ? "##{$2}" : false
                                # if $2
                                #     # echo "Learned that '#{where}' is ##{$2}"
                                #     if GameObj.inv.find{|x| x.id == $2}
                                #         # echo "Learned that '##{$2}' is an inventory container, and probably doesn't support ON/UNDER/BEHIND"
                                #         move_container_cache[where] = "##{$2}"
                                #     else
                                #         # echo "Learned that '##{$2}' is NOT an inventory container, and might support ON/UNDER/BEHIND"
                                #         move_container_cache[where] = false
                                #     end
                                # else
                                #     # echo "Learned that '#{where}' is probably a scripted container of some sort."
                                #     move_container_cache[where] = false
                                # end
                                # if $2
                                #     # echo "Learned that '#{where}' is ##{$2}"
                                #     if GameObj.inv.find{|x| x.id == $2}
                                #         # echo "Learned that '##{$2}' is an inventory container, and probably doesn't support ON/UNDER/BEHIND"
                                #         move_container_cache[where] = "##{$2}"
                                #     else
                                #         # echo "Learned that '##{$2}' is NOT an inventory container, and might support ON/UNDER/BEHIND"
                                #         move_container_cache[where] = false
                                #     end
                                # else
                                #     # echo "Learned that '#{where}' is probably a scripted container of some sort."
                                #     move_container_cache[where] = false
                                # end
                            end

                            #
                            #
                            #
                            #
                            #     fput "get #{what}" unless what == ref and self.holding?(item.id)
                            #     waitfor '<right>', '<left>'
                            # end
                            # if where =~ /^(?:ground|floor)$/i
                            #     fput "place #{what}"
                            # else
                            #     fput "put #{what} in #{where}"
                            # end
                            # waitfor '<right>', '<left>'
                        # elsif command =~ /^f(?:ast)?(?:move|mv)\s+(?:(.+)\s+)?to\s+(.*)$/i
                        #     before_next.call if before_next
                        #     before_next = nil
                        #     what = ($1 or ref)
                        #     where = $2
                        #     holding = (what == ref and self.holding?(item.id))
                        #     put "get #{what}" unless holding
                        #     put "put #{what} in #{where}"
                        #     waitfor '<right>', '<left>' unless holding
                        #     waitfor '<right>', '<left>'
                        elsif command =~ /^stash (.*$)/i
                            what = $1
                            success = false
                            lootsacks.length.times{
                                sack = lootsacks[0]
                                next unless GameObj.inv.find{|x| x.id == sack.id}
                                where = "##{sack.id}"
                                if what[0] == '#' and ix == 0
                                    fput "_drag #{what} #{where}"
                                else
                                    fput "get #{what}" if ix == 0
                                    fput "put #{what} in #{where}"
                                end
                                nil until get =~ /^Your .* won't fit in .*|<(left|right)>Empty</
                                waitfor '<prompt'
                                if $1
                                    success = true
                                    break
                                end
                                lootsacks << lootsacks.shift
                                # echo lootsacks.map{|x| x.name}.join('; ')
                            }
                            next if success
                            echo "All lootsacks are full, pausing script."
                            echo "#{$lich_char}unpause #{@script.name} to continue anyways, or abort with #{$lich_char}kill #{@script.name}"
                            pause_script
                        elsif command =~ /^echo (.*)$/i
                            before_next.call if before_next
                            before_next = nil
                            echo $1
                        elsif command =~ /^waitrt$/i
                            before_next = nil
                            waitrt
                        elsif command =~ /^waitfor (.*)$/i
                            script.want_downstream = true
                            script.want_downstream_xml = false
                            waitfor $1
                            before_next = proc { waitrt? }
                            script.want_downstream_xml = true
                            script.want_downstream = false
                        elsif command =~ /^waitre (.*)$/i
                            text = $1
                            flags = nil
                            if text =~ /\/(.+)\/(.*)$/
                                text = $1
                                flags = $2 unless $2 == ''
                            end
                            pattern = Regexp::new(text, flags)
                            nil until get =~ pattern
                            before_next = proc { waitrt? }
                        elsif command =~ /^pause$/i
                            percent = (100.0 * processed_items / total_items).to_i
                            msg = []
                            msg << '<output class="mono" />' if $stormfront
                            msg << "[#{@script.name}: Pausing at #{self.item_detail(item)},  (#{processed_items + 1} of #{total_items}, #{percent}% complete)."
                            msg << '<output class="" />' if $stormfront
                            puts msg.join("\n")
                            pause_script
                            before_next = proc { waitrt? }
                        elsif command =~ /^giveitem(?:\s+(?:to\s+)?(.+))?$/i
                            before_next.call if before_next
                            before_next = nil
                            unless $1
                                echo 'Give to whom?'
                                exit
                            end
                            fput "give ##{item.id} to #{$1}"
                            script.want_downstream = true
                            script.want_downstream_xml = false
                            waitfor /^#{$1} has accepted your offer/
                            script.want_downstream_xml = true
                            script.want_downstream = false
                        elsif command =~ /^return(?:\s+item)?$/i
                            before_next.call if before_next
                            before_next = nil
                            if container
                                fput "put #{ref} in ##{container}"
                            elsif target =~ /^worn$/i
                                fput "wear #{ref}"
                            else
                                fput "place #{ref}"
                            end
                            #     waitfor '<right>', '<left>'  # Wait for a hand change.
                            # end
                        else
                            before_next.call if before_next
                            before_next = proc { waitrt? }
                            fput command
                            before_next = proc { waitfor '<prompt'; waitrt? }
                        end
                    }
                    processed_items += 1
                }
            else
                msg = ['']
                header = "[#{container_names[container]}]: "
                if @stormfront
                    header = REXML::Text.new(header).to_s
                    msg << "<preset id=\"whisper\">#{header}</preset>"
                else
                    header = REXML::Text.new(header).to_s if @profanity
                    msg << monsterbold_start + header + monsterbold_end
                end
                items.each{|item|
                    msg << item_detail(item)
                }
                puts msg.join("\n")
            end
        }
        if commands.length == 0
            puts "\nTotal items: #{total_items}"
        end
    end

    def self.item_detail(item)
        if @stormfront
            noun = REXML::Text.new(item.noun).to_s
            text = REXML::Text.new("#{item.full_name} (#{item.type})").to_s
            return "<a exist=\"#{item.id}\" noun=\"#{noun}\">##{item.id}</a> #{text}"
        else
            text = "##{item.id} #{item.full_name} (#{item.type})"
            return REXML::Text.new(text).to_s if @profanity
            return text
        end
    end
end

if defined?(GameObj.type_data)
    GameObj.load_data if GameObj.type_data.empty? or GameObj.type_data.nil?
    if GameObj.type_data.nil?
        wait_while { running?('updater') }
        wait_while { running?('repository') }
        start_script 'repository', [ 'download', 'gameobj-data.xml' ]
        wait_while { running?('repository') }
        wait_while { running?('updater') }
        start_script 'updater', [ 'add', 'gameobj-data.xml' ]
        wait_while { running?('updater') }
        GameObj.load_data
        exit if GameObj.type_data.nil?
    end
end


ForeachScript.run(script)