=begin
  Documentation: TBD
=end

custom_require.call(%w(common common-items drinfomon))

class ScrollSearch
  include DRC
  include DRCI

  def initialize

  # Variables
  @scroll_count = 0
  @global_scroll_index = UserVars.scroll_counter || 0
  @owned_scrolls = UserVars.owned_scrolls.empty? ? {} : UserVars.owned_scrolls
    
  # RESET ALL
  # UserVars.owned_scrolls = { }
  # @owned_scrolls = { }
  # UserVars.scroll_counter = 0

  @settings = get_settings()
  @debug_mode_ssearch = @settings.debug_mode

  echo("Settings debug mode is: #{@debug_mode_ssearch}") if @debug_mode_ssearch
  if @settings.nil? || @settings.empty?
    echo("Settings was nil!") if @debug_mode_ssearch
  end

  arg_definitions = 
  [
    [
    { name: 'search', regex: /^sea.*/i, description: 'Searches given container and labels any unlabeled scrolls. ' },
    { name: 'container', regex: /\w+/i, description: 'The container to search. ' }
    ],
    [
    { name: 'list', regex: /^lis.*/i, optional: false, description: 'Lists all of the scrolls that have been categorized after a SEARCH. ' },
    ]
  ]

  args = parse_args(arg_definitions)

  pause

  if args.search
    if args.container.nil?
    echo_message("SPECIFY THE CONTAINER TO SEARCH!")
    return
    end

    search_container(args.container)
  elsif args.list
    if @owned_scrolls.length <= 0
    echo_message("NO SCROLLS HAVE BEEN ADDED! SEARCH YOUR CONTAINERS FIRST!")
      return
    end

    echo("Total scroll count is: #{@owned_scrolls.length}") if @debug_mode_ssearch
    display_scrolls()
  end
  end

  def search_container(container)
  # return if invalid container

  unless exists?(container)
    echo_message("INVALID CONTAINER")
    return
  end

  # Empty your hands
  stow_hands

  # Get long name of container
  $container_full = full_name(container)
  if $container_full =~ /Undefined/i
    echo("Was unable to retrieve the full name of container: #{container}.") if @debug_mode_ssearch
    $container_full = container
  end

  $container = get_noun($container_full)

  # iterate over all scroll types
  scroll_types = @settings.scroll_nouns

  if scroll_types.empty? || scroll_types.nil?
    echo_message("NO SCROLL NOUNS SET! SETUP YOUR YAML TO INCLUDE VALID \"scroll_nouns\".")
    return
  end

  echo("Scroll type count is: #{scroll_types.length}.") if @debug_mode_ssearch

  # Clear current scroll listing from owned scrolls if
  # user is searching an existing container
  if @owned_scrolls[$container_full]
    echo("Clearing scroll array for this container, since it was previously searched --- #{$container_full}!") if @debug_mode_ssearch
    @owned_scrolls[$container_full] = []
  end
  
  # reset scroll count
  @scroll_count = 0
  
  scroll_types.each do |scroll|
    echo "Searching for scrolls of type #{scroll}." if @debug_mode_ssearch

    scroll_list = get_scrolls(scroll)
    next if scroll_list.empty?

    look_scrolls(scroll_list)
  end

  # Save scrolls to user variables.
  if UserVars.owned_scrolls.nil? && @owned_scrolls.nil?
    echo("Creating an empty hash for vars!") if @debug_mode_ssearch
    UserVars.owned_scrolls = {}
    return
  end
  
  UserVars.owned_scrolls = @owned_scrolls
  UserVars.scroll_counter = @global_scroll_index
  
  echo ("Total scrolls added: #{@owned_scrolls.length}!") if @debug_mode_ssearch

  # Empty your hands
  stow_hands

  echo_message("SEARCH COMPLETED")
  end

  def display_scrolls()
  current_scrolls = UserVars.owned_scrolls

  if current_scrolls.length <= 0 || current_scrolls.nil?
    echo_message("NO SCROLLS TO DISPLAY -- SEARCH FIRST!")
    return
  end

  # Formatted Scroll listing
  echo("|#{' Scroll List '.center(73,'=')}|")
  echo("|#{'#'.center(5)}|#{'Scroll Name'.center(20)}|#{'Container'.center(30)}|#{'Type'.center(15)}|")
  echo("|#{''.center(73,'=')}|")

  # Iterate over scrolls to display
  current_scrolls.each do |container, scroll_array|
    scroll_array.each_with_index do |scroll_info, index|
    echo_scroll_list_line(scroll_info[:index], scroll_info[:spell], scroll_info[:container], scroll_info[:type])
    end
  end

  echo("|#{''.center(73,' ')}|")
  echo("|#{'(;send <get #> or ;send <transfer # to <container>>)'.center(73,' ')}|")
  echo("|#{''.center(73,'=')}|")

  line = get until line.strip =~ /^get\s+(\d+)$|^tran.+\s+(\d+)\s+to\s+(\w+)$/i

  case line
  when /^get\s+(\d+)$/i
    scroll_index = Regexp.last_match(1)
    echo("Scroll index is #{scroll_index}.") if @debug_mode_ssearch

    grab_scroll(scroll_index)
  when /^tran.+\s+(\d+)\s+to\s+(\w+)$/i
    scroll_index = Regexp.last_match(1)
    transfer_container = Regexp.last_match(2)

    echo("Index is #{scroll_index}. Transfer is: #{transfer_container}") if @debug_mode_ssearch

    transfer_scroll(scroll_index, transfer_container)
  end
  end

  # Private methods
  private

  def get_scrolls(scroll)
  scroll_noun = scroll
  parameter = "C #{scroll_noun}"
  scrolls = rummage(parameter, $container)
  return scrolls
  end

  def look_scrolls(all_scrolls)

  all_scrolls.each_with_index do |scroll, index|
    # TODO: Fix so we support more than DR's hard-limit of 12
    if index > 12 then next else end

    ordinal = $ORDINALS[index]

    case scroll_look = bput("look #{ordinal} #{scroll} in my #{$container}", 'It is labeled "\w*\s*\w*."', '.* of the \w*\s*\w* spell.', 'three-dimensional shapes cover much of the scroll', 'You see nothing unusual.', 'I could not find what you were referring to')
    when 'three-dimensional shapes cover much of the scroll' then read_scroll(scroll)
    when /It is labeled "(\w*\s*\w*)."/i
    spell_name = Regexp.last_match(1).empty? ? "Undefined" : Regexp.last_match(1)
    echo ("Spell is #{spell_name}") if @debug_mode_ssearch

    # If we cannot match, move on to the
    # next scroll
    if spell_name =~ /Undefined/i
      next
    end
    
    new_scroll =
    {
      :container => "#{$container_full}",
      :index => @global_scroll_index,
      :container_index => index,
      :ordinal => "#{ordinal}",
      :spell => "#{spell_name}",
      :type => "#{scroll}"
    }

    # Get list of scrolls for this container
    scroll_array = []
    
    if @owned_scrolls.key? ($container_full)
      scroll_array = @owned_scrolls[$container_full]
      
      scroll_array.push(new_scroll)
      echo("1. Scroll size is #{scroll_array.length}") if @debug_mode_ssearch
    else
      scroll_array.push(new_scroll)
      echo("2. Scroll size is #{scroll_array.length}") if @debug_mode_ssearch
    end
    
    echo("Adding scroll array of size #{scroll_array.length} to hash.") if @debug_mode_ssearch
    @owned_scrolls[$container_full] = scroll_array
    end

    @scroll_count += 1
    @global_scroll_index += 1
  end
  end

  def read_scroll(scroll)
  # TODO: Fix
  the_ordinal = $ORDINALS[@scroll_count]
  bput("get #{the_ordinal} #{scroll} from my #{$container}", 'You get')

  #case bput("read #{scroll}", 'The writing is too small', )
  #when 'The writing is too small' then hold_scroll(scroll)
  end

  def transfer_scroll(index, container)
  # Retrieve scroll info 
  scroll_info = get_scroll_info(index)

  echo("Got scroll info with spell: #{scroll_info[:spell]}") if @debug_mode_ssearch

  # Get previous values
  cur_scroll_container = get_noun(scroll_info[:container])
  cur_scroll_ordinal = scroll_info[:ordinal]
  cur_scroll_type = scroll_info[:type]

    # Make sure containers are opened
    bput("open my #{container}", 'That is already open', 'You open', 'You can\'t open that')
    bput("open my #{cur_scroll_container}", 'That is already open', 'You open')

    bput("get #{cur_scroll_ordinal} #{cur_scroll_type} from my #{cur_scroll_container}", 'You get')

  # Reorder the origin container
  reorder_container(scroll_info[:container], scroll_info, true)
  resave_container(scroll_info[:container], scroll_info, true)
  
  container_noun = container
  container = full_name(container)

  # Just warn the user if we cannot get
  # the full name of the container for some reason.
  if container =~ /Undefined/i
    echo("Was unable to retrieve the full name of this container...") if @debug_mode_ssearch
  end
  
  # Reorder destination container
  reorder_container(container, scroll_info, false)
  
  bput("put my #{cur_scroll_type} in my #{container_noun}", 'You put')
  
  # Transferred scrolls will always have a "first" ordinal
  scroll_info[:ordinal] = $ORDINALS[0]
  scroll_info[:container_index] = 0
  
  # Edit scroll information
  scroll_info[:container] = container
  
  # Resave scroll info
  resave_container(container, scroll_info, false)

  echo_message("SCROLL WAS TRANSFERRED!")
  end

  def reorder_container(container, scroll_info, wasRemoved)
  parameter = "C #{scroll_info[:type]}"
  scrolls = rummage(parameter, get_noun(container))
  
  echo("Scroll count of those matching the type (#{scroll_info[:type]}) is: #{scrolls.length}.") if @debug_mode_ssearch
  
  scrolls_in_container = @owned_scrolls[container]
  scrolls_in_container.each do |scroll_information|
  
    if scroll_information[:type] != scroll_info[:type]
      next
    end
    
    if scroll_information[:index] == scroll_info[:index]
      next
    end
    
    if wasRemoved
    if scroll_information[:container_index] > scroll_info[:container_index] && scroll_information[:container_index] > 0
      new_index = scroll_information[:container_index] - 1
      new_ordinal = $ORDINALS[new_index]
    else
      new_index = scroll_information[:container_index]
      new_ordinal = $ORDINALS[new_index]
    end
    else
    new_index = scroll_information[:container_index] + 1
    new_ordinal = $ORDINALS[new_index]
    end
    
    echo("New ordinal and index for scroll (#{scroll_information[:spell]}) is: #{new_index} - #{new_ordinal}.") if @debug_mode_ssearch
    
    scroll_information[:ordinal] = new_ordinal
    scroll_information[:container_index] = new_index
  end
  end

  def resave_container(container, scroll_info, remove)
  
  # if wasRemoved is true, we remove the scroll from
  # the container. If not, we simply add it to the container specified.
  
  if remove
    scrolls_in_container = @owned_scrolls[scroll_info[:container]]
    removed = scrolls_in_container.delete(scroll_info)
    unless removed
      echo_message("COULD NOT TRANSFER SCROLL TO NEW CONTAINER")
    exit
    else
    echo("Deleting scroll #{removed[:spell]} from container #{scroll_info[:container]}") if @debug_mode_ssearch
    # Re-save owned scrolls listing
    @owned_scrolls[scroll_info[:container]] = scrolls_in_container
      
    # Re-save user variables
    UserVars.owned_scrolls = @owned_scrolls
    end
  else
    echo ("Attempting to add scroll #{scroll_info[:spell]} to container #{container}.") if @debug_mode_ssearch
    
    my_scroll_list = []

    if @owned_scrolls.key? (container)
    my_scroll_list = @owned_scrolls[container]
    end

    my_scroll_list.push(scroll_info)
    unless my_scroll_list.length > 0
      echo_message("COULD NOT ADD SCROLL TO CONTAINER")
    exit
    else
    echo("Adding scroll #{scroll_info[:spell]} to container #{container}. Length of array is #{my_scroll_list.length}") if @debug_mode_ssearch
    # Re-save owned scrolls listing
    @owned_scrolls[container] = my_scroll_list
      
    # Re-save user variables
    UserVars.owned_scrolls = @owned_scrolls
      
    # List scrolls
    my_scroll_list.each do |scroll_array|
      echo("Scrolls in container is #{scroll_array[:spell]}") if @debug_mode_ssearch
    end
      
    # List everything
    @owned_scrolls.each do |container, scroll_array|
      scroll_array.each do |scroll_information|
      echo("Container #{container} | #{scroll_information[:spell]}") if @debug_mode_ssearch
      end
    end
    end
  end
  end
  
  def grab_scroll(index)
  echo ("Index in grab scroll of scroll is: #{index}.") if @debug_mode_ssearch
  
    # Retrieve scroll info 
  scroll_info = get_scroll_info(index)
  echo("Got scroll info with spell: #{scroll_info[:spell]}") if @debug_mode_ssearch

  # Get previous values
  cur_scroll_container = get_noun(scroll_info[:container])
  cur_scroll_ordinal = scroll_info[:ordinal]
  cur_scroll_type = scroll_info[:type]

  bput("open my #{cur_scroll_container}", 'That is already open', 'You open')
  bput("get #{cur_scroll_ordinal} #{cur_scroll_type} from my #{cur_scroll_container}", 'You get')
  
  # Reorder container
  reorder_container(scroll_info[:container], scroll_info, true)
  
  # Remove this scroll from our hash map
  scrolls_in_container = @owned_scrolls[scroll_info[:container]]
  
  echo("Scrolls in container count is: #{scrolls_in_container.length}") if @debug_mode_ssearch

  scrolls_in_container.select { |scroll_information|
    scroll_information[:index] == index.to_i}.each do |scroll_info|
      echo ("Found scroll we want to remove from listing... #{scroll_info[:spell]}") if @debug_mode_ssearch
      scrolls_in_container.delete(scroll_info)
  end
    
  # Re-save owned scrolls listing
  @owned_scrolls[scroll_info[:container]] = scrolls_in_container
  
  # Re-save user variables
  UserVars.owned_scrolls = @owned_scrolls

  echo_message("SCROLL WAS GRABBED!")
  end
  
  def full_name(noun)
  noun_name = bput("tap #{noun}", '^You tap ((\w+\s*\W*)+) (that|inside)\s*.*')
  noun_name =~ /^You tap ((\w+\s*\W*)+) (that|inside)\s*.*/i

  if Regexp.last_match(3).include? ("inside")
    bput("get #{noun}", 'You get')
  end
  
  name_full = Regexp.last_match(1).empty? ? "Undefined" : Regexp.last_match(1)
  
  return name_full
  end

  def get_scroll_info(index)
  # Retrieve scroll info 
  current_scrolls = UserVars.owned_scrolls
  
  the_scroll = nil
  
  current_scrolls.each do |container, scroll_array|
    the_scroll = scroll_array.find { |scroll_info| scroll_info[:index] == index.to_i }

    unless the_scroll.nil?
      echo ("Found scroll info : #{the_scroll[:spell]}") if @debug_mode_ssearch
      break
    end
  end
  
  echo("The scroll is: #{the_scroll[:spell]}") #if @debug_mode_ssearch
  
  unless the_scroll
    echo_message("INVALID SCROLL NUMBER")
    exit
  end
  
  return the_scroll
  end

  def echo_scroll_list_line(index, name, container, type)
  echo("|#{index.to_s.center(5)}|#{name.center(20)}|#{container.center(30)}|#{type.center(15)}|")
  end
  
  def format_bar(padding, value)
  sprintf("%#{padding}s", value.to_s)
  end

  def echo_message(msg)
  echo("*** #{msg} ***")
  end
end

# Call this last to avoid the need for forward declarations
ScrollSearch.new